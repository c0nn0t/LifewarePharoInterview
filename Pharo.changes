----QUIT----2019-03-15T14:54:38.352971+01:00 Pharo7.0-SNAPSHOT-32bit-9f17218.image priorSource: 0!----QUIT----2019-03-15T14:54:52.90449+01:00 Pharo7.0-SNAPSHOT-32bit-9f17218.image priorSource: 0!!CarRentalTest commentStamp: 'LWhr 3/28/2017 16:21' prior: 0!To execute a test, click on the circle next to its name. If it is green, the test passed. In any other case a debug windows will open. Close the debug window,  and the circle will color in yellow or red. A test is yellow when the received value is different from the expected value. A test is red when the code crashes.The tests are organized in "protocols", navigate through them to see all the exercises.!!Car commentStamp: 'LWhr 3/28/2017 14:51' prior: 0!we don't comment, we test!!!!CarRental commentStamp: 'LWhr 3/28/2017 14:51' prior: 0!we don't comment, we test!!!!ManifestLifewareHR commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!CarRentalTest methodsFor: '1.1 examples ' stamp: 'Anonymous 4/4/2017 17:43'!testBooleanCondition	| counter |	counter := OrderedCollection new.	1 > 0		ifTrue: [ counter add: 1 ]		ifFalse: [ counter add: 2 ].	self assert: counter first = 1! !!CarRentalTest methodsFor: '2 exercise' stamp: 'LWhr 3/28/2017 15:19'!testDiscountedPrice	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	"extend the code to make this test green"	| carRental myGolf |	carRental := CarRental new.	myGolf := Car golf.	self assert: (carRental priceFor: myGolf days: 4) = 390! !!CarRentalTest methodsFor: '3 exercise' stamp: 'LWhr 3/28/2017 15:29'!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.	self assert: carRental totalCars size = 3! !!CarRentalTest methodsFor: '0 examples' stamp: 'LWhr 3/28/2017 14:59'!testPandaPrice	| panda |	panda := Car panda.	self assert: panda price = 50! !!CarRentalTest methodsFor: '0 examples' stamp: 'LWhr 3/28/2017 15:16'!testRentPanda	| carRental myPanda |	carRental := CarRental new.	myPanda := Car panda.	self assert: (carRental priceFor: myPanda days: 3) = 150! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'LWhr 3/28/2017 16:01'!testRentTesla	"to be completed"	self assert: false "remove me"! !!CarRentalTest methodsFor: '3 exercise' stamp: 'LWhr 3/28/2017 15:37'!testRenting	"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: carRental availableCars size = 3.	carRental rent: redPanda days: 5.	self assert: carRental availableCars size = 2.	self assert: carRental rentedCars size = 1! !!CarRentalTest methodsFor: '4 exercise' stamp: 'LWhr 3/28/2017 16:01'!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3, 2 tesla and 1 golf. Customer Bob call our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"	self error. "remove this"! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'LWhr 3/28/2017 16:01'!testTeslaPrice	"to be completed"	self assert: false "remove me"! !!Car class methodsFor: 'instance creation' stamp: 'LWhr 3/28/2017 15:17'!golf	^ self price: 100! !!Car class methodsFor: 'instance creation' stamp: 'LWhr 3/28/2017 14:50'!panda	^ self price: 50! !!Car class methodsFor: 'instance creation' stamp: 'LWhr 3/28/2017 14:48'!price: aPrice	^ self new setPrice: aPrice! !!Car class methodsFor: 'instance creation' stamp: 'LWhr 3/28/2017 14:51'!tesla	^ self price: 400! !!Car methodsFor: 'accessor' stamp: 'LWhr 3/28/2017 14:47'!price	^ price! !!Car methodsFor: 'accessor' stamp: 'LWhr 3/28/2017 14:49'!price: aPrice	price := aPrice! !!Car methodsFor: 'initialization' stamp: 'LWhr 3/28/2017 14:48'!setPrice: aPrice	price := aPrice! !!CarRental class methodsFor: 'instance creation' stamp: 'LWhr 3/28/2017 15:25'!new	^ super new initialize! !!CarRental methodsFor: 'initialization' stamp: 'LWhr 3/28/2017 15:26'!initialize	cars := OrderedCollection new! !!CarRental methodsFor: 'action' stamp: 'LWhr 3/28/2017 15:03'!priceFor: aCar days: anInteger	| price |	price := aCar price * anInteger.	^ price! !!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'LWhr 3/28/2017 16:27'!ruleRBVariableReferencedOnceRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#CarRental)) #'2017-03-28T16:27:43.377446+02:00') )! !"LifewareHR"!!CarRentalTest methodsFor: '1.1 examples ' stamp: 'VincentBlondeau 3/22/2019 14:42' prior: 33555547!testBooleanCondition	| counter |	counter := OrderedCollection new.	1 > 0		ifTrue: [ counter add: 1 ]		ifFalse: [ counter add: 2 ].	self assert: counter first equals: 1! !!CarRentalTest methodsFor: '2 exercise' stamp: 'VincentBlondeau 3/22/2019 14:42' prior: 33555789!testDiscountedPrice	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	"extend the code to make this test green"	| carRental myGolf |	carRental := CarRental new.	myGolf := Car golf.	self assert: (carRental priceFor: myGolf days: 4) equals: 390! !!CarRentalTest methodsFor: '3 exercise' stamp: 'VincentBlondeau 3/22/2019 14:42' prior: 33556138!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.	self assert: carRental totalCars size equals: 3! !!CarRentalTest methodsFor: '0 examples' stamp: 'VincentBlondeau 3/22/2019 14:42' prior: 33556543!testPandaPrice	| panda |	panda := Car panda.	self assert: panda price equals: 50! !!CarRentalTest methodsFor: '0 examples' stamp: 'VincentBlondeau 3/22/2019 14:42' prior: 33556695!testRentPanda	| carRental myPanda |	carRental := CarRental new.	myPanda := Car panda.	self assert: (carRental priceFor: myPanda days: 3) equals: 150! !!CarRentalTest methodsFor: '3 exercise' stamp: 'VincentBlondeau 3/22/2019 14:43' prior: 33557067!testRenting	"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: carRental availableCars size equals: 3.	carRental rent: redPanda days: 5.	self assert: carRental availableCars size = 2.	self assert: carRental rentedCars size = 1! !!CarRentalTest methodsFor: '3 exercise' stamp: 'VincentBlondeau 3/22/2019 14:43' prior: 33561462!testRenting	"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: carRental availableCars size equals: 3.	carRental rent: redPanda days: 5.	self assert: carRental availableCars size equals: 2.	self assert: carRental rentedCars size equals: 1! !CarRental class removeSelector: #new!----SNAPSHOT----2019-03-22T14:45:56.066505+01:00 Pharo 7.0 - 64bit Lifeware.image priorSource: 100!TestCase subclass: #CarRentalTest	instanceVariableNames: ''	classVariableNames: ''	package: 'LifewareHR-Tests'!Object subclass: #Car	instanceVariableNames: 'price'	classVariableNames: ''	package: 'LifewareHR-Core'!PackageManifest subclass: #ManifestLifewareHR	instanceVariableNames: ''	classVariableNames: ''	package: 'LifewareHR-Manifest'!----SNAPSHOT----2019-03-22T14:46:59.112505+01:00 Pharo 7.0 - 64bit Lifeware.image priorSource: 8304!----SNAPSHOT----2019-03-22T14:47:54.273505+01:00 Pharo 7.0 - 64bit Lifeware.image priorSource: 8760!Smalltalk globals removeClassNamed: #AnObsoleteManifestLifewareHR!----SNAPSHOT----2019-03-22T15:38:21.787505+01:00 Pharo 7.0 - 64bit Lifeware.image priorSource: 8862!----QUIT----2019-03-22T16:02:15.274505+01:00 Pharo 7.0 - 64bit Lifeware.image priorSource: 9032!----QUIT----2019-03-22T16:02:58.05767+01:00 Pharo 7.0 - 64bit Lifeware.image priorSource: 9134!!ProfStef class methodsFor: 'as yet unclassified' stamp: 'Anonymous 6/19/2019 21:45' prior: 54907577!goToNextLesson  self next! !ProfStef class removeSelector: #goToNextLesson!!PharoSyntaxTutorial methodsFor: 'interactive' stamp: 'Anonymous 6/19/2019 21:54' prior: 54195919!divideTwoByZero		"Oops!! 2/0 raises a ZeroDivide exception. So the debugger opens to let you fix the code.	- Remove the line of code above.	- Right-click and select 'Accept' to compile the new version of the method	- click the button 'Proceed' to continue execution."	ProfStef next. ! !!CarRentalTest methodsFor: '0 examples' stamp: 'Anonymous 6/19/2019 22:01' prior: 33561023!testPandaPrice	| panda |	panda := Car panda.	panda setPrice: 50.	self assert: panda price equals: 50! !!CarRentalTest methodsFor: '0 examples' stamp: 'JerriNummenpalo 6/19/2019 22:02' prior: 33564430!testPandaPrice	| panda |	panda := Car panda.	self assert: panda price equals: 50! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 22:02' prior: 33556927!testRentTesla	"to be completed"! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 22:02' prior: 33564832!testRentTesla	"to be completed"	^ true.! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 22:02' prior: 33564978!testRentTesla	"to be completed"	^ true! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 22:06' prior: 33558450!testTeslaPrice	"to be completed"	self assert: true! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 22:06' prior: 33565132!testRentTesla	"to be completed"	self assert: true! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 22:09' prior: 33565285!testTeslaPrice	"to be completed"	self assert: false! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 22:09' prior: 33565451!testRentTesla	"to be completed"	self assert: false! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 23:03' prior: 33565781!testRentTesla	| tesla |	tesla := Car tesla.	self assert: tesla price equals: 50! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 23:03' prior: 33565615!testTeslaPrice	| tesla |	tesla := Car tesla.	self assert: tesla price equals: 400! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 23:05' prior: 33565946!testRentTesla	| carRental myTesla |	carRental := CarRental new.	myTesla := Car panda.	self assert: (carRental priceFor: myTesla days: 3) equals: 1200! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 23:05' prior: 33566338!testRentTesla	^false! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 23:05' prior: 33566604!testRentTesla	| carRental myTesla |	carRental := CarRental new.	myTesla := Car panda.	self assert: (carRental priceFor: myTesla days: 3) equals: 1200! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 23:06' prior: 33566738!testRentTesla	| carRental myTesla |	carRental := CarRental new.	myTesla := Car tesla.	self assert: (carRental priceFor: myTesla days: 3) equals: 1200! !!CarRental methodsFor: 'action' stamp: 'JerriNummenpalo 6/19/2019 23:13' prior: 33559506!priceFor: aCar days: anInteger	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	price := (aCar price * anInteger) -  ((anInteger - 3 max: 0) * aCar price * 0.1).	^ price! !!CarRental methodsFor: 'action' stamp: 'JerriNummenpalo 6/19/2019 23:21' prior: 33567251!priceFor: aCar days: anInteger	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	"price := (aCar price * anInteger) -  ((anInteger - 3 max: 0) * aCar price * 0.1)."	"Alternatively we could write"	price := 	(anInteger < 4)		ifTrue: [ aCar price * anInteger ]		ifFalse: [ aCar price * 3 + (anInteger - 3 * aCar price * 0.9) ].	^ price! !!CarRental methodsFor: 'action' stamp: 'JerriNummenpalo 6/19/2019 23:23' prior: 33567560!priceFor: aCar days: anInteger	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	"price := (aCar price * anInteger) -  ((anInteger - 3 max: 0) * aCar price * 0.1)."	"Alternatively we could write"	price := aCar price * anInteger.	(anInteger > 3)		ifTrue: [ price -= anInteger - 3 * aCar price * 0.1 ].	^ price! !!CarRental methodsFor: 'action' stamp: 'JerriNummenpalo 6/19/2019 23:24' prior: 33568036!priceFor: aCar days: anInteger	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	"price := (aCar price * anInteger) -  ((anInteger - 3 max: 0) * aCar price * 0.1)."	"Alternatively we could write"	price := aCar price * anInteger.	(anInteger > 3)		ifTrue: [ price -= (anInteger - 3 * aCar price * 0.1) ].	^ price! !!CarRental methodsFor: 'action' stamp: 'JerriNummenpalo 6/19/2019 23:28' prior: 33568487!priceFor: aCar days: anInteger	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	"price := (aCar price * anInteger) -  ((anInteger - 3 max: 0) * aCar price * 0.1)."	"Alternatively we could write"	price := aCar price * anInteger.	(anInteger > 3)		ifTrue: [ price - (anInteger - 3 * aCar price * 0.1) ].	^ price! !!CarRental methodsFor: 'action' stamp: 'JerriNummenpalo 6/19/2019 23:30' prior: 33568940!priceFor: aCar days: anInteger	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	"price := (aCar price * anInteger) -  ((anInteger - 3 max: 0) * aCar price * 0.1)."	"Alternatively we could write"	price := aCar price * anInteger.	price := price - 	(anInteger > 3)		ifTrue: [ (anInteger - 3 * aCar price * 0.1) ]		ifFalse: [ 0 ].	^ price! !!CarRental methodsFor: 'action' stamp: 'JerriNummenpalo 6/19/2019 23:33' prior: 33569392!priceFor: aCar days: anInteger	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	"price := (aCar price * anInteger) -  ((anInteger - 3 max: 0) * aCar price * 0.1)."	"Alternatively we could write"	price := aCar price * anInteger.	(anInteger > 3)		ifTrue: [ price := price - (anInteger - 3 * aCar price * 0.1) ].	^ price! !!ManifestLifewareHR commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JerriNummenpalo 6/19/2019 23:34'!ruleRBPrecedenceRuleV1FalsePositive	^ #()! !!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JerriNummenpalo 6/19/2019 23:34' prior: 33570534!ruleRBPrecedenceRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#CarRental #priceFor:days: #false)) #'2019-06-19T23:34:19.72379+02:00') )! !!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JerriNummenpalo 6/19/2019 23:34'!ruleRBUtilityMethodsRuleV1FalsePositive	^ #()! !!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JerriNummenpalo 6/19/2019 23:34' prior: 33570930!ruleRBUtilityMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#CarRental #priceFor:days: #false)) #'2019-06-19T23:34:26.64221+02:00') )! !!CarRental methodsFor: 'action' stamp: 'JerriNummenpalo 6/19/2019 23:34' prior: 33569872!priceFor: aCar days: anInteger	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	price := aCar price * anInteger.	(anInteger > 3)		ifTrue: [ price := price - (anInteger - 3 * aCar price * 0.1) ].	"Alternatively we could write in one line"	"price := (aCar price * anInteger) -  ((anInteger - 3 max: 0) * aCar price * 0.1)."	^ price! !!CarRental methodsFor: 'as yet unclassified' stamp: 'JerriNummenpalo 6/19/2019 23:39'!addCar	"comment stating purpose of message"	| temporary variable names |	^true! !!CarRental methodsFor: 'adding' stamp: 'JerriNummenpalo 6/19/2019 23:42'!addCar: newCar	cars add: newCar! !!CarRental methodsFor: 'as yet unclassified' stamp: 'JerriNummenpalo 6/19/2019 23:43'!totalCars	^cars size! !CarRentalTest removeSelector: #testFixedNumberOfCars!!CarRentalTest methodsFor: 'nil' stamp: 'JerriNummenpalo 6/19/2019 23:52'!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.	carRental totalCars.	self assert: carRental totalCars size equals: 3! !!CarRentalTest methodsFor: 'as yet unclassified' stamp: 'JerriNummenpalo 6/19/2019 23:53' prior: 33572237!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.	self assert: carRental totalCars size equals: 3! !!CarRentalTest methodsFor: 'as yet unclassified' stamp: 'JerriNummenpalo 6/19/2019 23:53' prior: 33572706!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.	self assert: carRental totalCars size equals: 3! !!CarRentalTest methodsFor: 'as yet unclassified' stamp: 'JerriNummenpalo 6/19/2019 23:54' prior: 33573153!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.	self assert: carRental totalCars size equals: 3! !CarRental removeSelector: #addCar!!CarRentalTest methodsFor: 'as yet unclassified' stamp: 'JerriNummenpalo 6/19/2019 23:59' prior: 33573600!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.		self assert: carRental totalCars size equals: 3! !!CarRental methodsFor: 'accessing' stamp: 'JerriNummenpalo 6/20/2019 00:00' prior: 33572082!totalCars	^cars! !----QUIT----2019-06-20T00:04:43.795085+02:00 Pharo.image priorSource: 1283!!CarRental methodsFor: 'action' stamp: 'JN 6/20/2019 10:42' prior: 33571329!priceFor: aCar days: anInteger	| price |	price := aCar price * anInteger.	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	(anInteger > 3)		ifTrue: [ price := price - (anInteger - 3 * aCar price * 0.1) ].	^ price! !Object subclass: #Car	instanceVariableNames: 'price type'	classVariableNames: ''	package: 'LifewareHR-Core'!!Car methodsFor: 'as yet unclassified' stamp: 'JN 6/20/2019 11:57'!type: aType	type := aType! !!Car methodsFor: 'as yet unclassified' stamp: 'JN 6/20/2019 11:57'!setType: aType	type := aType! !!Car methodsFor: 'initialization' stamp: 'JN 6/20/2019 11:58'!type	^type! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/20/2019 11:59' prior: 33558594!golf	self type = 'golf'.	^ self price: 100! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/20/2019 12:00' prior: 33575424!golf	self type: 'golf'.	^ self price: 100! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/20/2019 12:00' prior: 33575560!golf	self type: 'golf'.	^ self price: 100! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/20/2019 12:06' prior: 33558916!tesla	"| newCar |	newCar := self new.	newCar price: 400; type: 'tesla'."	^ self price: 400; type: 'tesla'! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/20/2019 12:06' prior: 33575830!tesla	^ self price: 400; type: 'tesla'! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/20/2019 12:06' prior: 33576031!tesla	| newCar |	newCar := self new.	newCar price: 400; type: 'tesla'.	^ newCar	"^ self price: 400; type: 'tesla'"! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/20/2019 12:08' prior: 33575695!golf	| newCar |	newCar := self new.	newCar price: 100; type: 'golf'.	^ newCar	"^ self price: 100"! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/20/2019 12:10' prior: 33558695!panda	| newCar |	newCar := self new.	newCar price: 50; type: 'panda'.	^ newCar	"^ self price: 50"! !!CarRental methodsFor: 'initialization' stamp: 'JN 6/20/2019 12:18' prior: 33559398!initialize	cars := Set new! !Object subclass: #CarRental	instanceVariableNames: 'cars numTotalCars'	classVariableNames: ''	package: 'LifewareHR-Core'!!CarRental methodsFor: 'initialization' stamp: 'JN 6/20/2019 12:20' prior: 33576758!initialize	cars := Set new.	numTotalCars := 0! !!CarRentalTest methodsFor: 'as yet unclassified' stamp: 'JN 6/20/2019 12:21' prior: 33574083!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.		self assert: carRental totalCars equals: 3! !!CarRentalTest methodsFor: 'as yet unclassified' stamp: 'JN 6/20/2019 12:22' prior: 33577145!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.		self assert: carRental totalCars size equals: 3! !!CarRental methodsFor: 'initialization' stamp: 'JN 6/20/2019 12:23' prior: 33577000!initialize	cars := OrderedCollection new.	numTotalCars := 0! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/20/2019 12:26' prior: 33557695!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob call our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"	self error. "remove this"! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/20/2019 12:26' prior: 33578153!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"	self error. "remove this"! !----QUIT----2019-06-21T00:28:58.2952+02:00 Pharo.image priorSource: 20105!!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:43'!price: aPrice type: aType	^ self new 		setPrice: aPrice; 		setType: aType! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:43' prior: 33576567!panda	"| newCar |	newCar := self new.	newCar price: 50; type: 'panda'.	^ newCar"	^ self price: 50 type: 'panda'! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:45' prior: 33576373!golf	^ self price: 100 type: 'golf'! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:45' prior: 33579915!panda	^ self price: 50 type: 'panda'! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:46' prior: 33576162!tesla	^ self price: 400; type: 'tesla'! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:46' prior: 33580380!tesla	^ self price: 400 type: 'tesla'! !!CarRentalTest methodsFor: 'as yet unclassified' stamp: 'JN 6/22/2019 10:46' prior: 33577576!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.		self assert: carRental totalCars size equals: 3! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:48' prior: 33580123!golf	^ self price: 100 type: 'golf'! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:57' prior: 33580511!tesla	^ self price: 400 type: #tesla! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:58' prior: 33580251!panda	^ self price: 50 type: #panda! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:58' prior: 33581077!golf	^ self price: 100 type: #golf! !Object subclass: #CarRental	instanceVariableNames: 'cars numTotalCars carRentalDates'	classVariableNames: ''	package: 'LifewareHR-Core'!!CarRental methodsFor: 'initialization' stamp: 'JN 6/22/2019 11:48' prior: 33578003!initialize	cars := OrderedCollection new.	numTotalCars := 0.	"The dictionary maps a Car to a Sorted collection of Points, each of which contains the starting and ending dates of rental periods as their x and y coordinates, respectively. These rental periods are non-overlapping for each given car."	carRentalDates = Dictionary new! !!CarRental methodsFor: 'initialization' stamp: 'JN 6/22/2019 11:48' prior: 33581727!initialize	cars := OrderedCollection new.	numTotalCars := 0.	"The dictionary maps a Car to a Sorted collection of Points, each of which contains the starting and ending dates of rental periods as their x and y coordinates, respectively. These rental periods are non-overlapping for each given car."	carRentalDates := Dictionary new! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 11:50'!isAvailable: car startingOn: date ForDays: numDays	! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 11:50' prior: 33582550!isAvailable: car startingOn: date ForDays: numDays		! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 11:54' prior: 33582683!isAvailable: car startingOn: date ForDays: numDays	carRentalDates includesKey: car		ifFalse: [ ^false ].! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 11:55' prior: 33582817!isAvailable: car startingOn: date ForDays: numDays	(carRentalDates includesKey: car)		ifFalse: [ ^false ].! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 11:57' prior: 33583004!isAvailable: car startingOn: date ForDays: numDays	| rentalDates |	rentalDates := (carRentalDates at: car ifAbsent: [^false]).! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 11:57' prior: 33583193!isAvailable: car startingOn: date ForDays: numDays	| rentalDates |.	rentalDates := (carRentalDates at: car ifAbsent: [^false]).! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 11:57' prior: 33583402!isAvailable: car startingOn: date ForDays: numDays	| rentalDates |	rentalDates := (carRentalDates at: car ifAbsent: [^false]).! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 11:58' prior: 33583612!isAvailable: car startingOn: date ForDays: numDays	| rentalDates |	rentalDates := (carRentalDates at: car ifAbsent: [^false]).	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 11:59'!isAvailable: car startingOn: date forDays: numDays	| rentalDates |	rentalDates := (carRentalDates at: car ifAbsent: [^false]).		^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:09' prior: 33584022!isAvailable: car startingOn: date forDays: numDays	| rentalDates |	rentalDates := (carRentalDates at: car ifAbsent: [^false]).	rentalDates findBinary: (date@date) dp: [ ^false ] ifNone: [ ^true ].		^ true! !!CarRental methodsFor: 'adding' stamp: 'JN 6/22/2019 12:11' prior: 33571959!addCar: newCar	cars add: newCar.	carRentalDates at: newCar put: SortedCollection new.	! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:11' prior: 33584241!isAvailable: car startingOn: date forDays: numDays	| rentalDates |	rentalDates := (carRentalDates at: car ifAbsent: [^false]).	rentalDates findBinary: (date@date) do: [ ^false ] ifNone: [ ^true ].		^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:38' prior: 33584700!isAvailable: car startingOn: date forDays: numDays	"Returns true if the requested car can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalDates |	"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."	rentalDates := (carRentalDates at: car ifAbsent: [^false]).		"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."	rentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] 		ifNone: [:previousRental :nextRental | 			((previousRental ~= nil) & (previousRental y >= date))				ifTrue: [ ^ false ].			((nextRental ~= nil) & (nextRental x < (date + numDays)))				ifTrue: [ ^ false ].		].	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:38' prior: 33584990!isAvailable: car startingOn: date forDays: numDays	"Returns true if the requested car can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalDates |	"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."	rentalDates := (carRentalDates at: car ifAbsent: [^false]).		"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."	rentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] 		ifNone: [:previousRental :nextRental | 			((previousRental notNil) & (previousRental y >= date))				ifTrue: [ ^ false ].			((nextRental notNil) & (nextRental x < (date + numDays)))				ifTrue: [ ^ false ].		].	^ true! !CarRental removeSelector: #isAvailable:startingOn:ForDays:!!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:43'!rent: car days: numDays	"Tries to rent the given car for the given number of days."	"Returns true upon success and false otherwise."	| temporary variable names |	(self isAvailable: car startingOn: Date today forDays: numDays)		ifFalse: [ ^false ].		^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:44' prior: 33586831!rent: car days: numDays	"Tries to rent the given car for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: car startingOn: Date today forDays: numDays)		ifFalse: [ ^false ].		^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:45' prior: 33587173!rent: car days: numDays	"Tries to rent the given car for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: car startingOn: Date today forDays: numDays)		ifFalse: [ ^false ].		^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:45' prior: 33587485!rent: car days: numDays	"Tries to rent the given car for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: car startingOn: Date today forDays: numDays)		ifFalse: [ ^false ].			^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:47' prior: 33587797!rent: car days: numDays	"Tries to rent the given car for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: car startingOn: Date today forDays: numDays)		ifFalse: [ ^false ].		carRentalDates at: car add: (Date today @ (Date today + numDays - 1)).	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:49'!isAvailable: car startingOn: date days: numDays	"Returns true if the requested car can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalDates |	"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."	rentalDates := (carRentalDates at: car ifAbsent: [^false]).		"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."	rentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] 		ifNone: [:previousRental :nextRental | 			((previousRental notNil) & (previousRental y >= date))				ifTrue: [ ^ false ].			((nextRental notNil) & (nextRental x < (date + numDays)))				ifTrue: [ ^ false ].		].	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:49' prior: 33588111!rent: car days: numDays	"Tries to rent the given car for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: car startingOn: Date today days: numDays)		ifFalse: [ ^false ].		carRentalDates at: car add: (Date today @ (Date today + numDays - 1)).	^true! !CarRental removeSelector: #isAvailable:startingOn:forDays:!!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:50' prior: 33588479!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalDates |	"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."	rentalDates := (carRentalDates at: aCar ifAbsent: [^false]).		"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."	rentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] 		ifNone: [:previousRental :nextRental | 			((previousRental notNil) & (previousRental y >= date))				ifTrue: [ ^ false ].			((nextRental notNil) & (nextRental x < (date + numDays)))				ifTrue: [ ^ false ].		].	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:50' prior: 33589374!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		carRentalDates at: aCar add: (Date today @ (Date today + numDays - 1)).	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:50' prior: 33571329!priceFor: aCar days: numDays	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	price := aCar price * numDays.	(numDays > 3)		ifTrue: [ price := price - (numDays - 3 * aCar price * 0.1) ].	"Alternatively we could write in one line"	"price := (aCar price * numDays) -  ((numDays - 3 max: 0) * aCar price * 0.1)."	^ price! !!CarRental methodsFor: 'accessing' stamp: 'JN 6/22/2019 12:55'!availableCars: date days: numDays	^ cars select: [ :aCar | self isAvailable: aCar startingOn: date days: numDays ]! !!CarRental methodsFor: 'as yet unclassified' stamp: 'JN 6/22/2019 12:56'!availableCars	^ self availableCars: Date today days: 1! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:59'!rentedCars: date days: numDays	"returns the cars that are rented in the requested time period"	^ cars select: [ :aCar | self isAvailable: aCar startingOn: date days: numDays ].! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:00'!rentedCars	"Returns all the cars that are rented today"	^ self rentedCars: Date today days: 1! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:07' prior: 33589816!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalDates |	"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."	rentalDates := (carRentalDates at: aCar ifAbsent: [^false]).		"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."	rentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] 		ifNone: [:previousRental :nextRental | 			previousRental ifNotNil: [ (previousRental y >= date) ifTrue: [^ false]].			nextRental ifNotNil: [ (nextRental x < (date + numDays)) ifTrue: [^ false] ].		].	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:10' prior: 33590714!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		carRentalDates at: aCar add: (Date today @ (Date today + numDays days - 1 day)).	^true! !!CarRentalTest methodsFor: '0 examples' stamp: 'JN 6/22/2019 13:16'!testCustom	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: true.! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 13:25' prior: 33562123!testRenting	"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: (carRental availableCars size) equals: 3.	carRental rent: redPanda days: 5.	self assert: carRental availableCars size equals: 2.	self assert: carRental rentedCars size equals: 1! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 13:25' prior: 33593887!testRenting	"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: (carRental availableCars size) equals: 3.	carRental rent: redPanda days: 5.	self assert: (carRental availableCars size) equals: 2.	self assert: (carRental rentedCars size) equals: 1! !!CarRentalTest methodsFor: '0 examples' stamp: 'JN 6/22/2019 13:26' prior: 33593539!testCustom	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: (carRental availableCars size) equals: 3.	self assert: true.! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 13:26' prior: 33594549!testRenting	"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: (carRental availableCars size) equals: 3.	"carRental rent: redPanda days: 5.	self assert: (carRental availableCars size) equals: 2.	self assert: (carRental rentedCars size) equals: 1"! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 13:26' prior: 33595619!testRenting	"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: (carRental availableCars size) equals: 3.	carRental rent: redPanda days: 5.	"self assert: (carRental availableCars size) equals: 2.	self assert: (carRental rentedCars size) equals: 1"! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 13:27' prior: 33596287!testRenting	"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: (carRental availableCars size) equals: 3.	carRental rent: redPanda days: 5.	self assert: (carRental availableCars size) equals: 2.	self assert: (carRental rentedCars size) equals: 1! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:37' prior: 33593153!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		(carRentalDates at: aCar) add: {Date today . (Date today + numDays days - 1 day)}.	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:38' prior: 33592266!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalDates |	"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."	rentalDates := (carRentalDates at: aCar ifAbsent: [^false]).		"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."	rentalDates findBinary: [ :arg | ((arg first) - date) asDays ] do: [ ^false ] 		ifNone: [:previousRental :nextRental | 			previousRental ifNotNil: [ (previousRental y >= date) ifTrue: [^ false]].			nextRental ifNotNil: [ (nextRental x < (date + numDays)) ifTrue: [^ false] ].		].	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:39' prior: 33598009!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalDates |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalDates := (carRentalDates at: aCar ifAbsent: [^false]).		"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."	rentalDates findBinary: [ :arg | ((arg first) - date) asDays ] do: [ ^false ] 		ifNone: [:previousRental :nextRental | 			previousRental ifNotNil: [ (previousRental last >= date) ifTrue: [^ false]].			nextRental ifNotNil: [ (nextRental first < (date + numDays)) ifTrue: [^ false] ].		].	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:39' prior: 33597613!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		carRentalDates at: aCar add: {Date today . (Date today + numDays days - 1 day)}.	^true! !Object subclass: #CarRental	instanceVariableNames: 'cars numTotalCars carRentalStartingDates carRentalEndingDates'	classVariableNames: ''	package: 'LifewareHR-Core'!!CarRental methodsFor: 'initialization' stamp: 'JN 6/22/2019 13:46' prior: 33582150!initialize	cars := OrderedCollection new.	numTotalCars := 0.	"The dictionary maps a Car to a Sorted collection of Points, each of which contains the starting and ending dates of rental periods as their x and y coordinates, respectively. These rental periods are non-overlapping for each given car."	carRentalStartingDates := Dictionary new! !!CarRental methodsFor: 'initialization' stamp: 'JN 6/22/2019 13:46' prior: 33600380!initialize	cars := OrderedCollection new.	numTotalCars := 0.	"The dictionary maps a Car to a Sorted collection of Points, each of which contains the starting and ending dates of rental periods as their x and y coordinates, respectively. These rental periods are non-overlapping for each given car."	carRentalStartingDates := Dictionary new.	carRentalEndingDates := Dictionary new! !!CarRental methodsFor: 'initialization' stamp: 'JN 6/22/2019 13:47' prior: 33600812!initialize	cars := OrderedCollection new.	numTotalCars := 0.	"The dictionaries maps a Car to a Sorted collection of Dates, which contain the starting dates and ending dates of rentals. The resulting intervals of rentals periods are non-overlapping."	carRentalStartingDates := Dictionary new.	carRentalEndingDates := Dictionary new! !!CarRental methodsFor: 'initialization' stamp: 'JN 6/22/2019 13:48' prior: 33601285!initialize	cars := OrderedCollection new.	numTotalCars := 0.	"The dictionaries maps a Car to a Sorted collection of Dates, which contain the starting dates and ending dates of rentals. For a given car the i'th entry for a given car gives the start and end date of a rental period. The resulting intervals of rentals periods are non-overlapping."	carRentalStartingDates := Dictionary new.	carRentalEndingDates := Dictionary new! !!CarRental methodsFor: 'adding' stamp: 'JN 6/22/2019 13:49' prior: 33584531!addCar: newCar	cars add: newCar.	carRentalStartingDates at: newCar put: SortedCollection new.	! !!CarRental methodsFor: 'adding' stamp: 'JN 6/22/2019 13:49' prior: 33602221!addCar: newCar	cars add: newCar.	carRentalStartingDates at: newCar put: SortedCollection new.	carRentalEndingDates at: newCar put: SortedCollection new.	! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:49' prior: 33599808!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		carRentalStartingDates at: aCar add: {Date today . (Date today + numDays days - 1 day)}.	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:49' prior: 33602635!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		carRentalStartingDates at: aCar add: Date today.	carRentalStartingDates at: aCar add: Date today + numDays days - 1 day.	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:49' prior: 33603037!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		carRentalStartingDates at: aCar add: Date today.	carRentalEndingDates at: aCar add: Date today + numDays days - 1 day.	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:50' prior: 33598900!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalDates |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalDates := (carRentalStartingDates at: aCar ifAbsent: [^false]).		"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."	rentalDates findBinary: [ :arg | ((arg first) - date) asDays ] do: [ ^false ] 		ifNone: [:previousRental :nextRental | 			previousRental ifNotNil: [ (previousRental last >= date) ifTrue: [^ false]].			nextRental ifNotNil: [ (nextRental first < (date + numDays)) ifTrue: [^ false] ].		].	^ true! !Object subclass: #CarRental	instanceVariableNames: 'cars numTotalCars carRentalStartingDates dictRentalEndingDates'	classVariableNames: ''	package: 'LifewareHR-Core'!Object subclass: #CarRental	instanceVariableNames: 'cars numTotalCars dictRentalStartingDates dictRentalEndingDates'	classVariableNames: ''	package: 'LifewareHR-Core'!!CarRental methodsFor: 'adding' stamp: 'JN 6/22/2019 13:57' prior: 33602398!addCar: newCar	cars add: newCar.	dictRentalStartingDates at: newCar put: SortedCollection new.	dictRentalEndingDates at: newCar put: SortedCollection new.	! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:57' prior: 33603472!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		dictRentalStartingDates at: aCar add: Date today.	dictRentalEndingDates at: aCar add: Date today + numDays days - 1 day.	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:12' prior: 33603905!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))	"		idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] 		ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] 		ifNone: [:prev :next | prev].	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:14' prior: 33605838!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))	"		idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] 		ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] 		ifNone: [:prev :next | next].	idxPrevRentalDate ifNil: [ ^true ].	idxNextRentalDate ifNil: [ ^true ].	^ (idxNextRentalDate - idxPrevRentalDate == 1)! !!CarRental methodsFor: 'initialization' stamp: 'JN 6/22/2019 14:15' prior: 33601709!initialize	cars := OrderedCollection new.	numTotalCars := 0.	"The dictionaries maps a Car to a Sorted collection of Dates, which contain the starting dates and ending dates of rentals. For a given car the i'th entry for a given car gives the start and end date of a rental period. The resulting intervals of rentals periods are non-overlapping."	dictRentalStartingDates := Dictionary new.	dictRentalEndingDates := Dictionary new! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:18' prior: 33607406!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] 		ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] 		ifNone: [:prev :next | next].	idxPrevRentalDate ifNil: [ ^true ].	idxNextRentalDate ifNil: [ ^true ].	^ (idxNextRentalDate - idxPrevRentalDate == 1)! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:19' prior: 33605403!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		(dictRentalStartingDates at: aCar) add: Date today.	(dictRentalEndingDates at: aCar) add: Date today + numDays days - 1 day.	^true! !!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JN 6/22/2019 14:22'!ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive	^ #()! !!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JN 6/22/2019 14:22' prior: 33611734!ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #'2019-06-22T14:22:00.415583+02:00') )! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:24' prior: 33609610!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | next].	idxPrevRentalDate ifNil: [ ^true ].	idxNextRentalDate ifNil: [ ^true ].	^ (idxNextRentalDate - idxPrevRentalDate == 1)! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:29' prior: 33612144!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | next].	idxPrevRentalDate == 0 ifTrue: [ ^true ].	idxNextRentalDate == 0 ifTrue: [ ^true ].	^ (idxNextRentalDate - idxPrevRentalDate == 1)! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:29' prior: 33613818!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | next].	idxPrevRentalDate == 0 ifTrue: [ ^true ].	idxNextRentalDate == 0 ifTrue: [ ^true ].	^ (idxNextRentalDate - idxPrevRentalDate == 1)! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:33' prior: 33615504!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [ ^false ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [ ^false ] ifNone: [:prev :next | next].	idxPrevRentalDate == 0 ifTrue: [ ^true ].	idxNextRentalDate == 0 ifTrue: [ ^true ].	^ (idxNextRentalDate - idxPrevRentalDate == 1)! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:37' prior: 33617182!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].	(idxPrevRentalDate == 0 | ((rentalEndingDates at: idxPrevRentalDate ) < date)) ifFalse: [ ^false ].	(idxNextRentalDate == 0 | ((rentalStartingDates at: idxNextRentalDate ) < date)) ifFalse: [ ^false ].	^ (idxNextRentalDate - idxPrevRentalDate == 1)! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:48' prior: 33618860!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that the conditions hold for the interval to be free."	idxPrevRentalDate isZero ifFalse: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].	idxNextRentalDate isZero ifFalse: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].	idxPrevRentalDate isZero ifFalse: [ idxNextRentalDate isZero ifFalse: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. 	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:48' prior: 33620626!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that the conditions hold for the interval to be free."	idxPrevRentalDate isZero ifFalse: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].	idxNextRentalDate isZero ifFalse: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].	idxPrevRentalDate isZero ifFalse: [ idxNextRentalDate isZero ifFalse: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. 	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:01' prior: 33622604!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that the conditions hold for the interval to be free."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | idx > 0 & idx < rentalEndingDates size ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].	(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. 	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:04' prior: 33624586!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that the conditions hold for the interval to be free."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx < rentalEndingDates size) ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].	(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. 	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:09' prior: 33626825!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that the conditions hold for the interval to be free."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx < rentalEndingDates size) ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].	(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. 	^true.! !!CarRentalTest methodsFor: '0 examples' stamp: 'JN 6/22/2019 15:13' prior: 33595215!testCustom	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	carRental availableCars size.	carRental rent: redPanda days: 5.	self assert: (carRental availableCars size) equals: 2.	self assert: (carRental rentedCars size) equals: 1! !!CarRentalTest methodsFor: '0 examples' stamp: 'JN 6/22/2019 15:14' prior: 33631197!testCustom	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	carRental availableCars. 	carRental rent: redPanda days: 5.	carRental availableCars.	self assert: (carRental rentedCars size) equals: 1! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:23' prior: 33629068!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that the conditions hold for the interval to be free."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].	(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. 	^true.! !!CarRentalTest methodsFor: '0 examples' stamp: 'JN 6/22/2019 15:24' prior: 33631700!testCustom	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	carRental availableCars. 	carRental rent: redPanda days: 5.	carRental availableCars.	"self assert: (carRental rentedCars size) equals: 1"! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:25' prior: 33632161!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that the conditions hold for the interval to be free."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].	(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > (date + numDays days - 1 day)) ifFalse: [ ^false ] ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. 	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:27' prior: 33591847!rentedCars: date days: numDays	"returns the cars that are rented at some point in the requested time period"	^ cars select: [ :aCar | (self isAvailable: aCar startingOn: date days: numDays) not ].! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:27' prior: 33636878!rentedCars: date days: numDays	"returns the cars that are rented at some point in the requested time period"	^ cars		reject: [ :aCar | self isAvailable: aCar startingOn: date days: numDays ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:27' prior: 33637157!rentedCars: date days: numDays	"returns the cars that are rented at some point in the requested time period"	^ cars reject: [ :aCar | self isAvailable: aCar startingOn: date days: numDays ]! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 15:44' prior: 33578918!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental |	carRental := CarRental new.	1 to: 3 do: [ carRental addCar: Car panda].	1 to: 2 do: [ carRental addCar: Car tesla].	1 to: 1 do: [ carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.	! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 15:45' prior: 33637713!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	carRental availableCars	self assert: (carRental availableCars size) equals: 6.	! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 15:46' prior: 33638687!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.	! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 15:48' prior: 33639698!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:49'!carIsAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that the conditions hold for the interval to be free."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].	(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > (date + numDays days - 1 day)) ifFalse: [ ^false ] ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. 	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:49' prior: 33591534!availableCars: date days: numDays	^ cars select: [ :aCar | self carIsAvailable: aCar startingOn: date days: numDays ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:49' prior: 33611290!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		(dictRentalStartingDates at: aCar) add: Date today.	(dictRentalEndingDates at: aCar) add: Date today + numDays days - 1 day.	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:49' prior: 33637432!rentedCars: date days: numDays	"returns the cars that are rented at some point in the requested time period"	^ cars reject: [ :aCar | self carIsAvailable: aCar startingOn: date days: numDays ]! !CarRental removeSelector: #isAvailable:startingOn:days:!!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:53'!availableCars: date days: numDays type: aType	^ cars select: [ :aCar | (aCar type == aType) & (self carIsAvailable: aCar startingOn: date days: numDays) ]! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:01' prior: 33640684!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date = Date year: 2019 month: 4 day: 1. 	"self assert (carRental availableCars: date days: 4 type: #golf)."		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:02' prior: 33644978!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	"self assert (carRental availableCars: date days: 4 type: #golf)."		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:02' prior: 33646083!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4 type: #golf) equals: 1.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:03' prior: 33647189!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4 type: #golf size) equals: 1.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:03' prior: 33648304!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.		! !!CarRental methodsFor: 'as yet unclassified' stamp: 'JN 6/22/2019 16:08'!rentType: aType days: numDays	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars :=	(self availableCars: Date today days: numDays type: aType).	(possibleCars size > 0) ifFalse: [ ^false ].		^ self rent: possibleCars first days: numDays.! !!CarRental methodsFor: 'as yet unclassified' stamp: 'JN 6/22/2019 16:09' prior: 33650534!rentType: aType days: numDays	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars :=	(self availableCars: Date today days: numDays type: aType).	(possibleCars isEmpty) ifTrue: [ ^false ].		^ self rent: possibleCars first days: numDays.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:09' prior: 33650984!rentType: aType days: numDays	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars :=	(self availableCars: Date today days: numDays type: aType).	(possibleCars isEmpty) 		ifTrue: [ ^false ]		ifFalse: [ ^ self rent: possibleCars first days: numDays ].		! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:11'!rent: date days: numDays type: aType	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars :=	(self availableCars: Date today days: numDays type: aType).	(possibleCars isEmpty) 		ifTrue: [ ^false ]		ifFalse: [ ^ self rent: possibleCars first days: numDays ].		! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:12'!rent: aCar startingOn: date days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		(dictRentalStartingDates at: aCar) add: Date today.	(dictRentalEndingDates at: aCar) add: Date today + numDays days - 1 day.	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:12' prior: 33652300!rent: aCar startingOn: date days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startingOn: date days: numDays)		ifFalse: [ ^false ].		(dictRentalStartingDates at: aCar) add: Date today.	(dictRentalEndingDates at: aCar) add: Date today + numDays days - 1 day.	^true! !!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JN 6/22/2019 16:13' prior: 33611902!ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #'2019-06-22T14:22:00.415583+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days: #false)) #'2019-06-22T16:13:01.383293+02:00') )! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:13' prior: 33652759!rent: aCar startingOn: date days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startingOn: date days: numDays)		ifFalse: [ ^false ].		(dictRentalStartingDates at: aCar) add: date.	(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:13' prior: 33643974!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	^ self rent: aCar startingOn: Date today days: numDays.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:14'!rent: aCar startingOn: date days: numDays type: aType	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startingOn: date days: numDays)		ifFalse: [ ^false ].		(dictRentalStartingDates at: aCar) add: date.	(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.	^true! !!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JN 6/22/2019 16:14' prior: 33653233!ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #'2019-06-22T14:22:00.415583+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days: #false)) #'2019-06-22T16:13:01.383293+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days:type: #false)) #'2019-06-22T16:14:27.070015+02:00') )! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:14' prior: 33654280!rent: aCar startingOn: date days: numDays type: aType	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars :=	(self availableCars: date days: numDays type: aType).	(possibleCars isEmpty) 		ifTrue: [ ^false ]		ifFalse: [ ^ self rent: possibleCars first days: numDays ].! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:15' prior: 33655213!rent: aCar startingOn: date days: numDays type: aType	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars :=	(self availableCars: date days: numDays type: aType).	(possibleCars isEmpty) 		ifTrue: [ ^false ]		ifFalse: [ ^ self rent: possibleCars first startingOn: date days: numDays ].! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:17'!rentType: aType days: numDays startingOn: date	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars :=	(self availableCars: Date today days: numDays type: aType).	(possibleCars isEmpty) 		ifTrue: [ ^false ]		ifFalse: [ ^ self rent: possibleCars first days: numDays ].		! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:17' prior: 33656148!rentType: aType days: numDays startingOn: date	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars :=	(self availableCars: date days: numDays type: aType).	(possibleCars isEmpty) 		ifTrue: [ ^false ]		ifFalse: [ ^ self rent: possibleCars first days: numDays ].		! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:18' prior: 33656618!rentType: aType days: numDays startingOn: date	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars :=	(self availableCars: date days: numDays type: aType).	(possibleCars isEmpty) 		ifTrue: [ ^false ]		ifFalse: [ ^ self rent: possibleCars first startingOn: date days: numDays ].! !CarRental removeSelector: #rent:days:type:!!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:19' prior: 33651419!rentType: aType days: numDays	^ self rentType: aType days: numDays startingOn: Date today.		! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:19'!rent: aCar days: numDays startingOn: date	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startingOn: date days: numDays)		ifFalse: [ ^false ].		(dictRentalStartingDates at: aCar) add: date.	(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.	^true! !CarRental removeSelector: #rent:days:startingOn:!!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:20'!rent: aCar days: numDays startingOn: date	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startingOn: date days: numDays)		ifFalse: [ ^false ].		(dictRentalStartingDates at: aCar) add: date.	(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:20' prior: 33654022!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	^ self rent: aCar days: numDays startingOn: Date today! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:20' prior: 33655680!rent: aCar startingOn: date days: numDays type: aType	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars := self availableCars: date days: numDays type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ ^ self rent: possibleCars first days: numDays startingOn: date ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:20' prior: 33657082!rentType: aType days: numDays startingOn: date	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars := self availableCars: date days: numDays type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ ^ self rent: possibleCars first days: numDays startingOn: date ]! !CarRental removeSelector: #rent:startingOn:days:!!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JN 6/22/2019 16:20' prior: 33654754!ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #'2019-06-22T14:22:00.415583+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days: #false)) #'2019-06-22T16:13:01.383293+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days:type: #false)) #'2019-06-22T16:14:27.070015+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:days:startingOn: #false)) #'2019-06-22T16:20:23.601853+02:00') )! !CarRental removeSelector: #rent:startingOn:days:type:!!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:22' prior: 33592090!rentedCars	"Returns all the cars that are rented by someone today"	^ self rentedCars: Date today days: 1! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:23' prior: 33649424!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 7 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:23' prior: 33660799!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 7 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 0.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:25' prior: 33662067!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 7 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 0.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:30' prior: 33663335!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 7 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 0.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:31' prior: 33664673!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 8 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 0.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:31' prior: 33666011!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 8 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 0.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:32' prior: 33667349!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 8 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:33'!availableCars: date	^ self availableCars: Date today days: 1! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:33' prior: 33670084!availableCars: date	^ cars select: [ :aCar | self carIsAvailable: aCar startingOn: date days: 1 ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:34' prior: 33670226!availableCars: date	^ self availableCars: date days: 1.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:35' prior: 33644734!availableCars: date days: numDays type: aType	^ (self availableCars: date days: numDays) select: [ :aCar | aCar type == aType  ]! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:39' prior: 33668770!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date golf |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	golf := Car golf.	carRental addCar: golf.	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 8 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:39' prior: 33670760!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date golf |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	golf := Car golf.	carRental addCar: golf.	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 8 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:40' prior: 33672099!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date golf |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	golf := Car golf.	carRental addCar: golf.	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 8 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:42' prior: 33673508!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date golf |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	golf := Car golf.	carRental addCar: golf.	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	self assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.	self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:44' prior: 33674984!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date golf |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	golf := Car golf.	carRental addCar: golf.	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	"self assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true."	self assert: (carRental rent: golf days: 8 startingOn: (date - 5 days)) equals: true.	self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:49'!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that the conditions hold for the interval to be free."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].	(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > (date + numDays days - 1 day)) ifFalse: [ ^false ] ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. 	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:49' prior: 33643775!availableCars: date days: numDays	^ cars		select: [ :aCar | self carIsAvailable: aCar days: numDays startingOn: date ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:49' prior: 33644416!rentedCars: date days: numDays	"returns the cars that are rented at some point in the requested time period"	^ cars		reject: [ :aCar | self carIsAvailable: aCar days: numDays startingOn: date ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:49' prior: 33658240!rent: aCar days: numDays startingOn: date	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar days: numDays startingOn: date)		ifFalse: [ ^ false ].	(dictRentalStartingDates at: aCar) add: date.	(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.	^ true! !CarRental removeSelector: #carIsAvailable:startingOn:days:!!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 16:50'!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			^ true.! !CarRentalTest removeSelector: #testCustom!!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 16:51' prior: 33681159!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.	self assert: (carRental availableCars size) equals: 2.	carRental rent: redPanda days: 5.	^ true.! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 16:54' prior: 33681492!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.	self assert: (carRental availableCars size) equals: 2.	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	self assert: (carRental availableCars size) equals: 1.	self assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.	self assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.	^ true.! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 16:56' prior: 33681869!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	self assert: (carRental availableCars size) equals: 1.	self assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.	self assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.	^ true.! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 16:56' prior: 33682528!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	self assert: (carRental availableCars size) equals: 1.	self assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.	^ true.! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 16:57' prior: 33683350!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	self assert: (carRental availableCars size) equals: 1.	self assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.	self assert: ((carRental availableCars: Date today + 3 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.	^ true.! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 16:57' prior: 33684172!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	self assert: (carRental availableCars size) equals: 1.	self assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.	self assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.	self assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.	^ true.! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 17:00' prior: 33685073!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			"self assert: (carRental availableCars size) equals: 2."	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	"self assert: (carRental availableCars size) equals: 1.	self assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.	self assert: ((carRental availableCars: Date today + 3 days) size) equals: 1."	self assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.	^ true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 17:22' prior: 33678057!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalStartingDate idxNextRentalStartingDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevRentalStartingDate and j := idxNextRentalStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."	idxPrevRentalStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that there are no conflicts."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevRentalStartingDate) ifTrue: [((rentalEndingDates at: idxPrevRentalStartingDate ) >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNextRentalStartingDate ) ifTrue: [((rentalStartingDates at: idxNextRentalStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 17:23' prior: 33686871!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextRentalStartingDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextRentalStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."	idxPrevStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that there are no conflicts."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNextRentalStartingDate ) ifTrue: [((rentalStartingDates at: idxNextRentalStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 17:24' prior: 33688517!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextStartingDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."	idxPrevStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that there are no conflicts."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNextStartingDate ) ifTrue: [((rentalStartingDates at: idxNextStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 17:26' prior: 33690133!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextStartingDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."	idxPrevStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [:found | idxPrevStartingDate := found. idxNextStartingDate = found] ifNone: [:prev :next | idxPrevStartingDate := prev. idxNextStartingDate := next ].		"Check that there are no conflicts."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNextStartingDate ) ifTrue: [((rentalStartingDates at: idxNextStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 17:26' prior: 33691719!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextStartingDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."	rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [:found | idxPrevStartingDate := found. idxNextStartingDate = found] ifNone: [:prev :next | idxPrevStartingDate := prev. idxNextStartingDate := next ].		"Check that there are no conflicts."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNextStartingDate ) ifTrue: [((rentalStartingDates at: idxNextStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 17:27' prior: 33693309!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextStartingDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."	rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [:found | idxPrevStartingDate := found. idxNextStartingDate := found] ifNone: [:prev :next | idxPrevStartingDate := prev. idxNextStartingDate := next ].		"Check that there are no conflicts."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNextStartingDate ) ifTrue: [((rentalStartingDates at: idxNextStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 17:28' prior: 33694876!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrev idxNext boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrev and j := idxNext be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."	rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [:found | idxPrev := found. idxNext := found] ifNone: [:prev :next | idxPrev := prev. idxNext := next ].		"Check that there are no conflicts."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrev) ifTrue: [((rentalEndingDates at: idxPrev ) >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNext ) ifTrue: [((rentalStartingDates at: idxNext ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].	^true.! !----QUIT----2019-06-23T22:53:40.226285+02:00 Pharo.image priorSource: 25166!!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 09:31' prior: 33676488!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date golf |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car tesla].	self assert: (carRental availableCars size) equals: 6.		"Test that the renting and that checking the available cars work."	date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	self assert: (carRental rent: golf days: 8 startingOn: (date - 5 days)) equals: true.	self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		"Test "	self assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.	! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 09:32' prior: 33697954!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date golf |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car tesla].	self assert: (carRental availableCars size) equals: 6.		"Test that the renting and that checking the available cars work."	date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	self assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.	self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		"Test "	self assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.	! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 09:32' prior: 33699618!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car tesla].	self assert: (carRental availableCars size) equals: 6.		"Test that the renting and that checking the available cars work."	date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	self assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.	self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		"Test "	self assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.	! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 09:33' prior: 33701287!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		"Test that the renting and that checking the available cars work."	date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	self assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.	self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		"Test "	self assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.	! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 09:33' prior: 33702951!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		"Test that the renting and that checking the available cars work."	date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	self assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.	self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		"Test the Teslas"	self assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.	! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/24/2019 09:35' prior: 33685974!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	self assert: (carRental availableCars size) equals: 1.	self assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.	self assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.	self assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.	^ true.! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/24/2019 09:35' prior: 33706287!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	self assert: (carRental availableCars size) equals: 2.	self assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.	self assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.	self assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.	^ true.! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/24/2019 09:38' prior: 33707153!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.		"Rent the same car today and 10 days before today, both times for 5 days."	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.		self assert: (carRental availableCars size) equals: 1.	self assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.	self assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.	^ true.! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 09:39' prior: 33708019!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.		"Rent the same car today and 10 days before today, both times for 5 days."	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.		self assert: (carRental availableCars size) equals: 1.	self assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.	self assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.	self assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.	^ true.! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 09:40' prior: 33709000!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.		"Rent the same car on different times, both times for 5 days."	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	carRental rent: redPanda days: 5 startingOn: Date today - 100 days.	carRental rent: redPanda days: 5 startingOn: Date today +100 days.		self assert: (carRental availableCars size) equals: 1.	self assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.	self assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.	self assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.	^ true.! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 09:40' prior: 33709981!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.		"Rent the same car on different times, both times for 5 days."	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	carRental rent: redPanda days: 5 startingOn: Date today - 100 days.	carRental rent: redPanda days: 5 startingOn: Date today + 100 days.		self assert: (carRental availableCars size) equals: 1.	self assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.	self assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.	self assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.	^ true.! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 09:43' prior: 33711087!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.		"Rent the same car on different times, both times for 5 days."	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	carRental rent: redPanda days: 5 startingOn: Date today - 100 days.	carRental rent: redPanda days: 5 startingOn: Date today + 100 days.		self assert: carRental availableCars size equals: 1.	self assert: (carRental availableCars: Date today + 20 days) size equals: 2.	self assert: (carRental availableCars: Date today - 20 days) size equals: 2.	self assert: (carRental availableCars: Date today - 3 days) size equals: 2.	self assert: (carRental availableCars: Date today + 3 days) size equals: 1.	self assert: (carRental availableCars: Date today - 7 days) size equals: 1. 		"Rent also the other car"	carRental rent: yellowPanda days: 5.	self assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.		^ true.! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 09:44' prior: 33712194!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.		"Rent the same car on different times, both times for 5 days."	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	carRental rent: redPanda days: 5 startingOn: Date today - 100 days.	carRental rent: redPanda days: 5 startingOn: Date today + 100 days.		self assert: carRental availableCars size equals: 1.	self assert: (carRental availableCars: Date today + 20 days) size equals: 2.	self assert: (carRental availableCars: Date today - 20 days) size equals: 2.	self assert: (carRental availableCars: Date today - 3 days) size equals: 2.	self assert: (carRental availableCars: Date today + 3 days) size equals: 1.	self assert: (carRental availableCars: Date today - 7 days) size equals: 1. 		"Rent also the other car"	carRental rent: yellowPanda days: 5.	self assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.	self assert: (carRental availableCars: Date today - 20 days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today + 20 days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today - 7 days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today -3 days: 1 type: #panda) size equals: 1.	self assert: (carRental availableCars: Date today - 7 days: 1 type: #panda) size equals: 1.		^ true.! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 09:45' prior: 33713448!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.		"Rent the same car on different times, both times for 5 days."	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	carRental rent: redPanda days: 5 startingOn: Date today - 100 days.	carRental rent: redPanda days: 5 startingOn: Date today + 100 days.		self assert: carRental availableCars size equals: 1.	self assert: (carRental availableCars: Date today + 20 days) size equals: 2.	self assert: (carRental availableCars: Date today - 20 days) size equals: 2.	self assert: (carRental availableCars: Date today - 3 days) size equals: 2.	self assert: (carRental availableCars: Date today + 3 days) size equals: 1.	self assert: (carRental availableCars: Date today - 7 days) size equals: 1. 		"Rent also the other car"	carRental rent: yellowPanda days: 5.	self assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.	self assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today - 3 days days: 1 type: #panda) size equals: 1.	self assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.		^ true.! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 09:45' prior: 33715168!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.		"Rent the same car on different times, both times for 5 days."	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	carRental rent: redPanda days: 5 startingOn: Date today - 100 days.	carRental rent: redPanda days: 5 startingOn: Date today + 100 days.		self assert: carRental availableCars size equals: 1.	self assert: (carRental availableCars: Date today + 20 days) size equals: 2.	self assert: (carRental availableCars: Date today - 20 days) size equals: 2.	self assert: (carRental availableCars: Date today - 3 days) size equals: 2.	self assert: (carRental availableCars: Date today + 3 days) size equals: 1.	self assert: (carRental availableCars: Date today - 7 days) size equals: 1. 		"Rent also the other car"	carRental rent: yellowPanda days: 5.	self assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.	self assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today - 3 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today + 3 days days: 1 type: #panda) size equals: 1.	self assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.		^ true.! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 09:46' prior: 33716914!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.		"Rent the same car on different times, both times for 5 days."	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	carRental rent: redPanda days: 5 startingOn: Date today - 100 days.	carRental rent: redPanda days: 5 startingOn: Date today + 100 days.		self assert: carRental availableCars size equals: 1.	self assert: (carRental availableCars: Date today + 20 days) size equals: 2.	self assert: (carRental availableCars: Date today - 20 days) size equals: 2.	self assert: (carRental availableCars: Date today - 3 days) size equals: 2.	self assert: (carRental availableCars: Date today + 3 days) size equals: 1.	self assert: (carRental availableCars: Date today - 7 days) size equals: 1. 		"Rent also the other car"	carRental rent: yellowPanda days: 2.	self assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.	self assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today - 3 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today + 3 days days: 1 type: #panda) size equals: 1.	self assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.		^ true.! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 09:46' prior: 33718660!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.		"Rent the same car on different times, both times for 5 days."	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	carRental rent: redPanda days: 5 startingOn: Date today - 100 days.	carRental rent: redPanda days: 5 startingOn: Date today + 100 days.		self assert: carRental availableCars size equals: 1.	self assert: (carRental availableCars: Date today + 20 days) size equals: 2.	self assert: (carRental availableCars: Date today - 20 days) size equals: 2.	self assert: (carRental availableCars: Date today - 3 days) size equals: 2.	self assert: (carRental availableCars: Date today + 3 days) size equals: 1.	self assert: (carRental availableCars: Date today - 7 days) size equals: 1. 		"Rent also the other car"	carRental rent: yellowPanda days: 2.	self assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.	self assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today - 3 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today + 2 days days: 1 type: #panda) size equals: 1.	self assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.		^ true.! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 09:47' prior: 33720406!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.		"Rent the same car on different times, both times for 5 days."	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	carRental rent: redPanda days: 5 startingOn: Date today - 100 days.	carRental rent: redPanda days: 5 startingOn: Date today + 100 days.		self assert: carRental availableCars size equals: 1.	self assert: (carRental availableCars: Date today + 20 days) size equals: 2.	self assert: (carRental availableCars: Date today - 20 days) size equals: 2.	self assert: (carRental availableCars: Date today - 1 days) size equals: 2.	self assert: (carRental availableCars: Date today + 3 days) size equals: 1.	self assert: (carRental availableCars: Date today - 7 days) size equals: 1. 		"Rent also the other car"	carRental rent: yellowPanda days: 2.	self assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.	self assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today - 1 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today + 2 days days: 1 type: #panda) size equals: 1.	self assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.		^ true.! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 09:49' prior: 33704614!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		"Test that the renting and that checking the available cars work."	date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.		self assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.		self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		"Test the Teslas"	self assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.	! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 09:55' prior: 33723898!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		"Test that checking the available cars work for the case of golf. See also the test 'testCarIsAvailable'."	date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	self assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.	self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		"Test the Tesla renting with discount"	self assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.	self assert: (carRental rentType: #tesla days: 5 startingOn: date) equals: true.	! !Object subclass: #CarRent	instanceVariableNames: 'startDate endDate discount'	classVariableNames: ''	package: 'LifewareHR-Core'!!CarRent methodsFor: 'accessing' stamp: 'JN 6/24/2019 10:11'!startDate	^ startDate! !!CarRent methodsFor: 'accessing' stamp: 'JN 6/24/2019 10:11'!startDate: anObject	startDate := anObject! !!CarRent methodsFor: 'accessing' stamp: 'JN 6/24/2019 10:11'!endDate	^ endDate! !!CarRent methodsFor: 'accessing' stamp: 'JN 6/24/2019 10:11'!endDate: anObject	endDate := anObject! !!CarRent methodsFor: 'accessing' stamp: 'JN 6/24/2019 10:11'!discount	^ discount! !!CarRent methodsFor: 'accessing' stamp: 'JN 6/24/2019 10:11'!discount: anObject	discount := anObject! !Object subclass: #CarRental	instanceVariableNames: 'cars dictRentalStartingDates dictRentalEndingDates'	classVariableNames: ''	package: 'LifewareHR-Core'!!CarRental methodsFor: 'initialization' stamp: 'JN 6/24/2019 10:12' prior: 33609096!initialize	cars := OrderedCollection new.	"The dictionaries maps a Car to a Sorted collection of Dates, which contain the starting dates and ending dates of rentals. For a given car the i'th entry for a given car gives the start and end date of a rental period. The resulting intervals of rentals periods are non-overlapping."	dictRentalStartingDates := Dictionary new.	dictRentalEndingDates := Dictionary new! !(Smalltalk globals at: #CarRent) rename: #CarSingleRent!(Smalltalk globals at: #CarSingleRent) rename: #CarRent!!CarRent class methodsFor: 'instance creation' stamp: 'JN 6/24/2019 10:19'!startDate: sDate endDate: eDate	^self new.! !!CarRent class methodsFor: 'instance creation' stamp: 'JN 6/24/2019 10:19' prior: 33728868!startDate: sDate endDate: eDate	^self new		startDate: sDate;		endDate: eDate.! !!CarRent class methodsFor: 'as yet unclassified' stamp: 'JN 6/24/2019 10:20'!startDate: sDate endDate: eDate discount: disc	^self new		startDate: sDate;		endDate: eDate;		discount: disc.! !Object subclass: #CarRental	instanceVariableNames: 'cars dictRentals'	classVariableNames: ''	package: 'LifewareHR-Core'!!CarRental methodsFor: 'initialization' stamp: 'JN 6/24/2019 10:22' prior: 33728259!initialize	cars := OrderedCollection new.	"The dictionaries maps a Car to a Sorted collection of Dates, which contain the starting dates and ending dates of rentals. For a given car the i'th entry for a given car gives the start and end date of a rental period. The resulting intervals of rentals periods are non-overlapping."	dictRentals := Dictionary new.! !!CarRental methodsFor: 'initialization' stamp: 'JN 6/24/2019 10:23' prior: 33729496!initialize	cars := OrderedCollection new.	"The dictionary maps a Car to a SortedCollection of CarRent objects which describe the rental periods of that given car. These objects are sorted by their starting dates."	dictRentals := Dictionary new.! !!CarRental methodsFor: 'initialization' stamp: 'JN 6/24/2019 10:23' prior: 33729945!initialize	cars := OrderedCollection new.	"The dictionary maps a Car to a SortedCollection of CarRent objects (sorted by starting dates) which describe the rental periods of that given car."	dictRentals := Dictionary new.! !!CarRental methodsFor: 'adding' stamp: 'JN 6/24/2019 10:24' prior: 33605164!addCar: newCar	cars add: newCar.	dictRentals at: newCar put: SortedCollection new.! !!CarRent methodsFor: 'testing' stamp: 'JN 6/24/2019 10:29'!< aCarRent	^ (startDate < aCarRent startDate) | ( (startDate == aCarRent startDate) & (endDate < aCarRent endDate) )! !!CarRent methodsFor: 'testing' stamp: 'JN 6/24/2019 10:30'!> aCarRent	^ aCarRent < self! !!CarRent methodsFor: 'as yet unclassified' stamp: 'JN 6/24/2019 10:30'!<= aCarRent	^(self > aCarRent) not	! !!CarRent methodsFor: 'comparing' stamp: 'JN 6/24/2019 10:31'!>= aCarRent	^aCarRent <= self! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 10:34' prior: 33680663!rent: aCar days: numDays startingOn: date	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar days: numDays startingOn: date)		ifFalse: [ ^ false ].	(dictRentals at: aCar) add: (CarRent startDate: date endDate: date + (numDays - 1) days).	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 10:38' prior: 33696444!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentals idxPrev idxNext boundsCheck|	rentals := (dictRentals at: aCar ifAbsent: [ ^false ]).	"rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ])."		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrev and j := idxNext be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."	rentals findBinaryIndex: [ :arg | (date - (arg startDate)) asDays ] do: [:found | idxPrev := found. idxNext := found] ifNone: [:prev :next | idxPrev := prev. idxNext := next ].		"Binary search can return indices that are not valid indices of the OrderedCollection rentals ."	boundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].	(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= (date + (numDays - 1) days)) ifTrue: [ ^false ] ].	^true.! !!CarRent commentStamp: 'JN 6/24/2019 10:41' prior: 0!This class represents a single rental of some Car.!!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 10:45' prior: 33731653!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentals idxPrev idxNext boundsCheck|	"The variable rentals is a SortedCollection of CarRent objects."	rentals := (dictRentals at: aCar ifAbsent: [ ^false ]).		"Using binary search, find the indices of the two rentals that have starting dates closest to the given date."	rentals findBinaryIndex: [ :arg | (date - (arg startDate)) asDays ] 		do: [:found | idxPrev := found. idxNext := found] 		ifNone: [:prev :next | idxPrev := prev. idxNext := next ].		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrev and j := idxNext be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."	boundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].	(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= (date + (numDays - 1) days)) ifTrue: [ ^false ] ].	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 10:46' prior: 33733109!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentals idxPrev idxNext boundsCheck|	"The variable rentals is a SortedCollection of CarRent objects."	rentals := (dictRentals at: aCar ifAbsent: [ ^false ]).		"Using binary search, find the indices of the two rentals that have starting dates closest to the given date."	rentals findBinaryIndex: [ :arg | (date - (arg startDate)) asDays ] 		do: [:found | idxPrev := found. idxNext := found] 		ifNone: [:prev :next | idxPrev := prev. idxNext := next ].		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. There is a conflict if and only if the rental starting date at idxPrev >= a OR the rental ending date at idxNext <= b."	boundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].	(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= (date + (numDays - 1) days)) ifTrue: [ ^false ] ].	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 10:46' prior: 33734466!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentals idxPrev idxNext boundsCheck|	"The variable rentals is a SortedCollection of CarRent objects."	rentals := (dictRentals at: aCar ifAbsent: [ ^false ]).		"Using binary search, find the indices of the two rentals that have starting dates closest to the given date."	rentals findBinaryIndex: [ :arg | (date - (arg startDate)) asDays ] 		do: [:found | idxPrev := found. idxNext := found] 		ifNone: [:prev :next | idxPrev := prev. idxNext := next ].		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. There is a conflict if and only if the rental starting date at idxPrev >= a OR the rental ending date at idxNext <= b. The binary search may return invalid indices so we need to check for that as well."	boundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].	(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= (date + (numDays - 1) days)) ifTrue: [ ^false ] ].	^true.! !Object subclass: #CarRent	instanceVariableNames: 'startDate endDate totalPrice'	classVariableNames: ''	package: 'LifewareHR-Core'!CarRent removeSelector: #discount!!CarRent methodsFor: 'accessing' stamp: 'JN 6/24/2019 10:51'!totalPrice: anObject	discount := anObject! !!CarRent class methodsFor: 'instance creation' stamp: 'JN 6/24/2019 10:51' prior: 33729169!startDate: sDate endDate: eDate discount: disc	^self new		startDate: sDate;		endDate: eDate;		totalPrice: disc.! !CarRent removeSelector: #discount:!!CarRent methodsFor: 'accessing' stamp: 'JN 6/24/2019 10:51' prior: 33737249!totalPrice: anObject	totalPrice := anObject! !!CarRent methodsFor: 'accessing' stamp: 'JN 6/24/2019 10:51' prior: 33737621!totalPrice: price	totalPrice := price! !!CarRent methodsFor: 'accessing' stamp: 'JN 6/24/2019 10:52' prior: 33727781!endDate: aDate	endDate := aDate! !!CarRent methodsFor: 'accessing' stamp: 'JN 6/24/2019 10:52' prior: 33727589!startDate: aDate	startDate := aDate! !!CarRent methodsFor: 'as yet unclassified' stamp: 'JN 6/24/2019 10:52'!totalPrice	^ totalPrice! !!CarRent class methodsFor: 'instance creation' stamp: 'JN 6/24/2019 10:54'!startDate: sDate endDate: eDate totalPrice: disc	^self new		startDate: sDate;		endDate: eDate;		totalPrice: disc.! !CarRent class removeSelector: #startDate:endDate:discount:!!CarRent class methodsFor: 'instance creation' stamp: 'JN 6/24/2019 10:54' prior: 33738197!startDate: sDate endDate: eDate totalPrice: price	^self new		startDate: sDate;		endDate: eDate;		totalPrice: price.! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:03'!rent: aCar rentalData: aCarRent	! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:05'!carIsAvailable: aCar startDate: date endDate: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentals idxPrev idxNext boundsCheck|	"The variable rentals is a SortedCollection of CarRent objects."	rentals := (dictRentals at: aCar ifAbsent: [ ^false ]).		"Using binary search, find the indices of the two rentals that have starting dates closest to the given date."	rentals findBinaryIndex: [ :arg | (date - (arg startDate)) asDays ] 		do: [:found | idxPrev := found. idxNext := found] 		ifNone: [:prev :next | idxPrev := prev. idxNext := next ].		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. There is a conflict if and only if the rental starting date at idxPrev >= a OR the rental ending date at idxNext <= b. The binary search may return invalid indices so we need to check for that as well."	boundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].	(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= (date + (numDays - 1) days)) ifTrue: [ ^false ] ].	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:05' prior: 33680184!availableCars: date days: numDays	^ cars		select: [ :aCar | self carIsAvailable: aCar startDate: date endDate: numDays ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:05' prior: 33680385!rentedCars: date days: numDays	"returns the cars that are rented at some point in the requested time period"	^ cars		reject: [ :aCar | self carIsAvailable: aCar startDate: date endDate: numDays ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:05' prior: 33731234!rent: aCar days: numDays startingOn: date	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startDate: date endDate: numDays)		ifFalse: [ ^ false ].	(dictRentals at: aCar)		add: (CarRent startDate: date endDate: date + (numDays - 1) days).	^ true! !CarRental removeSelector: #carIsAvailable:days:startingOn:!!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:06' prior: 33738753!carIsAvailable: aCar startDate: sDate endDate: eDate	"Returns true if the requested aCar can be rented in the interval of dates [ sDate, eDate ] and false otherwise."	| rentals idxPrev idxNext boundsCheck|	"The variable rentals is a SortedCollection of CarRent objects."	rentals := (dictRentals at: aCar ifAbsent: [ ^false ]).		"Using binary search, find the indices of the two rentals that have starting dates closest to the given date."	rentals findBinaryIndex: [ :arg | (sDate - (arg startDate)) asDays ] 		do: [:found | idxPrev := found. idxNext := found] 		ifNone: [:prev :next | idxPrev := prev. idxNext := next ].		"We need to check if the interval of dates [a,b] := [ sDate, eDate ] is free for rental. We can check this as follows. There is a conflict if and only if the rental starting date at idxPrev >= a OR the rental ending date at idxNext <= b. The binary search may return invalid indices so we need to check for that as well."	boundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].	(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= sDate) ifTrue: [ ^false ] ].	(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= eDate) ifTrue: [ ^false ] ].	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:07' prior: 33740110!availableCars: date days: numDays	^ cars		select: [ :aCar | self carIsAvailable: aCar startDate: date endDate: date + (numDays - 1) days ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:08'!rent: aCar startDate: date days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startDate: date endDate: numDays)		ifFalse: [ ^ false ].	(dictRentals at: aCar)		add: (CarRent startDate: date endDate: date + (numDays - 1) days).	^ true! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 11:08' prior: 33722152!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.	self assert: carRental availableCars size equals: 2.	"Rent the same car on different times, both times for 5 days."	carRental rent: redPanda days: 5.	carRental rent: redPanda startDate: Date today - 10 days days: 5.	carRental rent: redPanda startDate: Date today - 100 days days: 5.	carRental rent: redPanda startDate: Date today + 100 days days: 5.	self assert: carRental availableCars size equals: 1.	self		assert: (carRental availableCars: Date today + 20 days) size		equals: 2.	self		assert: (carRental availableCars: Date today - 20 days) size		equals: 2.	self		assert: (carRental availableCars: Date today - 1 days) size		equals: 2.	self		assert: (carRental availableCars: Date today + 3 days) size		equals: 1.	self		assert: (carRental availableCars: Date today - 7 days) size		equals: 1.	"Rent also the other car"	carRental rent: yellowPanda days: 2.	self		assert: (carRental availableCars: Date today days: 1 type: #panda) size		equals: 0.	self		assert:			(carRental availableCars: Date today - 20 days days: 1 type: #panda)				size		equals: 2.	self		assert:			(carRental availableCars: Date today + 20 days days: 1 type: #panda)				size		equals: 2.	self		assert:			(carRental availableCars: Date today - 1 days days: 1 type: #panda)				size		equals: 2.	self		assert:			(carRental availableCars: Date today + 2 days days: 1 type: #panda)				size		equals: 1.	self		assert:			(carRental availableCars: Date today - 7 days days: 1 type: #panda)				size		equals: 1.	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:08' prior: 33658681!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	^ self rent: aCar startDate: Date today days: numDays! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:08' prior: 33659437!rentType: aType days: numDays startingOn: date	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars := self availableCars: date days: numDays type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ ^ self rent: possibleCars first startDate: date days: numDays ]! !CarRental removeSelector: #rent:days:startingOn:!!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:09'!rent: aCar startDate: date endDate: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startDate: date endDate: numDays)		ifFalse: [ ^ false ].	(dictRentals at: aCar)		add: (CarRent startDate: date endDate: date + (numDays - 1) days).	^ true! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 11:09' prior: 33743026!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.	self assert: carRental availableCars size equals: 2.	"Rent the same car on different times, both times for 5 days."	carRental rent: redPanda days: 5.	carRental rent: redPanda startDate: Date today - 10 days endDate: 5.	carRental rent: redPanda startDate: Date today - 100 days endDate: 5.	carRental rent: redPanda startDate: Date today + 100 days endDate: 5.	self assert: carRental availableCars size equals: 1.	self		assert: (carRental availableCars: Date today + 20 days) size		equals: 2.	self		assert: (carRental availableCars: Date today - 20 days) size		equals: 2.	self		assert: (carRental availableCars: Date today - 1 days) size		equals: 2.	self		assert: (carRental availableCars: Date today + 3 days) size		equals: 1.	self		assert: (carRental availableCars: Date today - 7 days) size		equals: 1.	"Rent also the other car"	carRental rent: yellowPanda days: 2.	self		assert: (carRental availableCars: Date today days: 1 type: #panda) size		equals: 0.	self		assert:			(carRental availableCars: Date today - 20 days days: 1 type: #panda)				size		equals: 2.	self		assert:			(carRental availableCars: Date today + 20 days days: 1 type: #panda)				size		equals: 2.	self		assert:			(carRental availableCars: Date today - 1 days days: 1 type: #panda)				size		equals: 2.	self		assert:			(carRental availableCars: Date today + 2 days days: 1 type: #panda)				size		equals: 1.	self		assert:			(carRental availableCars: Date today - 7 days days: 1 type: #panda)				size		equals: 1.	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:09' prior: 33744827!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	^ self rent: aCar startDate: Date today endDate: numDays! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:09' prior: 33745101!rentType: aType days: numDays startingOn: date	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars := self availableCars: date days: numDays type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ ^ self rent: possibleCars first startDate: date endDate: numDays ]! !CarRental removeSelector: #rent:startDate:days:!!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:09' prior: 33745609!rent: aCar startDate: sDate endDate: eDate	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startDate: sDate endDate: eDate)		ifFalse: [ ^ false ].	(dictRentals at: aCar)		add: (CarRent startDate: sDate endDate: eDate).	^ true! !!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JN 6/24/2019 11:10' prior: 33659983!ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #'2019-06-22T14:22:00.415583+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days: #false)) #'2019-06-22T16:13:01.383293+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days:type: #false)) #'2019-06-22T16:14:27.070015+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:days:startingOn: #false)) #'2019-06-22T16:20:23.601853+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:startDate:endDate: #false)) #'2019-06-24T11:10:05.020725+02:00') )! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:11' prior: 33747852!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	^ self rent: aCar startDate: Date today endDate: Date today + (numDays - 1) days! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:12' prior: 33738655!rent: aCar rentalData: aCarRent	"Tries to rent the given aCar with the rental period and price given in aCarRent."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startDate: aCarRent startDate endDate: aCarRent endDate)		ifFalse: [ ^ false ].	(dictRentals at: aCar) add: aCarRent.	^ true! !!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JN 6/24/2019 11:12' prior: 33749080!ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #'2019-06-22T14:22:00.415583+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days: #false)) #'2019-06-22T16:13:01.383293+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days:type: #false)) #'2019-06-22T16:14:27.070015+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:days:startingOn: #false)) #'2019-06-22T16:20:23.601853+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:startDate:endDate: #false)) #'2019-06-24T11:10:05.020725+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:rentalData: #false)) #'2019-06-24T11:12:54.52723+02:00') )! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:14' prior: 33740313!rentedCars: date days: numDays	"returns the cars that are rented at some point in the requested time period"	^ cars		reject: [ :aCar | self carIsAvailable: aCar startDate: date endDate: date + (numDays - 1) days ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:15' prior: 33748129!rentType: aType days: numDays startingOn: date	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars := self availableCars: date days: numDays type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ ^ self rent: possibleCars first startDate: date endDate: date + (numDays - 1) days ]! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 11:18' prior: 33746042!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.	self assert: carRental availableCars size equals: 2.	"Rent the same car on different times, both times for 5 days."	carRental rent: redPanda days: 5.	carRental rent: redPanda startDate: Date today - 10 days endDate: 5.	carRental rent: redPanda startDate: Date today - 100 days endDate: 5.	carRental rent: redPanda startDate: Date today + 100 days endDate: 5.	self assert: carRental availableCars size equals: 1.	self assert: (carRental availableCars: Date today + 20 days) size equals: 2.	self assert: (carRental availableCars: Date today - 20 days) size equals: 2.	self assert: (carRental availableCars: Date today - 1 days) size equals: 2.	self assert: (carRental availableCars: Date today + 3 days) size equals: 1.	self assert: (carRental availableCars: Date today - 7 days) size equals: 1.	"Rent also the other car"	carRental rent: yellowPanda days: 2.	self assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.	self assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today - 1 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today + 2 days days: 1 type: #panda) size equals: 1.	self assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.	^ true! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 11:19' prior: 33752051!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.	self assert: carRental availableCars size equals: 2.	"Rent the same car on different times, both times for 5 days."	carRental rent: redPanda days: 5.	carRental rent: redPanda startDate: Date today - 10 days endDate: Date today - 5 days.	carRental rent: redPanda startDate: Date today - 100 days endDate: Date today - 5 days.	carRental rent: redPanda startDate: Date today + 100 days endDate: Date today - 5 days.	self assert: carRental availableCars size equals: 1.	self assert: (carRental availableCars: Date today + 20 days) size equals: 2.	self assert: (carRental availableCars: Date today - 20 days) size equals: 2.	self assert: (carRental availableCars: Date today - 1 days) size equals: 2.	self assert: (carRental availableCars: Date today + 3 days) size equals: 1.	self assert: (carRental availableCars: Date today - 7 days) size equals: 1.	"Rent also the other car"	carRental rent: yellowPanda days: 2.	self assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.	self assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today - 1 days days: 1 type: #panda) size equals: 2.	self assert: (carRental availableCars: Date today + 2 days days: 1 type: #panda) size equals: 1.	self assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:23'!rentType: aType rentalData: aCarRent	"Tries to rent the given car type with the rental period and price given in aCarRent."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars := self availableCars: aCarRent startDate days: ((aCarRent startDate - aCarRent endDate) asDays) type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ ^ self rent: possibleCars first rentalData: aCarRent ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:24' prior: 33755559!rentType: aType rentalData: aCarRent	"Tries to rent the given car type with the rental period and price given in aCarRent."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars := self availableCars: aCarRent startDate days: ((aCarRent startDate - aCarRent endDate) asDays + 1) type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ ^ self rent: possibleCars first rentalData: aCarRent ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:25'!rentType: aType startDate: date endDate: numDays	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars := self availableCars: date days: numDays type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ ^ self rent: possibleCars first startDate: date endDate: date + (numDays - 1) days ]! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 11:25' prior: 33725575!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"	| carRental date |	carRental := CarRental new.	1 to: 3 do: [ :i | carRental addCar: Car panda ].	1 to: 2 do: [ :i | carRental addCar: Car tesla ].	1 to: 1 do: [ :i | carRental addCar: Car golf ].	self assert: carRental availableCars size equals: 6.	"Test that checking the available cars work for the case of golf. See also the test 'testCarIsAvailable'."	date := Date year: 2019 month: 4 day: 1.	self assert: (carRental availableCars: date days: 4) size equals: 6.	self		assert: (carRental availableCars: date days: 4 type: #golf) size		equals: 1.	self		assert: (carRental rentType: #golf startDate: date - 5 days endDate: 8)		equals: true.	self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self		assert: (carRental availableCars: date days: 1 type: #golf) size		equals: 0.	"Test the Tesla renting with discount"	self		assert: (carRental availableCars: date days: 5 type: #tesla) size		equals: 2.	self		assert: (carRental rentType: #tesla startDate: date endDate: 5)		equals: true! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:25' prior: 33657604!rentType: aType days: numDays	^ self rentType: aType startDate: Date today endDate: numDays! !CarRental removeSelector: #rentType:days:startingOn:!!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:27' prior: 33756565!rentType: aType startDate: sDate endDate: eDate	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	^ self rentType: aType rentalData: (CarRent startDate: sDate endDate:eDate).! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:28' prior: 33758896!rentType: aType days: numDays	^ self rentType: aType startDate: Date today endDate: (Date today + (numDays - 1) days)! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:29' prior: 33756068!rentType: aType rentalData: aCarRent	"Tries to rent the given car type with the rental period and price given in aCarRent."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars := self availableCars: aCarRent startDate days: ((aCarRent startDate - aCarRent endDate) asDays + 1) type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ ^ self rent: possibleCars first rentalData: aCarRent ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:40' prior: 33748655!rent: aCar startDate: sDate endDate: eDate	^ self rent: aCar rentalData: (CarRent startDate: sDate endDate: eDate totalPrice: (self priceFor: aCar days: ((sDate - eDate) asDays + 1 ) ) )! !CarRental removeSelector: #rentType:days:!!CarRental methodsFor: 'action-private' stamp: 'JN 6/24/2019 11:52' prior: 33759666!rentType: aType rentalData: aCarRent	"Tries to rent the given car type with the rental period and price given in aCarRent."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars := self availableCars: aCarRent startDate days: ((aCarRent endDate - aCarRent startDate) asDays + 1) type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ ^ self rent: possibleCars first rentalData: aCarRent ]! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 11:52' prior: 33757069!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"	| carRental date |	carRental := CarRental new.	1 to: 3 do: [ :i | carRental addCar: Car panda ].	1 to: 2 do: [ :i | carRental addCar: Car tesla ].	1 to: 1 do: [ :i | carRental addCar: Car golf ].	self assert: carRental availableCars size equals: 6.	"Test that checking the available cars work for the case of golf. See also the test 'testCarIsAvailable'."	date := Date year: 2019 month: 4 day: 1.	self assert: (carRental availableCars: date days: 4) size equals: 6.	self		assert: (carRental availableCars: date days: 4 type: #golf) size		equals: 1.	self		assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days)		equals: true.	self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self		assert: (carRental availableCars: date days: 1 type: #golf) size		equals: 0.	"Test the Tesla renting with discount"	self		assert: (carRental availableCars: date days: 5 type: #tesla) size		equals: 2.	self		assert: (carRental rentType: #tesla startDate: date endDate: 5)		equals: true! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 11:53' prior: 33761020!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"	| carRental date |	carRental := CarRental new.	1 to: 3 do: [ :i | carRental addCar: Car panda ].	1 to: 2 do: [ :i | carRental addCar: Car tesla ].	1 to: 1 do: [ :i | carRental addCar: Car golf ].	self assert: carRental availableCars size equals: 6.	"Test that checking the available cars work for the case of golf. See also the test 'testCarIsAvailable'."	date := Date year: 2019 month: 4 day: 1.	self assert: (carRental availableCars: date days: 4) size equals: 6.	self		assert: (carRental availableCars: date days: 4 type: #golf) size		equals: 1.	self		assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days)		equals: true.	self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self		assert: (carRental availableCars: date days: 1 type: #golf) size		equals: 0.	"Test the Tesla renting with discount"	self		assert: (carRental availableCars: date days: 5 type: #tesla) size		equals: 2.	self		assert: (carRental rentType: #tesla startDate: date endDate: date + 4 days)		equals: true! !!CarRental methodsFor: 'as yet unclassified' stamp: 'JN 6/24/2019 11:55'!rent: aCar startDate: sDate endDate: eDate discount: disc	^ self rent: aCar rentalData: (CarRent startDate: sDate endDate: eDate totalPrice: (self priceFor: aCar days: ((sDate - eDate) asDays + 1 ) ) )! !!CarRental methodsFor: 'as yet unclassified' stamp: 'JN 6/24/2019 11:56' prior: 33764715!rent: aCar startDate: sDate endDate: eDate discount: disc	^ self rent: aCar rentalData: (CarRent startDate: sDate endDate: eDate totalPrice: (self priceFor: aCar days: ((sDate - eDate) asDays + 1 ) discount: disc ) )! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:56'!priceFor: aCar days: numDays discount: disc	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	price := aCar price * numDays.	(numDays > 3)		ifTrue: [ price := price - (numDays - 3 * aCar price * 0.1) ].	"Alternatively we could write in one line"	"price := (aCar price * numDays) -  ((numDays - 3 max: 0) * aCar price * 0.1)."	^ price! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:57' prior: 33765293!priceFor: aCar days: numDays discount: disc	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	price := aCar price * numDays.	(numDays > 3)		ifTrue: [ price := price - (numDays - 3 * aCar price * 0.1) ].	price := 0 max: price - (disc * numDays).	^ price! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:58' prior: 33591099!priceFor: aCar days: numDays	^ self priceFor: aCar days: numDays discount: 0.! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 11:59' prior: 33760179!rent: aCar startDate: sDate endDate: eDate	^ self rent: aCar startDate: sDate endDate: eDate discount: 0.! !!CarRental methodsFor: 'action-private' stamp: 'JN 6/24/2019 12:02' prior: 33760499!rentType: aType rentalData: aCarRent	"Tries to rent the given car type with the rental period and price given in aCarRent."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars := self availableCars: aCarRent startDate days: ((aCarRent endDate - aCarRent startDate) asDays + 1) type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ 			aCarRent totalprice: 5.			^ self rent: possibleCars first rentalData: aCarRent ]! !!CarRental methodsFor: 'action-private' stamp: 'JN 6/24/2019 12:03' prior: 33766491!rentType: aType rentalData: aCarRent	"Tries to rent the given car type with the rental period and price given in aCarRent."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars := self availableCars: aCarRent startDate days: ((aCarRent endDate - aCarRent startDate) asDays + 1) type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ 			aCarRent totalPrice: (self priceFor: possibleCars first days: (1) ).			^ self rent: possibleCars first rentalData: aCarRent ]! !!CarRental methodsFor: 'action-private' stamp: 'JN 6/24/2019 12:05' prior: 33767043!rentType: aType rentalData: aCarRent	"Tries to rent the given car type with the rental period and price given in aCarRent."	"Returns true upon success and false otherwise."	| possibleCars numDays|	numDays := (aCarRent endDate - aCarRent startDate) asDays + 1.	possibleCars := self availableCars: aCarRent startDate days: numDays type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ 			aCarRent totalPrice: (self priceFor: possibleCars first days: numDays ).			^ self rent: possibleCars first rentalData: aCarRent ]! !!CarRental methodsFor: 'action-private' stamp: 'JN 6/24/2019 12:06' prior: 33767640!rentType: aType rentalData: aCarRent	"Tries to rent the given car type with the rental period and price given in aCarRent."	"Returns true upon success and false otherwise."	| possibleCars numDays|	numDays := (aCarRent endDate - aCarRent startDate) asDays + 1.	possibleCars := self availableCars: aCarRent startDate days: numDays type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ 			aCarRent totalPrice: (self priceFor: possibleCars first days: numDays ).			^ self rent: possibleCars first rentalData: aCarRent ]! !!CarRental methodsFor: 'action-private' stamp: 'JN 6/24/2019 12:06'!rentType: aType rentalDataWithoutPrice: aCarRent	"Tries to rent the given car type with the rental period and price given in aCarRent."	"Returns true upon success and false otherwise."	| possibleCars numDays|	numDays := (aCarRent endDate - aCarRent startDate) asDays + 1.	possibleCars := self availableCars: aCarRent startDate days: numDays type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ 			aCarRent totalPrice: (self priceFor: possibleCars first days: numDays ).			^ self rent: possibleCars first rentalData: aCarRent ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 12:06' prior: 33759124!rentType: aType startDate: sDate endDate: eDate	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	^ self rentType: aType rentalDataWithoutPrice: (CarRent startDate: sDate endDate:eDate).! !CarRental removeSelector: #rentType:rentalData:!!CarRental methodsFor: 'action-private' stamp: 'JN 6/24/2019 12:06' prior: 33768878!rentType: aType rentalDataWithoutPrice: aCarRent	"Tries to rent the given car type with the rental period and price given in aCarRent."	"Returns true upon success and false otherwise."	| possibleCars numDays|	numDays := (aCarRent endDate - aCarRent startDate) asDays + 1.	possibleCars := self availableCars: aCarRent startDate days: numDays type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ 			aCarRent totalPrice: (self priceFor: possibleCars first days: numDays ).			^ self rent: possibleCars first rentalData: aCarRent ]! !!CarRental methodsFor: 'action-private' stamp: 'JN 6/24/2019 12:07'!rentType: aType rentalDataWithoutPrice: aCarRent discount: disc	"Tries to rent the given car type with the rental period and price given in aCarRent."	"Returns true upon success and false otherwise."	| possibleCars numDays|	numDays := (aCarRent endDate - aCarRent startDate) asDays + 1.	possibleCars := self availableCars: aCarRent startDate days: numDays type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ 			aCarRent totalPrice: (self priceFor: possibleCars first days: numDays ).			^ self rent: possibleCars first rentalData: aCarRent ]! !!CarRental methodsFor: 'action-private' stamp: 'JN 6/24/2019 12:07' prior: 33770545!rentType: aType rentalDataWithoutPrice: aCarRent discount: disc	"Tries to rent the given car type with the rental period and price given in aCarRent."	"Returns true upon success and false otherwise."	| possibleCars numDays|	numDays := (aCarRent endDate - aCarRent startDate) asDays + 1.	possibleCars := self availableCars: aCarRent startDate days: numDays type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ 			aCarRent totalPrice: (self priceFor: possibleCars first days: numDays discount: disc).			^ self rent: possibleCars first rentalData: aCarRent ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 12:08' prior: 33769509!rentType: aType startDate: sDate endDate: eDate	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	^ self rentType: aType rentalDataWithoutPrice: (CarRent startDate: sDate endDate:eDate) discount: 0.! !!CarRental methodsFor: 'action' stamp: 'JN 6/24/2019 12:08' prior: 33771859!rentType: aType startDate: sDate endDate: eDate	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	^ self rentType: aType rentalDataWithoutPrice: (CarRent startDate: sDate endDate: eDate) discount: 0.! !!CarRental methodsFor: 'as yet unclassified' stamp: 'JN 6/24/2019 12:08'!rentType: aType startDate: sDate endDate: eDate discount: disc	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	^ self rentType: aType rentalDataWithoutPrice: (CarRent startDate: sDate endDate: eDate) discount: 0.! !!CarRental methodsFor: 'as yet unclassified' stamp: 'JN 6/24/2019 12:08' prior: 33772591!rentType: aType startDate: sDate endDate: eDate discount: disc	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	^ self rentType: aType rentalDataWithoutPrice: (CarRent startDate: sDate endDate: eDate) discount: disc.! !CarRental removeSelector: #rentType:rentalDataWithoutPrice:!!CarRental methodsFor: 'action-private' stamp: 'JN 6/24/2019 12:10' prior: 33771199!rentType: aType rentalDataWithoutPrice: aCarRent discount: disc	"Tries to rent the given car type with the rental period given in aCarRent."	"The price is determined by the car found and the discount"	"Returns true upon success and false otherwise."	| possibleCars numDays|	numDays := (aCarRent endDate - aCarRent startDate) asDays + 1.	possibleCars := self availableCars: aCarRent startDate days: numDays type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ 			aCarRent totalPrice: (self priceFor: possibleCars first days: numDays discount: disc).			^ self rent: possibleCars first rentalData: aCarRent ]! !!CarRental methodsFor: 'action-private' stamp: 'JN 6/24/2019 12:10' prior: 33773443!rentType: aType rentalDataWithoutPrice: aCarRent discount: disc	"Tries to rent the given car type with the rental period given in aCarRent."	"The price is determined by the car found and by the discount."	"Returns true upon success and false otherwise."	| possibleCars numDays|	numDays := (aCarRent endDate - aCarRent startDate) asDays + 1.	possibleCars := self availableCars: aCarRent startDate days: numDays type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ 			aCarRent totalPrice: (self priceFor: possibleCars first days: numDays discount: disc).			^ self rent: possibleCars first rentalData: aCarRent ]! !!CarRental methodsFor: 'action-private' stamp: 'JN 6/24/2019 12:14' prior: 33750054!rent: aCar rentalData: aCarRent	"Tries to rent the given aCar with the rental period and price given in aCarRent."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startDate: aCarRent startDate endDate: aCarRent endDate)		ifFalse: [ ^ false ].	(dictRentals at: aCar) add: aCarRent.	^ true! !!CarRental methodsFor: 'accessing' stamp: 'JN 6/24/2019 12:15'!getRentals: aCar	"Returns all the rentals for a given car"	^ dictRentals at: aCar! !!CarRental methodsFor: 'accessing' stamp: 'JN 6/24/2019 12:16' prior: 33775275!getRentals: aCar	"Returns all the rentals for a given car."	^ dictRentals at: aCar! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 12:17' prior: 33762867!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		"Test that the renting and that checking the available cars work."	date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.		self assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.		self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		"Test that the Teslas are available and rent one with a 10 euro discount per day."	self assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.	self assert: (carRental rentType: #tesla days: 5 startingOn: date) equals: true.			! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 12:19' prior: 33775615!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		"Test that the renting and that checking the available cars work."	date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.		self assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.		self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		"Test that the Teslas are available and rent one with a 10 euro discount per day."	self assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.	self assert: (carRental rentType: #tesla days: 5 startingOn: date) equals: true.			! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 12:19' prior: 33777443!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		"Test that the renting and that checking the available cars work."	date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.		self assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.		self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		"Test that the Teslas are available and rent one with a 10 euro discount per day."	self assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.	self assert: (carRental rentType: #tesla startDate: date endDate: date + 5 days) equals: true.			! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 12:20' prior: 33779283!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		"Test that the renting and that checking the available cars work."	date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.		self assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.		self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		"Test that the Teslas are available and rent one with a 10 euro discount per day."	self assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.	self assert: (carRental rentType: #tesla startDate: date endDate: date + 5 days discount: 10) equals: true.			! !!CarRental methodsFor: 'as yet unclassified' stamp: 'JN 6/24/2019 12:23'!rentedCars: date days: numDays type: aType	"returns the cars that are rented at some point in the requested time period"	^ cars		reject: [ :aCar | (self carIsAvailable: aCar startDate: date endDate: date + (numDays - 1) days) | (aCar type ~= aType) ]! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 12:25' prior: 33781137!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date cars |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		"Test that the renting and that checking the available cars work."	date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.		self assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.		self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		"Test that the Teslas are available and rent one with a 10 euro discount per day."	self assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.	self assert: (carRental rentType: #tesla startDate: date endDate: date + 5 days discount: 10) equals: true.	cars := carRental rentedCars: date days: 1 type: #tesla.	self assert: (cars size) equals: 1.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 12:29' prior: 33783336!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date cars rentals |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		"Test that the renting and that checking the available cars work."	date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.		self assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.		self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		"Test that the Teslas are available and rent one with a 10 euro discount per day."	self assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.	self assert: (carRental rentType: #tesla startDate: date endDate: date + 4 days discount: 10) equals: true.	cars := carRental rentedCars: date days: 1 type: #tesla.	self assert: (cars size) equals: 1.	rentals = carRental getRentals: cars first.	self assert: (rentals size) equals: 1.	self assert: (rentals first) totalPrice equals: (400 - 10) * 5.	! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 12:29' prior: 33785301!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date cars rentals |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		"Test that the renting and that checking the available cars work."	date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.		self assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.		self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		"Test that the Teslas are available and rent one with a 10 euro discount per day."	self assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.	self assert: (carRental rentType: #tesla startDate: date endDate: date + 4 days discount: 10) equals: true.	cars := carRental rentedCars: date days: 1 type: #tesla.	self assert: (cars size) equals: 1.	rentals := carRental getRentals: cars first.	self assert: (rentals size) equals: 1.	self assert: (rentals first) totalPrice equals: (400 - 10) * 5.	! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 12:33' prior: 33787422!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date cars rentals |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		"Test that the renting and that checking the available cars work."	date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.		self assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.		self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		"Test that the Teslas are available and rent one with a 10 euro discount per day."	self assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.	self assert: (carRental rentType: #tesla startDate: date endDate: date + 4 days discount: 10) equals: true.	cars := carRental rentedCars: date days: 1 type: #tesla.	self assert: (cars size) equals: 1.	rentals := carRental getRentals: cars first.	self assert: (rentals size) equals: 1.	self assert: (rentals first) totalPrice equals: 400 - 2 * 40 - 5 * 10. "10 % discount from the last two days and the additional 10 euro discount for each day."	! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 12:33' prior: 33789544!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date cars rentals |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		"Test that the renting and that checking the available cars work."	date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.		self assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.		self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		"Test that the Teslas are available and rent one with a 10 euro discount per day."	self assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.	self assert: (carRental rentType: #tesla startDate: date endDate: date + 4 days discount: 10) equals: true.	cars := carRental rentedCars: date days: 1 type: #tesla.	self assert: (cars size) equals: 1.	rentals := carRental getRentals: cars first.	self assert: (rentals size) equals: 1.	self assert: (rentals first) totalPrice equals: 400 - (2 * 40) - (5 * 10). "10 % discount from the last two days and the additional 10 euro discount for each day."	! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/24/2019 12:34' prior: 33791762!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date cars rentals |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		"Test that the renting and that checking the available cars work."	date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.		self assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.		self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		"Test that the Teslas are available and rent one with a 10 euro discount per day."	self assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.	self assert: (carRental rentType: #tesla startDate: date endDate: date + 4 days discount: 10) equals: true.	cars := carRental rentedCars: date days: 1 type: #tesla.	self assert: (cars size) equals: 1.	rentals := carRental getRentals: cars first.	self assert: (rentals size) equals: 1.	self assert: (rentals first) totalPrice equals: 5 * 400 - (2 * 40) - (5 * 10). "10 % discount from the last two days and the additional 10 euro discount for each day."	! !----QUIT----2019-06-24T12:34:39.708612+02:00 Pharo.image priorSource: 143358!----QUIT----2019-06-24T12:58:39.742712+02:00 Pharo.image priorSource: 241692!