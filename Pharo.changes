----QUIT----2019-03-15T14:54:38.352971+01:00 Pharo7.0-SNAPSHOT-32bit-9f17218.image priorSource: 0!----QUIT----2019-03-15T14:54:52.90449+01:00 Pharo7.0-SNAPSHOT-32bit-9f17218.image priorSource: 0!!CarRentalTest commentStamp: 'LWhr 3/28/2017 16:21' prior: 0!To execute a test, click on the circle next to its name. If it is green, the test passed. In any other case a debug windows will open. Close the debug window,  and the circle will color in yellow or red. A test is yellow when the received value is different from the expected value. A test is red when the code crashes.The tests are organized in "protocols", navigate through them to see all the exercises.!!Car commentStamp: 'LWhr 3/28/2017 14:51' prior: 0!we don't comment, we test!!!!CarRental commentStamp: 'LWhr 3/28/2017 14:51' prior: 0!we don't comment, we test!!!!ManifestLifewareHR commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!CarRentalTest methodsFor: '1.1 examples ' stamp: 'Anonymous 4/4/2017 17:43'!testBooleanCondition	| counter |	counter := OrderedCollection new.	1 > 0		ifTrue: [ counter add: 1 ]		ifFalse: [ counter add: 2 ].	self assert: counter first = 1! !!CarRentalTest methodsFor: '2 exercise' stamp: 'LWhr 3/28/2017 15:19'!testDiscountedPrice	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	"extend the code to make this test green"	| carRental myGolf |	carRental := CarRental new.	myGolf := Car golf.	self assert: (carRental priceFor: myGolf days: 4) = 390! !!CarRentalTest methodsFor: '3 exercise' stamp: 'LWhr 3/28/2017 15:29'!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.	self assert: carRental totalCars size = 3! !!CarRentalTest methodsFor: '0 examples' stamp: 'LWhr 3/28/2017 14:59'!testPandaPrice	| panda |	panda := Car panda.	self assert: panda price = 50! !!CarRentalTest methodsFor: '0 examples' stamp: 'LWhr 3/28/2017 15:16'!testRentPanda	| carRental myPanda |	carRental := CarRental new.	myPanda := Car panda.	self assert: (carRental priceFor: myPanda days: 3) = 150! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'LWhr 3/28/2017 16:01'!testRentTesla	"to be completed"	self assert: false "remove me"! !!CarRentalTest methodsFor: '3 exercise' stamp: 'LWhr 3/28/2017 15:37'!testRenting	"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: carRental availableCars size = 3.	carRental rent: redPanda days: 5.	self assert: carRental availableCars size = 2.	self assert: carRental rentedCars size = 1! !!CarRentalTest methodsFor: '4 exercise' stamp: 'LWhr 3/28/2017 16:01'!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3, 2 tesla and 1 golf. Customer Bob call our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"	self error. "remove this"! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'LWhr 3/28/2017 16:01'!testTeslaPrice	"to be completed"	self assert: false "remove me"! !!Car class methodsFor: 'instance creation' stamp: 'LWhr 3/28/2017 15:17'!golf	^ self price: 100! !!Car class methodsFor: 'instance creation' stamp: 'LWhr 3/28/2017 14:50'!panda	^ self price: 50! !!Car class methodsFor: 'instance creation' stamp: 'LWhr 3/28/2017 14:48'!price: aPrice	^ self new setPrice: aPrice! !!Car class methodsFor: 'instance creation' stamp: 'LWhr 3/28/2017 14:51'!tesla	^ self price: 400! !!Car methodsFor: 'accessor' stamp: 'LWhr 3/28/2017 14:47'!price	^ price! !!Car methodsFor: 'accessor' stamp: 'LWhr 3/28/2017 14:49'!price: aPrice	price := aPrice! !!Car methodsFor: 'initialization' stamp: 'LWhr 3/28/2017 14:48'!setPrice: aPrice	price := aPrice! !!CarRental class methodsFor: 'instance creation' stamp: 'LWhr 3/28/2017 15:25'!new	^ super new initialize! !!CarRental methodsFor: 'initialization' stamp: 'LWhr 3/28/2017 15:26'!initialize	cars := OrderedCollection new! !!CarRental methodsFor: 'action' stamp: 'LWhr 3/28/2017 15:03'!priceFor: aCar days: anInteger	| price |	price := aCar price * anInteger.	^ price! !!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'LWhr 3/28/2017 16:27'!ruleRBVariableReferencedOnceRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#CarRental)) #'2017-03-28T16:27:43.377446+02:00') )! !"LifewareHR"!!CarRentalTest methodsFor: '1.1 examples ' stamp: 'VincentBlondeau 3/22/2019 14:42' prior: 33555547!testBooleanCondition	| counter |	counter := OrderedCollection new.	1 > 0		ifTrue: [ counter add: 1 ]		ifFalse: [ counter add: 2 ].	self assert: counter first equals: 1! !!CarRentalTest methodsFor: '2 exercise' stamp: 'VincentBlondeau 3/22/2019 14:42' prior: 33555789!testDiscountedPrice	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	"extend the code to make this test green"	| carRental myGolf |	carRental := CarRental new.	myGolf := Car golf.	self assert: (carRental priceFor: myGolf days: 4) equals: 390! !!CarRentalTest methodsFor: '3 exercise' stamp: 'VincentBlondeau 3/22/2019 14:42' prior: 33556138!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.	self assert: carRental totalCars size equals: 3! !!CarRentalTest methodsFor: '0 examples' stamp: 'VincentBlondeau 3/22/2019 14:42' prior: 33556543!testPandaPrice	| panda |	panda := Car panda.	self assert: panda price equals: 50! !!CarRentalTest methodsFor: '0 examples' stamp: 'VincentBlondeau 3/22/2019 14:42' prior: 33556695!testRentPanda	| carRental myPanda |	carRental := CarRental new.	myPanda := Car panda.	self assert: (carRental priceFor: myPanda days: 3) equals: 150! !!CarRentalTest methodsFor: '3 exercise' stamp: 'VincentBlondeau 3/22/2019 14:43' prior: 33557067!testRenting	"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: carRental availableCars size equals: 3.	carRental rent: redPanda days: 5.	self assert: carRental availableCars size = 2.	self assert: carRental rentedCars size = 1! !!CarRentalTest methodsFor: '3 exercise' stamp: 'VincentBlondeau 3/22/2019 14:43' prior: 33561462!testRenting	"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: carRental availableCars size equals: 3.	carRental rent: redPanda days: 5.	self assert: carRental availableCars size equals: 2.	self assert: carRental rentedCars size equals: 1! !CarRental class removeSelector: #new!----SNAPSHOT----2019-03-22T14:45:56.066505+01:00 Pharo 7.0 - 64bit Lifeware.image priorSource: 100!TestCase subclass: #CarRentalTest	instanceVariableNames: ''	classVariableNames: ''	package: 'LifewareHR-Tests'!Object subclass: #Car	instanceVariableNames: 'price'	classVariableNames: ''	package: 'LifewareHR-Core'!PackageManifest subclass: #ManifestLifewareHR	instanceVariableNames: ''	classVariableNames: ''	package: 'LifewareHR-Manifest'!----SNAPSHOT----2019-03-22T14:46:59.112505+01:00 Pharo 7.0 - 64bit Lifeware.image priorSource: 8304!----SNAPSHOT----2019-03-22T14:47:54.273505+01:00 Pharo 7.0 - 64bit Lifeware.image priorSource: 8760!Smalltalk globals removeClassNamed: #AnObsoleteManifestLifewareHR!----SNAPSHOT----2019-03-22T15:38:21.787505+01:00 Pharo 7.0 - 64bit Lifeware.image priorSource: 8862!----QUIT----2019-03-22T16:02:15.274505+01:00 Pharo 7.0 - 64bit Lifeware.image priorSource: 9032!----QUIT----2019-03-22T16:02:58.05767+01:00 Pharo 7.0 - 64bit Lifeware.image priorSource: 9134!!ProfStef class methodsFor: 'as yet unclassified' stamp: 'Anonymous 6/19/2019 21:45' prior: 54907577!goToNextLesson  self next! !ProfStef class removeSelector: #goToNextLesson!!PharoSyntaxTutorial methodsFor: 'interactive' stamp: 'Anonymous 6/19/2019 21:54' prior: 54195919!divideTwoByZero		"Oops!! 2/0 raises a ZeroDivide exception. So the debugger opens to let you fix the code.	- Remove the line of code above.	- Right-click and select 'Accept' to compile the new version of the method	- click the button 'Proceed' to continue execution."	ProfStef next. ! !!CarRentalTest methodsFor: '0 examples' stamp: 'Anonymous 6/19/2019 22:01' prior: 33561023!testPandaPrice	| panda |	panda := Car panda.	panda setPrice: 50.	self assert: panda price equals: 50! !!CarRentalTest methodsFor: '0 examples' stamp: 'JerriNummenpalo 6/19/2019 22:02' prior: 33564430!testPandaPrice	| panda |	panda := Car panda.	self assert: panda price equals: 50! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 22:02' prior: 33556927!testRentTesla	"to be completed"! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 22:02' prior: 33564832!testRentTesla	"to be completed"	^ true.! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 22:02' prior: 33564978!testRentTesla	"to be completed"	^ true! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 22:06' prior: 33558450!testTeslaPrice	"to be completed"	self assert: true! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 22:06' prior: 33565132!testRentTesla	"to be completed"	self assert: true! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 22:09' prior: 33565285!testTeslaPrice	"to be completed"	self assert: false! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 22:09' prior: 33565451!testRentTesla	"to be completed"	self assert: false! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 23:03' prior: 33565781!testRentTesla	| tesla |	tesla := Car tesla.	self assert: tesla price equals: 50! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 23:03' prior: 33565615!testTeslaPrice	| tesla |	tesla := Car tesla.	self assert: tesla price equals: 400! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 23:05' prior: 33565946!testRentTesla	| carRental myTesla |	carRental := CarRental new.	myTesla := Car panda.	self assert: (carRental priceFor: myTesla days: 3) equals: 1200! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 23:05' prior: 33566338!testRentTesla	^false! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 23:05' prior: 33566604!testRentTesla	| carRental myTesla |	carRental := CarRental new.	myTesla := Car panda.	self assert: (carRental priceFor: myTesla days: 3) equals: 1200! !!CarRentalTest methodsFor: '1 warming up exercise' stamp: 'JerriNummenpalo 6/19/2019 23:06' prior: 33566738!testRentTesla	| carRental myTesla |	carRental := CarRental new.	myTesla := Car tesla.	self assert: (carRental priceFor: myTesla days: 3) equals: 1200! !!CarRental methodsFor: 'action' stamp: 'JerriNummenpalo 6/19/2019 23:13' prior: 33559506!priceFor: aCar days: anInteger	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	price := (aCar price * anInteger) -  ((anInteger - 3 max: 0) * aCar price * 0.1).	^ price! !!CarRental methodsFor: 'action' stamp: 'JerriNummenpalo 6/19/2019 23:21' prior: 33567251!priceFor: aCar days: anInteger	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	"price := (aCar price * anInteger) -  ((anInteger - 3 max: 0) * aCar price * 0.1)."	"Alternatively we could write"	price := 	(anInteger < 4)		ifTrue: [ aCar price * anInteger ]		ifFalse: [ aCar price * 3 + (anInteger - 3 * aCar price * 0.9) ].	^ price! !!CarRental methodsFor: 'action' stamp: 'JerriNummenpalo 6/19/2019 23:23' prior: 33567560!priceFor: aCar days: anInteger	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	"price := (aCar price * anInteger) -  ((anInteger - 3 max: 0) * aCar price * 0.1)."	"Alternatively we could write"	price := aCar price * anInteger.	(anInteger > 3)		ifTrue: [ price -= anInteger - 3 * aCar price * 0.1 ].	^ price! !!CarRental methodsFor: 'action' stamp: 'JerriNummenpalo 6/19/2019 23:24' prior: 33568036!priceFor: aCar days: anInteger	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	"price := (aCar price * anInteger) -  ((anInteger - 3 max: 0) * aCar price * 0.1)."	"Alternatively we could write"	price := aCar price * anInteger.	(anInteger > 3)		ifTrue: [ price -= (anInteger - 3 * aCar price * 0.1) ].	^ price! !!CarRental methodsFor: 'action' stamp: 'JerriNummenpalo 6/19/2019 23:28' prior: 33568487!priceFor: aCar days: anInteger	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	"price := (aCar price * anInteger) -  ((anInteger - 3 max: 0) * aCar price * 0.1)."	"Alternatively we could write"	price := aCar price * anInteger.	(anInteger > 3)		ifTrue: [ price - (anInteger - 3 * aCar price * 0.1) ].	^ price! !!CarRental methodsFor: 'action' stamp: 'JerriNummenpalo 6/19/2019 23:30' prior: 33568940!priceFor: aCar days: anInteger	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	"price := (aCar price * anInteger) -  ((anInteger - 3 max: 0) * aCar price * 0.1)."	"Alternatively we could write"	price := aCar price * anInteger.	price := price - 	(anInteger > 3)		ifTrue: [ (anInteger - 3 * aCar price * 0.1) ]		ifFalse: [ 0 ].	^ price! !!CarRental methodsFor: 'action' stamp: 'JerriNummenpalo 6/19/2019 23:33' prior: 33569392!priceFor: aCar days: anInteger	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	"price := (aCar price * anInteger) -  ((anInteger - 3 max: 0) * aCar price * 0.1)."	"Alternatively we could write"	price := aCar price * anInteger.	(anInteger > 3)		ifTrue: [ price := price - (anInteger - 3 * aCar price * 0.1) ].	^ price! !!ManifestLifewareHR commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JerriNummenpalo 6/19/2019 23:34'!ruleRBPrecedenceRuleV1FalsePositive	^ #()! !!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JerriNummenpalo 6/19/2019 23:34' prior: 33570534!ruleRBPrecedenceRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#CarRental #priceFor:days: #false)) #'2019-06-19T23:34:19.72379+02:00') )! !!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JerriNummenpalo 6/19/2019 23:34'!ruleRBUtilityMethodsRuleV1FalsePositive	^ #()! !!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JerriNummenpalo 6/19/2019 23:34' prior: 33570930!ruleRBUtilityMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#CarRental #priceFor:days: #false)) #'2019-06-19T23:34:26.64221+02:00') )! !!CarRental methodsFor: 'action' stamp: 'JerriNummenpalo 6/19/2019 23:34' prior: 33569872!priceFor: aCar days: anInteger	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	price := aCar price * anInteger.	(anInteger > 3)		ifTrue: [ price := price - (anInteger - 3 * aCar price * 0.1) ].	"Alternatively we could write in one line"	"price := (aCar price * anInteger) -  ((anInteger - 3 max: 0) * aCar price * 0.1)."	^ price! !!CarRental methodsFor: 'as yet unclassified' stamp: 'JerriNummenpalo 6/19/2019 23:39'!addCar	"comment stating purpose of message"	| temporary variable names |	^true! !!CarRental methodsFor: 'adding' stamp: 'JerriNummenpalo 6/19/2019 23:42'!addCar: newCar	cars add: newCar! !!CarRental methodsFor: 'as yet unclassified' stamp: 'JerriNummenpalo 6/19/2019 23:43'!totalCars	^cars size! !CarRentalTest removeSelector: #testFixedNumberOfCars!!CarRentalTest methodsFor: 'nil' stamp: 'JerriNummenpalo 6/19/2019 23:52'!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.	carRental totalCars.	self assert: carRental totalCars size equals: 3! !!CarRentalTest methodsFor: 'as yet unclassified' stamp: 'JerriNummenpalo 6/19/2019 23:53' prior: 33572237!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.	self assert: carRental totalCars size equals: 3! !!CarRentalTest methodsFor: 'as yet unclassified' stamp: 'JerriNummenpalo 6/19/2019 23:53' prior: 33572706!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.	self assert: carRental totalCars size equals: 3! !!CarRentalTest methodsFor: 'as yet unclassified' stamp: 'JerriNummenpalo 6/19/2019 23:54' prior: 33573153!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.	self assert: carRental totalCars size equals: 3! !CarRental removeSelector: #addCar!!CarRentalTest methodsFor: 'as yet unclassified' stamp: 'JerriNummenpalo 6/19/2019 23:59' prior: 33573600!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.		self assert: carRental totalCars size equals: 3! !!CarRental methodsFor: 'accessing' stamp: 'JerriNummenpalo 6/20/2019 00:00' prior: 33572082!totalCars	^cars! !----QUIT----2019-06-20T00:04:43.795085+02:00 Pharo.image priorSource: 1283!!CarRental methodsFor: 'action' stamp: 'JN 6/20/2019 10:42' prior: 33571329!priceFor: aCar days: anInteger	| price |	price := aCar price * anInteger.	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	(anInteger > 3)		ifTrue: [ price := price - (anInteger - 3 * aCar price * 0.1) ].	^ price! !Object subclass: #Car	instanceVariableNames: 'price type'	classVariableNames: ''	package: 'LifewareHR-Core'!!Car methodsFor: 'as yet unclassified' stamp: 'JN 6/20/2019 11:57'!type: aType	type := aType! !!Car methodsFor: 'as yet unclassified' stamp: 'JN 6/20/2019 11:57'!setType: aType	type := aType! !!Car methodsFor: 'initialization' stamp: 'JN 6/20/2019 11:58'!type	^type! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/20/2019 11:59' prior: 33558594!golf	self type = 'golf'.	^ self price: 100! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/20/2019 12:00' prior: 33575424!golf	self type: 'golf'.	^ self price: 100! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/20/2019 12:00' prior: 33575560!golf	self type: 'golf'.	^ self price: 100! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/20/2019 12:06' prior: 33558916!tesla	"| newCar |	newCar := self new.	newCar price: 400; type: 'tesla'."	^ self price: 400; type: 'tesla'! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/20/2019 12:06' prior: 33575830!tesla	^ self price: 400; type: 'tesla'! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/20/2019 12:06' prior: 33576031!tesla	| newCar |	newCar := self new.	newCar price: 400; type: 'tesla'.	^ newCar	"^ self price: 400; type: 'tesla'"! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/20/2019 12:08' prior: 33575695!golf	| newCar |	newCar := self new.	newCar price: 100; type: 'golf'.	^ newCar	"^ self price: 100"! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/20/2019 12:10' prior: 33558695!panda	| newCar |	newCar := self new.	newCar price: 50; type: 'panda'.	^ newCar	"^ self price: 50"! !!CarRental methodsFor: 'initialization' stamp: 'JN 6/20/2019 12:18' prior: 33559398!initialize	cars := Set new! !Object subclass: #CarRental	instanceVariableNames: 'cars numTotalCars'	classVariableNames: ''	package: 'LifewareHR-Core'!!CarRental methodsFor: 'initialization' stamp: 'JN 6/20/2019 12:20' prior: 33576758!initialize	cars := Set new.	numTotalCars := 0! !!CarRentalTest methodsFor: 'as yet unclassified' stamp: 'JN 6/20/2019 12:21' prior: 33574083!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.		self assert: carRental totalCars equals: 3! !!CarRentalTest methodsFor: 'as yet unclassified' stamp: 'JN 6/20/2019 12:22' prior: 33577145!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.		self assert: carRental totalCars size equals: 3! !!CarRental methodsFor: 'initialization' stamp: 'JN 6/20/2019 12:23' prior: 33577000!initialize	cars := OrderedCollection new.	numTotalCars := 0! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/20/2019 12:26' prior: 33557695!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob call our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"	self error. "remove this"! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/20/2019 12:26' prior: 33578153!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"	self error. "remove this"! !----QUIT----2019-06-21T00:28:58.2952+02:00 Pharo.image priorSource: 20105!!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:43'!price: aPrice type: aType	^ self new 		setPrice: aPrice; 		setType: aType! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:43' prior: 33576567!panda	"| newCar |	newCar := self new.	newCar price: 50; type: 'panda'.	^ newCar"	^ self price: 50 type: 'panda'! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:45' prior: 33576373!golf	^ self price: 100 type: 'golf'! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:45' prior: 33579915!panda	^ self price: 50 type: 'panda'! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:46' prior: 33576162!tesla	^ self price: 400; type: 'tesla'! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:46' prior: 33580380!tesla	^ self price: 400 type: 'tesla'! !!CarRentalTest methodsFor: 'as yet unclassified' stamp: 'JN 6/22/2019 10:46' prior: 33577576!testFixedNumberOfCars	"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental |	carRental := CarRental new.	carRental		addCar: Car panda;		addCar: Car panda;		addCar: Car tesla.		self assert: carRental totalCars size equals: 3! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:48' prior: 33580123!golf	^ self price: 100 type: 'golf'! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:57' prior: 33580511!tesla	^ self price: 400 type: #tesla! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:58' prior: 33580251!panda	^ self price: 50 type: #panda! !!Car class methodsFor: 'instance creation' stamp: 'JN 6/22/2019 10:58' prior: 33581077!golf	^ self price: 100 type: #golf! !Object subclass: #CarRental	instanceVariableNames: 'cars numTotalCars carRentalDates'	classVariableNames: ''	package: 'LifewareHR-Core'!!CarRental methodsFor: 'initialization' stamp: 'JN 6/22/2019 11:48' prior: 33578003!initialize	cars := OrderedCollection new.	numTotalCars := 0.	"The dictionary maps a Car to a Sorted collection of Points, each of which contains the starting and ending dates of rental periods as their x and y coordinates, respectively. These rental periods are non-overlapping for each given car."	carRentalDates = Dictionary new! !!CarRental methodsFor: 'initialization' stamp: 'JN 6/22/2019 11:48' prior: 33581727!initialize	cars := OrderedCollection new.	numTotalCars := 0.	"The dictionary maps a Car to a Sorted collection of Points, each of which contains the starting and ending dates of rental periods as their x and y coordinates, respectively. These rental periods are non-overlapping for each given car."	carRentalDates := Dictionary new! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 11:50'!isAvailable: car startingOn: date ForDays: numDays	! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 11:50' prior: 33582550!isAvailable: car startingOn: date ForDays: numDays		! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 11:54' prior: 33582683!isAvailable: car startingOn: date ForDays: numDays	carRentalDates includesKey: car		ifFalse: [ ^false ].! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 11:55' prior: 33582817!isAvailable: car startingOn: date ForDays: numDays	(carRentalDates includesKey: car)		ifFalse: [ ^false ].! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 11:57' prior: 33583004!isAvailable: car startingOn: date ForDays: numDays	| rentalDates |	rentalDates := (carRentalDates at: car ifAbsent: [^false]).! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 11:57' prior: 33583193!isAvailable: car startingOn: date ForDays: numDays	| rentalDates |.	rentalDates := (carRentalDates at: car ifAbsent: [^false]).! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 11:57' prior: 33583402!isAvailable: car startingOn: date ForDays: numDays	| rentalDates |	rentalDates := (carRentalDates at: car ifAbsent: [^false]).! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 11:58' prior: 33583612!isAvailable: car startingOn: date ForDays: numDays	| rentalDates |	rentalDates := (carRentalDates at: car ifAbsent: [^false]).	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 11:59'!isAvailable: car startingOn: date forDays: numDays	| rentalDates |	rentalDates := (carRentalDates at: car ifAbsent: [^false]).		^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:09' prior: 33584022!isAvailable: car startingOn: date forDays: numDays	| rentalDates |	rentalDates := (carRentalDates at: car ifAbsent: [^false]).	rentalDates findBinary: (date@date) dp: [ ^false ] ifNone: [ ^true ].		^ true! !!CarRental methodsFor: 'adding' stamp: 'JN 6/22/2019 12:11' prior: 33571959!addCar: newCar	cars add: newCar.	carRentalDates at: newCar put: SortedCollection new.	! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:11' prior: 33584241!isAvailable: car startingOn: date forDays: numDays	| rentalDates |	rentalDates := (carRentalDates at: car ifAbsent: [^false]).	rentalDates findBinary: (date@date) do: [ ^false ] ifNone: [ ^true ].		^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:38' prior: 33584700!isAvailable: car startingOn: date forDays: numDays	"Returns true if the requested car can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalDates |	"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."	rentalDates := (carRentalDates at: car ifAbsent: [^false]).		"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."	rentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] 		ifNone: [:previousRental :nextRental | 			((previousRental ~= nil) & (previousRental y >= date))				ifTrue: [ ^ false ].			((nextRental ~= nil) & (nextRental x < (date + numDays)))				ifTrue: [ ^ false ].		].	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:38' prior: 33584990!isAvailable: car startingOn: date forDays: numDays	"Returns true if the requested car can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalDates |	"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."	rentalDates := (carRentalDates at: car ifAbsent: [^false]).		"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."	rentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] 		ifNone: [:previousRental :nextRental | 			((previousRental notNil) & (previousRental y >= date))				ifTrue: [ ^ false ].			((nextRental notNil) & (nextRental x < (date + numDays)))				ifTrue: [ ^ false ].		].	^ true! !CarRental removeSelector: #isAvailable:startingOn:ForDays:!!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:43'!rent: car days: numDays	"Tries to rent the given car for the given number of days."	"Returns true upon success and false otherwise."	| temporary variable names |	(self isAvailable: car startingOn: Date today forDays: numDays)		ifFalse: [ ^false ].		^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:44' prior: 33586831!rent: car days: numDays	"Tries to rent the given car for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: car startingOn: Date today forDays: numDays)		ifFalse: [ ^false ].		^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:45' prior: 33587173!rent: car days: numDays	"Tries to rent the given car for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: car startingOn: Date today forDays: numDays)		ifFalse: [ ^false ].		^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:45' prior: 33587485!rent: car days: numDays	"Tries to rent the given car for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: car startingOn: Date today forDays: numDays)		ifFalse: [ ^false ].			^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:47' prior: 33587797!rent: car days: numDays	"Tries to rent the given car for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: car startingOn: Date today forDays: numDays)		ifFalse: [ ^false ].		carRentalDates at: car add: (Date today @ (Date today + numDays - 1)).	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:49'!isAvailable: car startingOn: date days: numDays	"Returns true if the requested car can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalDates |	"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."	rentalDates := (carRentalDates at: car ifAbsent: [^false]).		"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."	rentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] 		ifNone: [:previousRental :nextRental | 			((previousRental notNil) & (previousRental y >= date))				ifTrue: [ ^ false ].			((nextRental notNil) & (nextRental x < (date + numDays)))				ifTrue: [ ^ false ].		].	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:49' prior: 33588111!rent: car days: numDays	"Tries to rent the given car for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: car startingOn: Date today days: numDays)		ifFalse: [ ^false ].		carRentalDates at: car add: (Date today @ (Date today + numDays - 1)).	^true! !CarRental removeSelector: #isAvailable:startingOn:forDays:!!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:50' prior: 33588479!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalDates |	"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."	rentalDates := (carRentalDates at: aCar ifAbsent: [^false]).		"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."	rentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] 		ifNone: [:previousRental :nextRental | 			((previousRental notNil) & (previousRental y >= date))				ifTrue: [ ^ false ].			((nextRental notNil) & (nextRental x < (date + numDays)))				ifTrue: [ ^ false ].		].	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:50' prior: 33589374!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		carRentalDates at: aCar add: (Date today @ (Date today + numDays - 1)).	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:50' prior: 33571329!priceFor: aCar days: numDays	| price |	"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"	price := aCar price * numDays.	(numDays > 3)		ifTrue: [ price := price - (numDays - 3 * aCar price * 0.1) ].	"Alternatively we could write in one line"	"price := (aCar price * numDays) -  ((numDays - 3 max: 0) * aCar price * 0.1)."	^ price! !!CarRental methodsFor: 'accessing' stamp: 'JN 6/22/2019 12:55'!availableCars: date days: numDays	^ cars select: [ :aCar | self isAvailable: aCar startingOn: date days: numDays ]! !!CarRental methodsFor: 'as yet unclassified' stamp: 'JN 6/22/2019 12:56'!availableCars	^ self availableCars: Date today days: 1! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 12:59'!rentedCars: date days: numDays	"returns the cars that are rented in the requested time period"	^ cars select: [ :aCar | self isAvailable: aCar startingOn: date days: numDays ].! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:00'!rentedCars	"Returns all the cars that are rented today"	^ self rentedCars: Date today days: 1! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:07' prior: 33589816!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalDates |	"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."	rentalDates := (carRentalDates at: aCar ifAbsent: [^false]).		"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."	rentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] 		ifNone: [:previousRental :nextRental | 			previousRental ifNotNil: [ (previousRental y >= date) ifTrue: [^ false]].			nextRental ifNotNil: [ (nextRental x < (date + numDays)) ifTrue: [^ false] ].		].	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:10' prior: 33590714!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		carRentalDates at: aCar add: (Date today @ (Date today + numDays days - 1 day)).	^true! !!CarRentalTest methodsFor: '0 examples' stamp: 'JN 6/22/2019 13:16'!testCustom	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: true.! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 13:25' prior: 33562123!testRenting	"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: (carRental availableCars size) equals: 3.	carRental rent: redPanda days: 5.	self assert: carRental availableCars size equals: 2.	self assert: carRental rentedCars size equals: 1! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 13:25' prior: 33593887!testRenting	"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: (carRental availableCars size) equals: 3.	carRental rent: redPanda days: 5.	self assert: (carRental availableCars size) equals: 2.	self assert: (carRental rentedCars size) equals: 1! !!CarRentalTest methodsFor: '0 examples' stamp: 'JN 6/22/2019 13:26' prior: 33593539!testCustom	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: (carRental availableCars size) equals: 3.	self assert: true.! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 13:26' prior: 33594549!testRenting	"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: (carRental availableCars size) equals: 3.	"carRental rent: redPanda days: 5.	self assert: (carRental availableCars size) equals: 2.	self assert: (carRental rentedCars size) equals: 1"! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 13:26' prior: 33595619!testRenting	"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: (carRental availableCars size) equals: 3.	carRental rent: redPanda days: 5.	"self assert: (carRental availableCars size) equals: 2.	self assert: (carRental rentedCars size) equals: 1"! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 13:27' prior: 33596287!testRenting	"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	self assert: (carRental availableCars size) equals: 3.	carRental rent: redPanda days: 5.	self assert: (carRental availableCars size) equals: 2.	self assert: (carRental rentedCars size) equals: 1! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:37' prior: 33593153!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		(carRentalDates at: aCar) add: {Date today . (Date today + numDays days - 1 day)}.	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:38' prior: 33592266!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalDates |	"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."	rentalDates := (carRentalDates at: aCar ifAbsent: [^false]).		"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."	rentalDates findBinary: [ :arg | ((arg first) - date) asDays ] do: [ ^false ] 		ifNone: [:previousRental :nextRental | 			previousRental ifNotNil: [ (previousRental y >= date) ifTrue: [^ false]].			nextRental ifNotNil: [ (nextRental x < (date + numDays)) ifTrue: [^ false] ].		].	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:39' prior: 33598009!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalDates |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalDates := (carRentalDates at: aCar ifAbsent: [^false]).		"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."	rentalDates findBinary: [ :arg | ((arg first) - date) asDays ] do: [ ^false ] 		ifNone: [:previousRental :nextRental | 			previousRental ifNotNil: [ (previousRental last >= date) ifTrue: [^ false]].			nextRental ifNotNil: [ (nextRental first < (date + numDays)) ifTrue: [^ false] ].		].	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:39' prior: 33597613!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		carRentalDates at: aCar add: {Date today . (Date today + numDays days - 1 day)}.	^true! !Object subclass: #CarRental	instanceVariableNames: 'cars numTotalCars carRentalStartingDates carRentalEndingDates'	classVariableNames: ''	package: 'LifewareHR-Core'!!CarRental methodsFor: 'initialization' stamp: 'JN 6/22/2019 13:46' prior: 33582150!initialize	cars := OrderedCollection new.	numTotalCars := 0.	"The dictionary maps a Car to a Sorted collection of Points, each of which contains the starting and ending dates of rental periods as their x and y coordinates, respectively. These rental periods are non-overlapping for each given car."	carRentalStartingDates := Dictionary new! !!CarRental methodsFor: 'initialization' stamp: 'JN 6/22/2019 13:46' prior: 33600380!initialize	cars := OrderedCollection new.	numTotalCars := 0.	"The dictionary maps a Car to a Sorted collection of Points, each of which contains the starting and ending dates of rental periods as their x and y coordinates, respectively. These rental periods are non-overlapping for each given car."	carRentalStartingDates := Dictionary new.	carRentalEndingDates := Dictionary new! !!CarRental methodsFor: 'initialization' stamp: 'JN 6/22/2019 13:47' prior: 33600812!initialize	cars := OrderedCollection new.	numTotalCars := 0.	"The dictionaries maps a Car to a Sorted collection of Dates, which contain the starting dates and ending dates of rentals. The resulting intervals of rentals periods are non-overlapping."	carRentalStartingDates := Dictionary new.	carRentalEndingDates := Dictionary new! !!CarRental methodsFor: 'initialization' stamp: 'JN 6/22/2019 13:48' prior: 33601285!initialize	cars := OrderedCollection new.	numTotalCars := 0.	"The dictionaries maps a Car to a Sorted collection of Dates, which contain the starting dates and ending dates of rentals. For a given car the i'th entry for a given car gives the start and end date of a rental period. The resulting intervals of rentals periods are non-overlapping."	carRentalStartingDates := Dictionary new.	carRentalEndingDates := Dictionary new! !!CarRental methodsFor: 'adding' stamp: 'JN 6/22/2019 13:49' prior: 33584531!addCar: newCar	cars add: newCar.	carRentalStartingDates at: newCar put: SortedCollection new.	! !!CarRental methodsFor: 'adding' stamp: 'JN 6/22/2019 13:49' prior: 33602221!addCar: newCar	cars add: newCar.	carRentalStartingDates at: newCar put: SortedCollection new.	carRentalEndingDates at: newCar put: SortedCollection new.	! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:49' prior: 33599808!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		carRentalStartingDates at: aCar add: {Date today . (Date today + numDays days - 1 day)}.	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:49' prior: 33602635!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		carRentalStartingDates at: aCar add: Date today.	carRentalStartingDates at: aCar add: Date today + numDays days - 1 day.	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:49' prior: 33603037!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		carRentalStartingDates at: aCar add: Date today.	carRentalEndingDates at: aCar add: Date today + numDays days - 1 day.	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:50' prior: 33598900!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalDates |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalDates := (carRentalStartingDates at: aCar ifAbsent: [^false]).		"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."	rentalDates findBinary: [ :arg | ((arg first) - date) asDays ] do: [ ^false ] 		ifNone: [:previousRental :nextRental | 			previousRental ifNotNil: [ (previousRental last >= date) ifTrue: [^ false]].			nextRental ifNotNil: [ (nextRental first < (date + numDays)) ifTrue: [^ false] ].		].	^ true! !Object subclass: #CarRental	instanceVariableNames: 'cars numTotalCars carRentalStartingDates dictRentalEndingDates'	classVariableNames: ''	package: 'LifewareHR-Core'!Object subclass: #CarRental	instanceVariableNames: 'cars numTotalCars dictRentalStartingDates dictRentalEndingDates'	classVariableNames: ''	package: 'LifewareHR-Core'!!CarRental methodsFor: 'adding' stamp: 'JN 6/22/2019 13:57' prior: 33602398!addCar: newCar	cars add: newCar.	dictRentalStartingDates at: newCar put: SortedCollection new.	dictRentalEndingDates at: newCar put: SortedCollection new.	! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 13:57' prior: 33603472!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		dictRentalStartingDates at: aCar add: Date today.	dictRentalEndingDates at: aCar add: Date today + numDays days - 1 day.	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:12' prior: 33603905!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))	"		idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] 		ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] 		ifNone: [:prev :next | prev].	^ true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:14' prior: 33605838!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))	"		idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] 		ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] 		ifNone: [:prev :next | next].	idxPrevRentalDate ifNil: [ ^true ].	idxNextRentalDate ifNil: [ ^true ].	^ (idxNextRentalDate - idxPrevRentalDate == 1)! !!CarRental methodsFor: 'initialization' stamp: 'JN 6/22/2019 14:15' prior: 33601709!initialize	cars := OrderedCollection new.	numTotalCars := 0.	"The dictionaries maps a Car to a Sorted collection of Dates, which contain the starting dates and ending dates of rentals. For a given car the i'th entry for a given car gives the start and end date of a rental period. The resulting intervals of rentals periods are non-overlapping."	dictRentalStartingDates := Dictionary new.	dictRentalEndingDates := Dictionary new! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:18' prior: 33607406!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] 		ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] 		ifNone: [:prev :next | next].	idxPrevRentalDate ifNil: [ ^true ].	idxNextRentalDate ifNil: [ ^true ].	^ (idxNextRentalDate - idxPrevRentalDate == 1)! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:19' prior: 33605403!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self isAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		(dictRentalStartingDates at: aCar) add: Date today.	(dictRentalEndingDates at: aCar) add: Date today + numDays days - 1 day.	^true! !!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JN 6/22/2019 14:22'!ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive	^ #()! !!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JN 6/22/2019 14:22' prior: 33611734!ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #'2019-06-22T14:22:00.415583+02:00') )! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:24' prior: 33609610!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | next].	idxPrevRentalDate ifNil: [ ^true ].	idxNextRentalDate ifNil: [ ^true ].	^ (idxNextRentalDate - idxPrevRentalDate == 1)! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:29' prior: 33612144!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | next].	idxPrevRentalDate == 0 ifTrue: [ ^true ].	idxNextRentalDate == 0 ifTrue: [ ^true ].	^ (idxNextRentalDate - idxPrevRentalDate == 1)! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:29' prior: 33613818!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | next].	idxPrevRentalDate == 0 ifTrue: [ ^true ].	idxNextRentalDate == 0 ifTrue: [ ^true ].	^ (idxNextRentalDate - idxPrevRentalDate == 1)! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:33' prior: 33615504!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [ ^false ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [ ^false ] ifNone: [:prev :next | next].	idxPrevRentalDate == 0 ifTrue: [ ^true ].	idxNextRentalDate == 0 ifTrue: [ ^true ].	^ (idxNextRentalDate - idxPrevRentalDate == 1)! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:37' prior: 33617182!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].	(idxPrevRentalDate == 0 | ((rentalEndingDates at: idxPrevRentalDate ) < date)) ifFalse: [ ^false ].	(idxNextRentalDate == 0 | ((rentalStartingDates at: idxNextRentalDate ) < date)) ifFalse: [ ^false ].	^ (idxNextRentalDate - idxPrevRentalDate == 1)! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:48' prior: 33618860!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that the conditions hold for the interval to be free."	idxPrevRentalDate isZero ifFalse: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].	idxNextRentalDate isZero ifFalse: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].	idxPrevRentalDate isZero ifFalse: [ idxNextRentalDate isZero ifFalse: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. 	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 14:48' prior: 33620626!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that the conditions hold for the interval to be free."	idxPrevRentalDate isZero ifFalse: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].	idxNextRentalDate isZero ifFalse: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].	idxPrevRentalDate isZero ifFalse: [ idxNextRentalDate isZero ifFalse: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. 	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:01' prior: 33622604!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that the conditions hold for the interval to be free."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | idx > 0 & idx < rentalEndingDates size ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].	(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. 	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:04' prior: 33624586!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|	"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that the conditions hold for the interval to be free."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx < rentalEndingDates size) ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].	(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. 	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:09' prior: 33626825!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that the conditions hold for the interval to be free."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx < rentalEndingDates size) ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].	(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. 	^true.! !!CarRentalTest methodsFor: '0 examples' stamp: 'JN 6/22/2019 15:13' prior: 33595215!testCustom	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	carRental availableCars size.	carRental rent: redPanda days: 5.	self assert: (carRental availableCars size) equals: 2.	self assert: (carRental rentedCars size) equals: 1! !!CarRentalTest methodsFor: '0 examples' stamp: 'JN 6/22/2019 15:14' prior: 33631197!testCustom	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	carRental availableCars. 	carRental rent: redPanda days: 5.	carRental availableCars.	self assert: (carRental rentedCars size) equals: 1! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:23' prior: 33629068!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that the conditions hold for the interval to be free."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].	(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. 	^true.! !!CarRentalTest methodsFor: '0 examples' stamp: 'JN 6/22/2019 15:24' prior: 33631700!testCustom	| carRental redPanda yellowPanda blackTesla |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	blackTesla := Car tesla.	carRental		addCar: redPanda;		addCar: yellowPanda;		addCar: blackTesla.	carRental availableCars. 	carRental rent: redPanda days: 5.	carRental availableCars.	"self assert: (carRental rentedCars size) equals: 1"! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:25' prior: 33632161!isAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that the conditions hold for the interval to be free."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].	(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > (date + numDays days - 1 day)) ifFalse: [ ^false ] ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. 	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:27' prior: 33591847!rentedCars: date days: numDays	"returns the cars that are rented at some point in the requested time period"	^ cars select: [ :aCar | (self isAvailable: aCar startingOn: date days: numDays) not ].! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:27' prior: 33636878!rentedCars: date days: numDays	"returns the cars that are rented at some point in the requested time period"	^ cars		reject: [ :aCar | self isAvailable: aCar startingOn: date days: numDays ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:27' prior: 33637157!rentedCars: date days: numDays	"returns the cars that are rented at some point in the requested time period"	^ cars reject: [ :aCar | self isAvailable: aCar startingOn: date days: numDays ]! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 15:44' prior: 33578918!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental |	carRental := CarRental new.	1 to: 3 do: [ carRental addCar: Car panda].	1 to: 2 do: [ carRental addCar: Car tesla].	1 to: 1 do: [ carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.	! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 15:45' prior: 33637713!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	carRental availableCars	self assert: (carRental availableCars size) equals: 6.	! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 15:46' prior: 33638687!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.	! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 15:48' prior: 33639698!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:49'!carIsAvailable: aCar startingOn: date days: numDays	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that the conditions hold for the interval to be free."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].	(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > (date + numDays days - 1 day)) ifFalse: [ ^false ] ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. 	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:49' prior: 33591534!availableCars: date days: numDays	^ cars select: [ :aCar | self carIsAvailable: aCar startingOn: date days: numDays ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:49' prior: 33611290!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		(dictRentalStartingDates at: aCar) add: Date today.	(dictRentalEndingDates at: aCar) add: Date today + numDays days - 1 day.	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:49' prior: 33637432!rentedCars: date days: numDays	"returns the cars that are rented at some point in the requested time period"	^ cars reject: [ :aCar | self carIsAvailable: aCar startingOn: date days: numDays ]! !CarRental removeSelector: #isAvailable:startingOn:days:!!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 15:53'!availableCars: date days: numDays type: aType	^ cars select: [ :aCar | (aCar type == aType) & (self carIsAvailable: aCar startingOn: date days: numDays) ]! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:01' prior: 33640684!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date = Date year: 2019 month: 4 day: 1. 	"self assert (carRental availableCars: date days: 4 type: #golf)."		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:02' prior: 33644978!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	"self assert (carRental availableCars: date days: 4 type: #golf)."		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:02' prior: 33646083!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4 type: #golf) equals: 1.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:03' prior: 33647189!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4 type: #golf size) equals: 1.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:03' prior: 33648304!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.		! !!CarRental methodsFor: 'as yet unclassified' stamp: 'JN 6/22/2019 16:08'!rentType: aType days: numDays	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars :=	(self availableCars: Date today days: numDays type: aType).	(possibleCars size > 0) ifFalse: [ ^false ].		^ self rent: possibleCars first days: numDays.! !!CarRental methodsFor: 'as yet unclassified' stamp: 'JN 6/22/2019 16:09' prior: 33650534!rentType: aType days: numDays	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars :=	(self availableCars: Date today days: numDays type: aType).	(possibleCars isEmpty) ifTrue: [ ^false ].		^ self rent: possibleCars first days: numDays.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:09' prior: 33650984!rentType: aType days: numDays	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars :=	(self availableCars: Date today days: numDays type: aType).	(possibleCars isEmpty) 		ifTrue: [ ^false ]		ifFalse: [ ^ self rent: possibleCars first days: numDays ].		! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:11'!rent: date days: numDays type: aType	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars :=	(self availableCars: Date today days: numDays type: aType).	(possibleCars isEmpty) 		ifTrue: [ ^false ]		ifFalse: [ ^ self rent: possibleCars first days: numDays ].		! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:12'!rent: aCar startingOn: date days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startingOn: Date today days: numDays)		ifFalse: [ ^false ].		(dictRentalStartingDates at: aCar) add: Date today.	(dictRentalEndingDates at: aCar) add: Date today + numDays days - 1 day.	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:12' prior: 33652300!rent: aCar startingOn: date days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startingOn: date days: numDays)		ifFalse: [ ^false ].		(dictRentalStartingDates at: aCar) add: Date today.	(dictRentalEndingDates at: aCar) add: Date today + numDays days - 1 day.	^true! !!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JN 6/22/2019 16:13' prior: 33611902!ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #'2019-06-22T14:22:00.415583+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days: #false)) #'2019-06-22T16:13:01.383293+02:00') )! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:13' prior: 33652759!rent: aCar startingOn: date days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startingOn: date days: numDays)		ifFalse: [ ^false ].		(dictRentalStartingDates at: aCar) add: date.	(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:13' prior: 33643974!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	^ self rent: aCar startingOn: Date today days: numDays.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:14'!rent: aCar startingOn: date days: numDays type: aType	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startingOn: date days: numDays)		ifFalse: [ ^false ].		(dictRentalStartingDates at: aCar) add: date.	(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.	^true! !!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JN 6/22/2019 16:14' prior: 33653233!ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #'2019-06-22T14:22:00.415583+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days: #false)) #'2019-06-22T16:13:01.383293+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days:type: #false)) #'2019-06-22T16:14:27.070015+02:00') )! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:14' prior: 33654280!rent: aCar startingOn: date days: numDays type: aType	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars :=	(self availableCars: date days: numDays type: aType).	(possibleCars isEmpty) 		ifTrue: [ ^false ]		ifFalse: [ ^ self rent: possibleCars first days: numDays ].! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:15' prior: 33655213!rent: aCar startingOn: date days: numDays type: aType	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars :=	(self availableCars: date days: numDays type: aType).	(possibleCars isEmpty) 		ifTrue: [ ^false ]		ifFalse: [ ^ self rent: possibleCars first startingOn: date days: numDays ].! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:17'!rentType: aType days: numDays startingOn: date	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars :=	(self availableCars: Date today days: numDays type: aType).	(possibleCars isEmpty) 		ifTrue: [ ^false ]		ifFalse: [ ^ self rent: possibleCars first days: numDays ].		! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:17' prior: 33656148!rentType: aType days: numDays startingOn: date	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars :=	(self availableCars: date days: numDays type: aType).	(possibleCars isEmpty) 		ifTrue: [ ^false ]		ifFalse: [ ^ self rent: possibleCars first days: numDays ].		! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:18' prior: 33656618!rentType: aType days: numDays startingOn: date	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars :=	(self availableCars: date days: numDays type: aType).	(possibleCars isEmpty) 		ifTrue: [ ^false ]		ifFalse: [ ^ self rent: possibleCars first startingOn: date days: numDays ].! !CarRental removeSelector: #rent:days:type:!!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:19' prior: 33651419!rentType: aType days: numDays	^ self rentType: aType days: numDays startingOn: Date today.		! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:19'!rent: aCar days: numDays startingOn: date	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startingOn: date days: numDays)		ifFalse: [ ^false ].		(dictRentalStartingDates at: aCar) add: date.	(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.	^true! !CarRental removeSelector: #rent:days:startingOn:!!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:20'!rent: aCar days: numDays startingOn: date	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar startingOn: date days: numDays)		ifFalse: [ ^false ].		(dictRentalStartingDates at: aCar) add: date.	(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.	^true! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:20' prior: 33654022!rent: aCar days: numDays	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	^ self rent: aCar days: numDays startingOn: Date today! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:20' prior: 33655680!rent: aCar startingOn: date days: numDays type: aType	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars := self availableCars: date days: numDays type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ ^ self rent: possibleCars first days: numDays startingOn: date ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:20' prior: 33657082!rentType: aType days: numDays startingOn: date	"Tries to rent a car of the given type for the given number of days starting today."	"Returns true upon success and false otherwise."	| possibleCars |	possibleCars := self availableCars: date days: numDays type: aType.	possibleCars isEmpty		ifTrue: [ ^ false ]		ifFalse: [ ^ self rent: possibleCars first days: numDays startingOn: date ]! !CarRental removeSelector: #rent:startingOn:days:!!ManifestLifewareHR class methodsFor: 'code-critics' stamp: 'JN 6/22/2019 16:20' prior: 33654754!ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #'2019-06-22T14:22:00.415583+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days: #false)) #'2019-06-22T16:13:01.383293+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days:type: #false)) #'2019-06-22T16:14:27.070015+02:00') #(#(#RGMethodDefinition #(#CarRental #rent:days:startingOn: #false)) #'2019-06-22T16:20:23.601853+02:00') )! !CarRental removeSelector: #rent:startingOn:days:type:!!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:22' prior: 33592090!rentedCars	"Returns all the cars that are rented by someone today"	^ self rentedCars: Date today days: 1! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:23' prior: 33649424!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 7 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:23' prior: 33660799!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 7 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 0.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:25' prior: 33662067!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 7 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 0.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:30' prior: 33663335!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 7 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 0.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:31' prior: 33664673!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 8 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 0.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:31' prior: 33666011!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 8 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 0.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:32' prior: 33667349!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	1 to: 1 do: [:i | carRental addCar: Car golf].	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 8 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:33'!availableCars: date	^ self availableCars: Date today days: 1! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:33' prior: 33670084!availableCars: date	^ cars select: [ :aCar | self carIsAvailable: aCar startingOn: date days: 1 ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:34' prior: 33670226!availableCars: date	^ self availableCars: date days: 1.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:35' prior: 33644734!availableCars: date days: numDays type: aType	^ (self availableCars: date days: numDays) select: [ :aCar | aCar type == aType  ]! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:39' prior: 33668770!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date golf |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	golf := Car golf.	carRental addCar: golf.	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 8 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:39' prior: 33670760!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date golf |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	golf := Car golf.	carRental addCar: golf.	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 8 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:40' prior: 33672099!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date golf |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	golf := Car golf.	carRental addCar: golf.	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	carRental rentType: #golf days: 8 startingOn: (date - 5 days).	self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:42' prior: 33673508!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date golf |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	golf := Car golf.	carRental addCar: golf.	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	self assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.	self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		! !!CarRentalTest methodsFor: '4 exercise' stamp: 'JN 6/22/2019 16:44' prior: 33674984!testRentingWithDates	"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. Our informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...write test case(s) and code to simulate this scenario"| carRental date golf |	carRental := CarRental new.	1 to: 3 do: [:i | carRental addCar: Car panda].	1 to: 2 do: [:i | carRental addCar: Car tesla].	golf := Car golf.	carRental addCar: golf.	self assert: (carRental availableCars size) equals: 6.		date := Date year: 2019 month: 4 day: 1. 	self assert: (carRental availableCars: date days: 4) size equals: 6.	self assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.	"self assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true."	self assert: (carRental rent: golf days: 8 startingOn: (date - 5 days)) equals: true.	self assert: (carRental availableCars: date days: 1) size equals: 5.	self assert: (carRental rentedCars: date days: 1) size equals: 1.	self assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.		! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:49'!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if 		(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and		(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and		(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))	"	idxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that the conditions hold for the interval to be free."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].	(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > (date + numDays days - 1 day)) ifFalse: [ ^false ] ].	(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. 	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:49' prior: 33643775!availableCars: date days: numDays	^ cars		select: [ :aCar | self carIsAvailable: aCar days: numDays startingOn: date ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:49' prior: 33644416!rentedCars: date days: numDays	"returns the cars that are rented at some point in the requested time period"	^ cars		reject: [ :aCar | self carIsAvailable: aCar days: numDays startingOn: date ]! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 16:49' prior: 33658240!rent: aCar days: numDays startingOn: date	"Tries to rent the given aCar for the given number of days."	"Returns true upon success and false otherwise."	(self carIsAvailable: aCar days: numDays startingOn: date)		ifFalse: [ ^ false ].	(dictRentalStartingDates at: aCar) add: date.	(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.	^ true! !CarRental removeSelector: #carIsAvailable:startingOn:days:!!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 16:50'!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			^ true.! !CarRentalTest removeSelector: #testCustom!!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 16:51' prior: 33681159!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.	self assert: (carRental availableCars size) equals: 2.	carRental rent: redPanda days: 5.	^ true.! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 16:54' prior: 33681492!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.	self assert: (carRental availableCars size) equals: 2.	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	self assert: (carRental availableCars size) equals: 1.	self assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.	self assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.	^ true.! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 16:56' prior: 33681869!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	self assert: (carRental availableCars size) equals: 1.	self assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.	self assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.	^ true.! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 16:56' prior: 33682528!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	self assert: (carRental availableCars size) equals: 1.	self assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.	^ true.! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 16:57' prior: 33683350!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	self assert: (carRental availableCars size) equals: 1.	self assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.	self assert: ((carRental availableCars: Date today + 3 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.	^ true.! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 16:57' prior: 33684172!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			self assert: (carRental availableCars size) equals: 2.	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	self assert: (carRental availableCars size) equals: 1.	self assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.	self assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.	self assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.	^ true.! !!CarRentalTest methodsFor: '3 exercise' stamp: 'JN 6/22/2019 17:00' prior: 33685073!testCarIsAvailable	| carRental redPanda yellowPanda |	carRental := CarRental new.	redPanda := Car panda.	yellowPanda := Car panda.	carRental		addCar: redPanda;		addCar: yellowPanda.			"self assert: (carRental availableCars size) equals: 2."	carRental rent: redPanda days: 5.	carRental rent: redPanda days: 5 startingOn: Date today - 10 days.	"self assert: (carRental availableCars size) equals: 1.	self assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.	self assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.	self assert: ((carRental availableCars: Date today + 3 days) size) equals: 1."	self assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.	^ true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 17:22' prior: 33678057!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevRentalStartingDate idxNextRentalStartingDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevRentalStartingDate and j := idxNextRentalStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."	idxPrevRentalStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that there are no conflicts."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevRentalStartingDate) ifTrue: [((rentalEndingDates at: idxPrevRentalStartingDate ) >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNextRentalStartingDate ) ifTrue: [((rentalStartingDates at: idxNextRentalStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 17:23' prior: 33686871!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextRentalStartingDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextRentalStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."	idxPrevStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextRentalStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that there are no conflicts."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNextRentalStartingDate ) ifTrue: [((rentalStartingDates at: idxNextRentalStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 17:24' prior: 33688517!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextStartingDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."	idxPrevStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].	idxNextStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].		"Check that there are no conflicts."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNextStartingDate ) ifTrue: [((rentalStartingDates at: idxNextStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 17:26' prior: 33690133!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextStartingDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."	idxPrevStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [:found | idxPrevStartingDate := found. idxNextStartingDate = found] ifNone: [:prev :next | idxPrevStartingDate := prev. idxNextStartingDate := next ].		"Check that there are no conflicts."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNextStartingDate ) ifTrue: [((rentalStartingDates at: idxNextStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 17:26' prior: 33691719!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextStartingDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."	rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [:found | idxPrevStartingDate := found. idxNextStartingDate = found] ifNone: [:prev :next | idxPrevStartingDate := prev. idxNextStartingDate := next ].		"Check that there are no conflicts."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNextStartingDate ) ifTrue: [((rentalStartingDates at: idxNextStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 17:27' prior: 33693309!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextStartingDate boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."	rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [:found | idxPrevStartingDate := found. idxNextStartingDate := found] ifNone: [:prev :next | idxPrevStartingDate := prev. idxNextStartingDate := next ].		"Check that there are no conflicts."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNextStartingDate ) ifTrue: [((rentalStartingDates at: idxNextStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].	^true.! !!CarRental methodsFor: 'action' stamp: 'JN 6/22/2019 17:28' prior: 33694876!carIsAvailable: aCar days: numDays startingOn: date	"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."	| rentalStartingDates rentalEndingDates idxPrev idxNext boundsCheck|	rentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).	rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).		"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrev and j := idxNext be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."	rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [:found | idxPrev := found. idxNext := found] ifNone: [:prev :next | idxPrev := prev. idxNext := next ].		"Check that there are no conflicts."	self assert: rentalStartingDates size == rentalEndingDates size.	boundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].	(boundsCheck value: idxPrev) ifTrue: [((rentalEndingDates at: idxPrev ) >= date) ifTrue: [ ^false ] ].	(boundsCheck value: idxNext ) ifTrue: [((rentalStartingDates at: idxNext ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].	^true.! !----QUIT----2019-06-23T22:53:40.226285+02:00 Pharo.image priorSource: 25166!