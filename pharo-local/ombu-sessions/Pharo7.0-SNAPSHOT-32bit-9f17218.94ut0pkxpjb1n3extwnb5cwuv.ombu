OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:31:51.567626+02:00' ],		#prior : OmReference [ 'Pharo7.0-SNAPSHOT-32bit-9f17218.1m1yfyygdpct70cbhuji1u2qk', '191' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date golf |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\tgolf := Car golf.\r\tcarRental addCar: golf.\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t"self assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true."\r\tself assert: (carRental rent: golf days: 8 startingOn: (date - 5 days)) equals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:44',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date golf |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car tesla].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tself assert: (carRental rent: golf days: 8 startingOn: (date - 5 days)) equals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test "\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\t',			#stamp : 'JN 6/24/2019 09:31',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:32:19.991225+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date golf |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car tesla].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tself assert: (carRental rent: golf days: 8 startingOn: (date - 5 days)) equals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test "\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\t',			#stamp : 'JN 6/24/2019 09:31',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date golf |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car tesla].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tself assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test "\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\t',			#stamp : 'JN 6/24/2019 09:32',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:32:25.88427+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date golf |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car tesla].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tself assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test "\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\t',			#stamp : 'JN 6/24/2019 09:32',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car tesla].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tself assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test "\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\t',			#stamp : 'JN 6/24/2019 09:32',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:33:02.523006+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car tesla].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tself assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test "\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\t',			#stamp : 'JN 6/24/2019 09:32',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tself assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test "\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\t',			#stamp : 'JN 6/24/2019 09:33',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:33:30.772168+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tself assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test "\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\t',			#stamp : 'JN 6/24/2019 09:33',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tself assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test the Teslas"\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\t',			#stamp : 'JN 6/24/2019 09:33',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:35:06.43386+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\t"self assert: (carRental availableCars size) equals: 2."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\t"self assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 1."\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/22/2019 17:00',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/24/2019 09:35',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:35:25.494386+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/24/2019 09:35',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tself assert: (carRental availableCars size) equals: 2.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/24/2019 09:35',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:38:40.973253+02:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tself assert: (carRental availableCars size) equals: 2.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/24/2019 09:35',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car today and 10 days before today, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\t\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/24/2019 09:38',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:39:02.890335+02:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car today and 10 days before today, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\t\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/24/2019 09:38',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car today and 10 days before today, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\t\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/24/2019 09:38',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:39:21.279329+02:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car today and 10 days before today, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\t\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/24/2019 09:38',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car today and 10 days before today, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\t\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/24/2019 09:39',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:40:00.133419+02:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car today and 10 days before today, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\t\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/24/2019 09:39',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 100 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today +100 days.\r\t\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/24/2019 09:40',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:40:02.982089+02:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 100 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today +100 days.\r\t\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/24/2019 09:40',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 100 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today + 100 days.\r\t\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/24/2019 09:40',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:43:19.399315+02:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 100 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today + 100 days.\r\t\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/24/2019 09:40',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 100 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today + 100 days.\r\t\r\tself assert: carRental availableCars size equals: 1.\r\tself assert: (carRental availableCars: Date today + 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days) size equals: 1. \r\t\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 5.\r\tself assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.\r\t\r\t^ true.',			#stamp : 'JN 6/24/2019 09:43',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:44:18.371046+02:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 100 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today + 100 days.\r\t\r\tself assert: carRental availableCars size equals: 1.\r\tself assert: (carRental availableCars: Date today + 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days) size equals: 1. \r\t\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 5.\r\tself assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.\r\t\r\t^ true.',			#stamp : 'JN 6/24/2019 09:43',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 100 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today + 100 days.\r\t\r\tself assert: carRental availableCars size equals: 1.\r\tself assert: (carRental availableCars: Date today + 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days) size equals: 1. \r\t\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 5.\r\tself assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.\r\tself assert: (carRental availableCars: Date today - 20 days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 20 days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 7 days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today -3 days: 1 type: #panda) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days: 1 type: #panda) size equals: 1.\r\t\r\t^ true.',			#stamp : 'JN 6/24/2019 09:44',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:45:07.012924+02:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 100 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today + 100 days.\r\t\r\tself assert: carRental availableCars size equals: 1.\r\tself assert: (carRental availableCars: Date today + 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days) size equals: 1. \r\t\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 5.\r\tself assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.\r\tself assert: (carRental availableCars: Date today - 20 days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 20 days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 7 days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today -3 days: 1 type: #panda) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days: 1 type: #panda) size equals: 1.\r\t\r\t^ true.',			#stamp : 'JN 6/24/2019 09:44',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 100 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today + 100 days.\r\t\r\tself assert: carRental availableCars size equals: 1.\r\tself assert: (carRental availableCars: Date today + 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days) size equals: 1. \r\t\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 5.\r\tself assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.\r\tself assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days days: 1 type: #panda) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.\r\t\r\t^ true.',			#stamp : 'JN 6/24/2019 09:45',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:45:51.228145+02:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 100 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today + 100 days.\r\t\r\tself assert: carRental availableCars size equals: 1.\r\tself assert: (carRental availableCars: Date today + 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days) size equals: 1. \r\t\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 5.\r\tself assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.\r\tself assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days days: 1 type: #panda) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.\r\t\r\t^ true.',			#stamp : 'JN 6/24/2019 09:45',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 100 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today + 100 days.\r\t\r\tself assert: carRental availableCars size equals: 1.\r\tself assert: (carRental availableCars: Date today + 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days) size equals: 1. \r\t\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 5.\r\tself assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.\r\tself assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days days: 1 type: #panda) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.\r\t\r\t^ true.',			#stamp : 'JN 6/24/2019 09:45',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:46:20.58175+02:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 100 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today + 100 days.\r\t\r\tself assert: carRental availableCars size equals: 1.\r\tself assert: (carRental availableCars: Date today + 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days) size equals: 1. \r\t\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 5.\r\tself assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.\r\tself assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days days: 1 type: #panda) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.\r\t\r\t^ true.',			#stamp : 'JN 6/24/2019 09:45',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 100 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today + 100 days.\r\t\r\tself assert: carRental availableCars size equals: 1.\r\tself assert: (carRental availableCars: Date today + 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days) size equals: 1. \r\t\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 2.\r\tself assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.\r\tself assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days days: 1 type: #panda) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.\r\t\r\t^ true.',			#stamp : 'JN 6/24/2019 09:46',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:46:42.590147+02:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 100 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today + 100 days.\r\t\r\tself assert: carRental availableCars size equals: 1.\r\tself assert: (carRental availableCars: Date today + 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days) size equals: 1. \r\t\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 2.\r\tself assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.\r\tself assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days days: 1 type: #panda) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.\r\t\r\t^ true.',			#stamp : 'JN 6/24/2019 09:46',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 100 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today + 100 days.\r\t\r\tself assert: carRental availableCars size equals: 1.\r\tself assert: (carRental availableCars: Date today + 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days) size equals: 1. \r\t\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 2.\r\tself assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.\r\tself assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 2 days days: 1 type: #panda) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.\r\t\r\t^ true.',			#stamp : 'JN 6/24/2019 09:46',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:47:03.326433+02:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 100 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today + 100 days.\r\t\r\tself assert: carRental availableCars size equals: 1.\r\tself assert: (carRental availableCars: Date today + 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days) size equals: 1. \r\t\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 2.\r\tself assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.\r\tself assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 3 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 2 days days: 1 type: #panda) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.\r\t\r\t^ true.',			#stamp : 'JN 6/24/2019 09:46',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 100 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today + 100 days.\r\t\r\tself assert: carRental availableCars size equals: 1.\r\tself assert: (carRental availableCars: Date today + 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 1 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days) size equals: 1. \r\t\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 2.\r\tself assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.\r\tself assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 1 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 2 days days: 1 type: #panda) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.\r\t\r\t^ true.',			#stamp : 'JN 6/24/2019 09:47',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:49:18.329057+02:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tself assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test the Teslas"\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\t',			#stamp : 'JN 6/24/2019 09:33',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test the Teslas"\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\t',			#stamp : 'JN 6/24/2019 09:49',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T09:55:23.103224+02:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test the Teslas"\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\t',			#stamp : 'JN 6/24/2019 09:49',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that checking the available cars work for the case of golf. See also the test \'testCarIsAvailable\'."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tself assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test the Tesla renting with discount"\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla days: 5 startingOn: date) equals: true.\r\t',			#stamp : 'JN 6/24/2019 09:55',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:10:04.557575+02:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRent\r\tinstanceVariableNames: \'startDate endDate discount\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRent,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #startDate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #endDate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #discount,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRent class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRent class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRent				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:10:23.115402+02:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRent\r\tinstanceVariableNames: \'startDate endDate discount\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRent,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #startDate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #endDate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #discount,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRent class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRent class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRent				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		},		#protocol : #initialization	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:11:02.009405+02:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [			EpGenericRefactoring {				#storeString : '(RBCreateAccessorsForVariableRefactoring variable: #startDate class: CarRent classVariable: false)'			},			EpGenericRefactoring {				#storeString : '(RBCreateAccessorsForVariableRefactoring variable: #endDate class: CarRent classVariable: false)'			},			EpGenericRefactoring {				#storeString : '(RBCreateAccessorsForVariableRefactoring variable: #discount class: CarRent classVariable: false)'			}		]	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ],		#time : DateAndTime [ '2019-06-24T10:11:02.024552+02:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #startDate,			#protocol : #accessing,			#sourceCode : 'startDate\r\t^ startDate',			#stamp : 'JN 6/24/2019 10:11',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ],		#time : DateAndTime [ '2019-06-24T10:11:02.030789+02:00' ],		#trigger : OmReference [ '24' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'startDate:',			#protocol : #accessing,			#sourceCode : 'startDate: anObject\r\tstartDate := anObject',			#stamp : 'JN 6/24/2019 10:11',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ],		#time : DateAndTime [ '2019-06-24T10:11:02.03348+02:00' ],		#trigger : OmReference [ '24' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #endDate,			#protocol : #accessing,			#sourceCode : 'endDate\r\t^ endDate',			#stamp : 'JN 6/24/2019 10:11',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ],		#time : DateAndTime [ '2019-06-24T10:11:02.038011+02:00' ],		#trigger : OmReference [ '24' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'endDate:',			#protocol : #accessing,			#sourceCode : 'endDate: anObject\r\tendDate := anObject',			#stamp : 'JN 6/24/2019 10:11',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ],		#time : DateAndTime [ '2019-06-24T10:11:02.040609+02:00' ],		#trigger : OmReference [ '24' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #discount,			#protocol : #accessing,			#sourceCode : 'discount\r\t^ discount',			#stamp : 'JN 6/24/2019 10:11',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ],		#time : DateAndTime [ '2019-06-24T10:11:02.043138+02:00' ],		#trigger : OmReference [ '24' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'discount:',			#protocol : #accessing,			#sourceCode : 'discount: anObject\r\tdiscount := anObject',			#stamp : 'JN 6/24/2019 10:11',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:12:21.83697+02:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRental\r\tinstanceVariableNames: \'cars numTotalCars dictRentalStartingDates dictRentalEndingDates\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRental,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #cars,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #numTotalCars,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #dictRentalStartingDates,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #dictRentalEndingDates,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRental class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRental class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRental				},				#parent : @7,				#content : 'commentStamp: \'LWhr 3/28/2017 14:51\' prior: 0',				#stamp : 'VincentBlondeau 3/25/2019 10:12'			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRental\r\tinstanceVariableNames: \'cars dictRentalStartingDates dictRentalEndingDates\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRental,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #cars,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #dictRentalStartingDates,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #dictRentalEndingDates,					#parent : @29				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRental class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRental class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @29			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRental				},				#parent : @29,				#content : 'commentStamp: \'LWhr 3/28/2017 14:51\' prior: 0',				#stamp : 'VincentBlondeau 3/25/2019 10:12'			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:12:27.500516+02:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\tnumTotalCars := 0.\r\t"The dictionaries maps a Car to a Sorted collection of Dates, which contain the starting dates and ending dates of rentals. For a given car the i\'th entry for a given car gives the start and end date of a rental period. The resulting intervals of rentals periods are non-overlapping."\r\tdictRentalStartingDates := Dictionary new.\r\tdictRentalEndingDates := Dictionary new',			#stamp : 'JN 6/22/2019 14:15',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\t"The dictionaries maps a Car to a Sorted collection of Dates, which contain the starting dates and ending dates of rentals. For a given car the i\'th entry for a given car gives the start and end date of a rental period. The resulting intervals of rentals periods are non-overlapping."\r\tdictRentalStartingDates := Dictionary new.\r\tdictRentalEndingDates := Dictionary new',			#stamp : 'JN 6/24/2019 10:12',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:13:58.056223+02:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpBehaviorNameChange {		#oldName : #CarRent,		#newName : #CarSingleRent,		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarSingleRent\r\tinstanceVariableNames: \'startDate endDate discount\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarSingleRent,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarSingleRent					},					#name : #startDate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarSingleRent					},					#name : #endDate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarSingleRent					},					#name : #discount,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarSingleRent class\r\tinstanceVariableNames: \'\''				},				#name : #'CarSingleRent class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarSingleRent				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:14:34.984383+02:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpBehaviorNameChange {		#oldName : #CarSingleRent,		#newName : #CarRent,		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRent\r\tinstanceVariableNames: \'startDate endDate discount\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRent,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #startDate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #endDate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #discount,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRent class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRent class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRent				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:14:55.194451+02:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRent\r\tinstanceVariableNames: \'startDate endDate discount\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRent,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #startDate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #endDate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #discount,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRent class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRent class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRent				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		},		#protocol : #initialization	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:16:39.383098+02:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpProtocolAddition {		#behavior : RGMetaclassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'CarRent class\r\tinstanceVariableNames: \'\''			},			#name : #'CarRent class',			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#baseClass : RGClassDefinition {				#annotations : IdentityDictionary {					#superclassName : 'Object',					#traitCompositionSource : '{}',					#definitionSource : 'Object subclass: #CarRent\r\tinstanceVariableNames: \'startDate endDate discount\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''				},				#name : #CarRent,				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGInstanceVariableDefinition {						#annotations : IdentityDictionary {							#isMetaSide : false,							#className : #CarRent						},						#name : #startDate,						#parent : @12					},					RGInstanceVariableDefinition {						#annotations : IdentityDictionary {							#isMetaSide : false,							#className : #CarRent						},						#name : #endDate,						#parent : @12					},					RGInstanceVariableDefinition {						#annotations : IdentityDictionary {							#isMetaSide : false,							#className : #CarRent						},						#name : #discount,						#parent : @12					}				],				#metaClass : @7,				#comment : RGCommentDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#parent : @12,					#content : ''				},				#classVariables : OrderedCollection [ ],				#category : #LifewareHR-Core,				#package : #LifewareHR,				#sharedPools : OrderedCollection [ ]			}		},		#protocol : #'instance creation'	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:19:15.28288+02:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'CarRent class'			},			#name : #'startDate:endDate:',			#protocol : #'instance creation',			#sourceCode : 'startDate: sDate endDate: eDate\r\t^self new.',			#stamp : 'JN 6/24/2019 10:19',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:19:48.740314+02:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'CarRent class'			},			#name : #'startDate:endDate:',			#protocol : #'instance creation',			#sourceCode : 'startDate: sDate endDate: eDate\r\t^self new.',			#stamp : 'JN 6/24/2019 10:19',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'CarRent class'			},			#name : #'startDate:endDate:',			#protocol : #'instance creation',			#sourceCode : 'startDate: sDate endDate: eDate\r\t^self new\r\t\tstartDate: sDate;\r\t\tendDate: eDate.',			#stamp : 'JN 6/24/2019 10:19',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:20:12.334134+02:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'CarRent class'			},			#name : #'startDate:endDate:discount:',			#protocol : #'as yet unclassified',			#sourceCode : 'startDate: sDate endDate: eDate discount: disc\r\t^self new\r\t\tstartDate: sDate;\r\t\tendDate: eDate;\r\t\tdiscount: disc.',			#stamp : 'JN 6/24/2019 10:20',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:20:19.853415+02:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'CarRent class'			},			#name : #'startDate:endDate:discount:',			#protocol : #'as yet unclassified',			#sourceCode : 'startDate: sDate endDate: eDate discount: disc\r\t^self new\r\t\tstartDate: sDate;\r\t\tendDate: eDate;\r\t\tdiscount: disc.',			#stamp : 'JN 6/24/2019 10:20',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'CarRent class'			},			#name : #'startDate:endDate:discount:',			#protocol : #'instance creation',			#sourceCode : 'startDate: sDate endDate: eDate discount: disc\r\t^self new\r\t\tstartDate: sDate;\r\t\tendDate: eDate;\r\t\tdiscount: disc.',			#stamp : 'JN 6/24/2019 10:20',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:21:57.207078+02:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRental\r\tinstanceVariableNames: \'cars dictRentalStartingDates dictRentalEndingDates\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRental,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #cars,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #dictRentalStartingDates,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #dictRentalEndingDates,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRental class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRental class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRental				},				#parent : @7,				#content : 'commentStamp: \'LWhr 3/28/2017 14:51\' prior: 0',				#stamp : 'VincentBlondeau 3/25/2019 10:12'			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRental\r\tinstanceVariableNames: \'cars dictRentals\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRental,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #cars,					#parent : @27				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #dictRentals,					#parent : @27				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRental class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRental class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @27			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRental				},				#parent : @27,				#content : 'commentStamp: \'LWhr 3/28/2017 14:51\' prior: 0',				#stamp : 'VincentBlondeau 3/25/2019 10:12'			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:22:41.522139+02:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\t"The dictionaries maps a Car to a Sorted collection of Dates, which contain the starting dates and ending dates of rentals. For a given car the i\'th entry for a given car gives the start and end date of a rental period. The resulting intervals of rentals periods are non-overlapping."\r\tdictRentalStartingDates := Dictionary new.\r\tdictRentalEndingDates := Dictionary new',			#stamp : 'JN 6/24/2019 10:12',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\t"The dictionaries maps a Car to a Sorted collection of Dates, which contain the starting dates and ending dates of rentals. For a given car the i\'th entry for a given car gives the start and end date of a rental period. The resulting intervals of rentals periods are non-overlapping."\r\tdictRentals := Dictionary new.',			#stamp : 'JN 6/24/2019 10:22',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:23:32.955371+02:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\t"The dictionaries maps a Car to a Sorted collection of Dates, which contain the starting dates and ending dates of rentals. For a given car the i\'th entry for a given car gives the start and end date of a rental period. The resulting intervals of rentals periods are non-overlapping."\r\tdictRentals := Dictionary new.',			#stamp : 'JN 6/24/2019 10:22',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\t"The dictionary maps a Car to a SortedCollection of CarRent objects which describe the rental periods of that given car. These objects are sorted by their starting dates."\r\tdictRentals := Dictionary new.',			#stamp : 'JN 6/24/2019 10:23',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:23:52.038105+02:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\t"The dictionary maps a Car to a SortedCollection of CarRent objects which describe the rental periods of that given car. These objects are sorted by their starting dates."\r\tdictRentals := Dictionary new.',			#stamp : 'JN 6/24/2019 10:23',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\t"The dictionary maps a Car to a SortedCollection of CarRent objects (sorted by starting dates) which describe the rental periods of that given car."\r\tdictRentals := Dictionary new.',			#stamp : 'JN 6/24/2019 10:23',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:24:08.0646+02:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'addCar:',			#protocol : #adding,			#sourceCode : 'addCar: newCar\r\tcars add: newCar.\r\tdictRentalStartingDates at: newCar put: SortedCollection new.\r\tdictRentalEndingDates at: newCar put: SortedCollection new.\t',			#stamp : 'JN 6/22/2019 13:57',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'addCar:',			#protocol : #adding,			#sourceCode : 'addCar: newCar\r\tcars add: newCar.\r\tdictRentals at: newCar put: SortedCollection new.',			#stamp : 'JN 6/24/2019 10:24',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:27:21.776519+02:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRent\r\tinstanceVariableNames: \'startDate endDate discount\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRent,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #startDate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #endDate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #discount,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRent class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRent class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRent				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		},		#protocol : #testing	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:29:26.979252+02:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'<',			#protocol : #testing,			#sourceCode : '< aCarRent\r\t^ (startDate < aCarRent startDate) | ( (startDate == aCarRent startDate) & (endDate < aCarRent endDate) )',			#stamp : 'JN 6/24/2019 10:29',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:30:01.444038+02:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'>',			#protocol : #testing,			#sourceCode : '> aCarRent\r\t^ aCarRent < self',			#stamp : 'JN 6/24/2019 10:30',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:30:43.308489+02:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'<=',			#protocol : #'as yet unclassified',			#sourceCode : '<= aCarRent\r\t^(self > aCarRent) not\r\t',			#stamp : 'JN 6/24/2019 10:30',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:30:43.333048+02:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'<=',			#protocol : #'as yet unclassified',			#sourceCode : '<= aCarRent\r\t^(self > aCarRent) not\r\t',			#stamp : 'JN 6/24/2019 10:30',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'<=',			#protocol : #comparing,			#sourceCode : '<= aCarRent\r\t^(self > aCarRent) not\r\t',			#stamp : 'JN 6/24/2019 10:30',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:31:11.767141+02:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'>=',			#protocol : #comparing,			#sourceCode : '>= aCarRent\r\t^aCarRent <= self',			#stamp : 'JN 6/24/2019 10:31',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:31:19.894725+02:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'<',			#protocol : #testing,			#sourceCode : '< aCarRent\r\t^ (startDate < aCarRent startDate) | ( (startDate == aCarRent startDate) & (endDate < aCarRent endDate) )',			#stamp : 'JN 6/24/2019 10:29',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'<',			#protocol : #comparing,			#sourceCode : '< aCarRent\r\t^ (startDate < aCarRent startDate) | ( (startDate == aCarRent startDate) & (endDate < aCarRent endDate) )',			#stamp : 'JN 6/24/2019 10:29',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:31:19.896577+02:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRent\r\tinstanceVariableNames: \'startDate endDate discount\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRent,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #startDate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #endDate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #discount,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRent class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRent class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRent				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		},		#protocol : #testing	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:31:19.923774+02:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'>',			#protocol : #testing,			#sourceCode : '> aCarRent\r\t^ aCarRent < self',			#stamp : 'JN 6/24/2019 10:30',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'>',			#protocol : #comparing,			#sourceCode : '> aCarRent\r\t^ aCarRent < self',			#stamp : 'JN 6/24/2019 10:30',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:34:07.564903+02:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:startingOn:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays startingOn: date\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar days: numDays startingOn: date)\r\t\tifFalse: [ ^ false ].\r\t(dictRentalStartingDates at: aCar) add: date.\r\t(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.\r\t^ true',			#stamp : 'JN 6/22/2019 16:49',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:startingOn:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays startingOn: date\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar days: numDays startingOn: date)\r\t\tifFalse: [ ^ false ].\r\t(dictRentals at: aCar) add: (CarRent startDate: date endDate: date + (numDays - 1) days).\r\t^ true',			#stamp : 'JN 6/24/2019 10:34',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:38:43.92535+02:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrev idxNext boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrev and j := idxNext be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."\r\trentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [:found | idxPrev := found. idxNext := found] ifNone: [:prev :next | idxPrev := prev. idxNext := next ].\r\t\r\t"Check that there are no conflicts."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrev) ifTrue: [((rentalEndingDates at: idxPrev ) >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNext ) ifTrue: [((rentalStartingDates at: idxNext ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/22/2019 17:28',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentals idxPrev idxNext boundsCheck|\r\trentals := (dictRentals at: aCar ifAbsent: [ ^false ]).\r\t"rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ])."\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrev and j := idxNext be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."\r\trentals findBinaryIndex: [ :arg | (date - (arg startDate)) asDays ] do: [:found | idxPrev := found. idxNext := found] ifNone: [:prev :next | idxPrev := prev. idxNext := next ].\r\t\r\t"Binary search can return indices that are not valid indices of the OrderedCollection rentals ."\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].\r\t(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= (date + (numDays - 1) days)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/24/2019 10:38',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:41:36.657636+02:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRent\r\tinstanceVariableNames: \'startDate endDate discount\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRent,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #startDate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #endDate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #discount,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRent class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRent class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRent				},				#parent : @7,				#content : 'This class represents a single rental of some Car.',				#stamp : 'JN 6/24/2019 10:41'			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'This class represents a single rental of some Car.',		#newStamp : 'JN 6/24/2019 10:41'	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:45:00.903875+02:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentals idxPrev idxNext boundsCheck|\r\trentals := (dictRentals at: aCar ifAbsent: [ ^false ]).\r\t"rentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ])."\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrev and j := idxNext be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."\r\trentals findBinaryIndex: [ :arg | (date - (arg startDate)) asDays ] do: [:found | idxPrev := found. idxNext := found] ifNone: [:prev :next | idxPrev := prev. idxNext := next ].\r\t\r\t"Binary search can return indices that are not valid indices of the OrderedCollection rentals ."\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].\r\t(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= (date + (numDays - 1) days)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/24/2019 10:38',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentals idxPrev idxNext boundsCheck|\r\t"The variable rentals is a SortedCollection of CarRent objects."\r\trentals := (dictRentals at: aCar ifAbsent: [ ^false ]).\r\t\r\t"Using binary search, find the indices of the two rentals that have starting dates closest to the given date."\r\trentals findBinaryIndex: [ :arg | (date - (arg startDate)) asDays ] \r\t\tdo: [:found | idxPrev := found. idxNext := found] \r\t\tifNone: [:prev :next | idxPrev := prev. idxNext := next ].\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrev and j := idxNext be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].\r\t(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= (date + (numDays - 1) days)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/24/2019 10:45',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:46:30.92403+02:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentals idxPrev idxNext boundsCheck|\r\t"The variable rentals is a SortedCollection of CarRent objects."\r\trentals := (dictRentals at: aCar ifAbsent: [ ^false ]).\r\t\r\t"Using binary search, find the indices of the two rentals that have starting dates closest to the given date."\r\trentals findBinaryIndex: [ :arg | (date - (arg startDate)) asDays ] \r\t\tdo: [:found | idxPrev := found. idxNext := found] \r\t\tifNone: [:prev :next | idxPrev := prev. idxNext := next ].\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrev and j := idxNext be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].\r\t(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= (date + (numDays - 1) days)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/24/2019 10:45',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentals idxPrev idxNext boundsCheck|\r\t"The variable rentals is a SortedCollection of CarRent objects."\r\trentals := (dictRentals at: aCar ifAbsent: [ ^false ]).\r\t\r\t"Using binary search, find the indices of the two rentals that have starting dates closest to the given date."\r\trentals findBinaryIndex: [ :arg | (date - (arg startDate)) asDays ] \r\t\tdo: [:found | idxPrev := found. idxNext := found] \r\t\tifNone: [:prev :next | idxPrev := prev. idxNext := next ].\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. There is a conflict if and only if the rental starting date at idxPrev >= a OR the rental ending date at idxNext <= b."\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].\r\t(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= (date + (numDays - 1) days)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/24/2019 10:46',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:46:59.864692+02:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentals idxPrev idxNext boundsCheck|\r\t"The variable rentals is a SortedCollection of CarRent objects."\r\trentals := (dictRentals at: aCar ifAbsent: [ ^false ]).\r\t\r\t"Using binary search, find the indices of the two rentals that have starting dates closest to the given date."\r\trentals findBinaryIndex: [ :arg | (date - (arg startDate)) asDays ] \r\t\tdo: [:found | idxPrev := found. idxNext := found] \r\t\tifNone: [:prev :next | idxPrev := prev. idxNext := next ].\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. There is a conflict if and only if the rental starting date at idxPrev >= a OR the rental ending date at idxNext <= b."\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].\r\t(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= (date + (numDays - 1) days)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/24/2019 10:46',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentals idxPrev idxNext boundsCheck|\r\t"The variable rentals is a SortedCollection of CarRent objects."\r\trentals := (dictRentals at: aCar ifAbsent: [ ^false ]).\r\t\r\t"Using binary search, find the indices of the two rentals that have starting dates closest to the given date."\r\trentals findBinaryIndex: [ :arg | (date - (arg startDate)) asDays ] \r\t\tdo: [:found | idxPrev := found. idxNext := found] \r\t\tifNone: [:prev :next | idxPrev := prev. idxNext := next ].\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. There is a conflict if and only if the rental starting date at idxPrev >= a OR the rental ending date at idxNext <= b. The binary search may return invalid indices so we need to check for that as well."\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].\r\t(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= (date + (numDays - 1) days)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/24/2019 10:46',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:50:56.250007+02:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRent\r\tinstanceVariableNames: \'startDate endDate discount\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRent,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #startDate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #endDate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #discount,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRent class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRent class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRent				},				#parent : @7,				#content : 'This class represents a single rental of some Car.',				#stamp : 'JN 6/24/2019 10:41'			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRent\r\tinstanceVariableNames: \'startDate endDate totalPrice\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRent,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #startDate,					#parent : @27				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #endDate,					#parent : @27				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRent					},					#name : #totalPrice,					#parent : @27				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRent class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRent class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @27			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRent				},				#parent : @27,				#content : 'This class represents a single rental of some Car.',				#stamp : 'JN 6/24/2019 10:41'			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:51:01.423287+02:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #discount,			#protocol : #accessing,			#sourceCode : 'discount\r\t^ discount',			#stamp : 'JN 6/24/2019 10:11',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #discount,			#protocol : #'as yet unclassified',			#sourceCode : 'discount\r\t^ discount',			#stamp : 'JN 6/24/2019 10:11',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:51:01.429978+02:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #discount,			#protocol : #accessing,			#sourceCode : 'discount\r\t^ discount',			#stamp : 'JN 6/24/2019 10:11',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:51:23.376847+02:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'discount:',		#newSelector : #'totalPrice:',		#affectedClassName : 'CarRent>>#discount:'	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ],		#time : DateAndTime [ '2019-06-24T10:51:23.385313+02:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'totalPrice:',			#protocol : #accessing,			#sourceCode : 'totalPrice: anObject\r\tdiscount := anObject',			#stamp : 'JN 6/24/2019 10:51',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ],		#time : DateAndTime [ '2019-06-24T10:51:23.391873+02:00' ],		#trigger : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'CarRent class'			},			#name : #'startDate:endDate:discount:',			#protocol : #'instance creation',			#sourceCode : 'startDate: sDate endDate: eDate discount: disc\r\t^self new\r\t\tstartDate: sDate;\r\t\tendDate: eDate;\r\t\tdiscount: disc.',			#stamp : 'JN 6/24/2019 10:20',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'CarRent class'			},			#name : #'startDate:endDate:discount:',			#protocol : #'instance creation',			#sourceCode : 'startDate: sDate endDate: eDate discount: disc\r\t^self new\r\t\tstartDate: sDate;\r\t\tendDate: eDate;\r\t\ttotalPrice: disc.',			#stamp : 'JN 6/24/2019 10:51',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ],		#time : DateAndTime [ '2019-06-24T10:51:23.418933+02:00' ],		#trigger : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'discount:',			#protocol : #accessing,			#sourceCode : 'discount: anObject\r\tdiscount := anObject',			#stamp : 'JN 6/24/2019 10:11',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'discount:',			#protocol : #'as yet unclassified',			#sourceCode : 'discount: anObject\r\tdiscount := anObject',			#stamp : 'JN 6/24/2019 10:11',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ],		#time : DateAndTime [ '2019-06-24T10:51:23.422325+02:00' ],		#trigger : OmReference [ '64' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'discount:',			#protocol : #accessing,			#sourceCode : 'discount: anObject\r\tdiscount := anObject',			#stamp : 'JN 6/24/2019 10:11',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:51:44.810782+02:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'totalPrice:',			#protocol : #accessing,			#sourceCode : 'totalPrice: anObject\r\tdiscount := anObject',			#stamp : 'JN 6/24/2019 10:51',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'totalPrice:',			#protocol : #accessing,			#sourceCode : 'totalPrice: anObject\r\ttotalPrice := anObject',			#stamp : 'JN 6/24/2019 10:51',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:51:51.945004+02:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'totalPrice:',			#protocol : #accessing,			#sourceCode : 'totalPrice: anObject\r\ttotalPrice := anObject',			#stamp : 'JN 6/24/2019 10:51',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'totalPrice:',			#protocol : #accessing,			#sourceCode : 'totalPrice: price\r\ttotalPrice := price',			#stamp : 'JN 6/24/2019 10:51',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:52:07.603833+02:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'endDate:',			#protocol : #accessing,			#sourceCode : 'endDate: anObject\r\tendDate := anObject',			#stamp : 'JN 6/24/2019 10:11',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'endDate:',			#protocol : #accessing,			#sourceCode : 'endDate: aDate\r\tendDate := aDate',			#stamp : 'JN 6/24/2019 10:52',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:52:13.53388+02:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'startDate:',			#protocol : #accessing,			#sourceCode : 'startDate: anObject\r\tstartDate := anObject',			#stamp : 'JN 6/24/2019 10:11',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #'startDate:',			#protocol : #accessing,			#sourceCode : 'startDate: aDate\r\tstartDate := aDate',			#stamp : 'JN 6/24/2019 10:52',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:52:37.662942+02:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #totalPrice,			#protocol : #'as yet unclassified',			#sourceCode : 'totalPrice\r\t^ totalPrice',			#stamp : 'JN 6/24/2019 10:52',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:52:37.670744+02:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #totalPrice,			#protocol : #'as yet unclassified',			#sourceCode : 'totalPrice\r\t^ totalPrice',			#stamp : 'JN 6/24/2019 10:52',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRent			},			#name : #totalPrice,			#protocol : #accessing,			#sourceCode : 'totalPrice\r\t^ totalPrice',			#stamp : 'JN 6/24/2019 10:52',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:54:15.090742+02:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'startDate:endDate:discount:',		#newSelector : #'startDate:endDate:totalPrice:',		#affectedClassName : 'CarRent class>>#startDate:endDate:discount:'	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ],		#time : DateAndTime [ '2019-06-24T10:54:15.106381+02:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'CarRent class'			},			#name : #'startDate:endDate:totalPrice:',			#protocol : #'instance creation',			#sourceCode : 'startDate: sDate endDate: eDate totalPrice: disc\r\t^self new\r\t\tstartDate: sDate;\r\t\tendDate: eDate;\r\t\ttotalPrice: disc.',			#stamp : 'JN 6/24/2019 10:54',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ],		#time : DateAndTime [ '2019-06-24T10:54:15.136337+02:00' ],		#trigger : OmReference [ '75' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'CarRent class'			},			#name : #'startDate:endDate:discount:',			#protocol : #'instance creation',			#sourceCode : 'startDate: sDate endDate: eDate discount: disc\r\t^self new\r\t\tstartDate: sDate;\r\t\tendDate: eDate;\r\t\ttotalPrice: disc.',			#stamp : 'JN 6/24/2019 10:51',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'CarRent class'			},			#name : #'startDate:endDate:discount:',			#protocol : #'as yet unclassified',			#sourceCode : 'startDate: sDate endDate: eDate discount: disc\r\t^self new\r\t\tstartDate: sDate;\r\t\tendDate: eDate;\r\t\ttotalPrice: disc.',			#stamp : 'JN 6/24/2019 10:51',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ],		#time : DateAndTime [ '2019-06-24T10:54:15.139798+02:00' ],		#trigger : OmReference [ '75' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'CarRent class'			},			#name : #'startDate:endDate:discount:',			#protocol : #'instance creation',			#sourceCode : 'startDate: sDate endDate: eDate discount: disc\r\t^self new\r\t\tstartDate: sDate;\r\t\tendDate: eDate;\r\t\ttotalPrice: disc.',			#stamp : 'JN 6/24/2019 10:51',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T10:54:22.194685+02:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'CarRent class'			},			#name : #'startDate:endDate:totalPrice:',			#protocol : #'instance creation',			#sourceCode : 'startDate: sDate endDate: eDate totalPrice: disc\r\t^self new\r\t\tstartDate: sDate;\r\t\tendDate: eDate;\r\t\ttotalPrice: disc.',			#stamp : 'JN 6/24/2019 10:54',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'CarRent class'			},			#name : #'startDate:endDate:totalPrice:',			#protocol : #'instance creation',			#sourceCode : 'startDate: sDate endDate: eDate totalPrice: price\r\t^self new\r\t\tstartDate: sDate;\r\t\tendDate: eDate;\r\t\ttotalPrice: price.',			#stamp : 'JN 6/24/2019 10:54',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:03:06.24747+02:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:rentalData:',			#protocol : #action,			#sourceCode : 'rent: aCar rentalData: aCarRent\r\t',			#stamp : 'JN 6/24/2019 11:03',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:05:27.030316+02:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'carIsAvailable:days:startingOn:',		#newSelector : #'carIsAvailable:startDate:endDate:',		#affectedClassName : 'CarRental>>#carIsAvailable:days:startingOn:'	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ],		#time : DateAndTime [ '2019-06-24T11:05:27.04594+02:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:startDate:endDate:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar startDate: date endDate: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentals idxPrev idxNext boundsCheck|\r\t"The variable rentals is a SortedCollection of CarRent objects."\r\trentals := (dictRentals at: aCar ifAbsent: [ ^false ]).\r\t\r\t"Using binary search, find the indices of the two rentals that have starting dates closest to the given date."\r\trentals findBinaryIndex: [ :arg | (date - (arg startDate)) asDays ] \r\t\tdo: [:found | idxPrev := found. idxNext := found] \r\t\tifNone: [:prev :next | idxPrev := prev. idxNext := next ].\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. There is a conflict if and only if the rental starting date at idxPrev >= a OR the rental ending date at idxNext <= b. The binary search may return invalid indices so we need to check for that as well."\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].\r\t(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= (date + (numDays - 1) days)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/24/2019 11:05',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ],		#time : DateAndTime [ '2019-06-24T11:05:27.053463+02:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:days:',			#protocol : #action,			#sourceCode : 'availableCars: date days: numDays\r\t^ cars\r\t\tselect: [ :aCar | self carIsAvailable: aCar days: numDays startingOn: date ]',			#stamp : 'JN 6/22/2019 16:49',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:days:',			#protocol : #action,			#sourceCode : 'availableCars: date days: numDays\r\t^ cars\r\t\tselect: [ :aCar | self carIsAvailable: aCar startDate: date endDate: numDays ]',			#stamp : 'JN 6/24/2019 11:05',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ],		#time : DateAndTime [ '2019-06-24T11:05:27.058721+02:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:',			#protocol : #action,			#sourceCode : 'rentedCars: date days: numDays\r\t"returns the cars that are rented at some point in the requested time period"\r\r\t^ cars\r\t\treject: [ :aCar | self carIsAvailable: aCar days: numDays startingOn: date ]',			#stamp : 'JN 6/22/2019 16:49',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:',			#protocol : #action,			#sourceCode : 'rentedCars: date days: numDays\r\t"returns the cars that are rented at some point in the requested time period"\r\r\t^ cars\r\t\treject: [ :aCar | self carIsAvailable: aCar startDate: date endDate: numDays ]',			#stamp : 'JN 6/24/2019 11:05',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ],		#time : DateAndTime [ '2019-06-24T11:05:27.063655+02:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:startingOn:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays startingOn: date\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar days: numDays startingOn: date)\r\t\tifFalse: [ ^ false ].\r\t(dictRentals at: aCar) add: (CarRent startDate: date endDate: date + (numDays - 1) days).\r\t^ true',			#stamp : 'JN 6/24/2019 10:34',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:startingOn:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays startingOn: date\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar startDate: date endDate: numDays)\r\t\tifFalse: [ ^ false ].\r\t(dictRentals at: aCar)\r\t\tadd: (CarRent startDate: date endDate: date + (numDays - 1) days).\r\t^ true',			#stamp : 'JN 6/24/2019 11:05',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ],		#time : DateAndTime [ '2019-06-24T11:05:27.126755+02:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentals idxPrev idxNext boundsCheck|\r\t"The variable rentals is a SortedCollection of CarRent objects."\r\trentals := (dictRentals at: aCar ifAbsent: [ ^false ]).\r\t\r\t"Using binary search, find the indices of the two rentals that have starting dates closest to the given date."\r\trentals findBinaryIndex: [ :arg | (date - (arg startDate)) asDays ] \r\t\tdo: [:found | idxPrev := found. idxNext := found] \r\t\tifNone: [:prev :next | idxPrev := prev. idxNext := next ].\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. There is a conflict if and only if the rental starting date at idxPrev >= a OR the rental ending date at idxNext <= b. The binary search may return invalid indices so we need to check for that as well."\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].\r\t(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= (date + (numDays - 1) days)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/24/2019 10:46',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #'as yet unclassified',			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentals idxPrev idxNext boundsCheck|\r\t"The variable rentals is a SortedCollection of CarRent objects."\r\trentals := (dictRentals at: aCar ifAbsent: [ ^false ]).\r\t\r\t"Using binary search, find the indices of the two rentals that have starting dates closest to the given date."\r\trentals findBinaryIndex: [ :arg | (date - (arg startDate)) asDays ] \r\t\tdo: [:found | idxPrev := found. idxNext := found] \r\t\tifNone: [:prev :next | idxPrev := prev. idxNext := next ].\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. There is a conflict if and only if the rental starting date at idxPrev >= a OR the rental ending date at idxNext <= b. The binary search may return invalid indices so we need to check for that as well."\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].\r\t(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= (date + (numDays - 1) days)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/24/2019 10:46',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ],		#time : DateAndTime [ '2019-06-24T11:05:27.1323+02:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentals idxPrev idxNext boundsCheck|\r\t"The variable rentals is a SortedCollection of CarRent objects."\r\trentals := (dictRentals at: aCar ifAbsent: [ ^false ]).\r\t\r\t"Using binary search, find the indices of the two rentals that have starting dates closest to the given date."\r\trentals findBinaryIndex: [ :arg | (date - (arg startDate)) asDays ] \r\t\tdo: [:found | idxPrev := found. idxNext := found] \r\t\tifNone: [:prev :next | idxPrev := prev. idxNext := next ].\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. There is a conflict if and only if the rental starting date at idxPrev >= a OR the rental ending date at idxNext <= b. The binary search may return invalid indices so we need to check for that as well."\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].\r\t(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= (date + (numDays - 1) days)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/24/2019 10:46',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:06:41.063943+02:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:startDate:endDate:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar startDate: date endDate: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentals idxPrev idxNext boundsCheck|\r\t"The variable rentals is a SortedCollection of CarRent objects."\r\trentals := (dictRentals at: aCar ifAbsent: [ ^false ]).\r\t\r\t"Using binary search, find the indices of the two rentals that have starting dates closest to the given date."\r\trentals findBinaryIndex: [ :arg | (date - (arg startDate)) asDays ] \r\t\tdo: [:found | idxPrev := found. idxNext := found] \r\t\tifNone: [:prev :next | idxPrev := prev. idxNext := next ].\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. There is a conflict if and only if the rental starting date at idxPrev >= a OR the rental ending date at idxNext <= b. The binary search may return invalid indices so we need to check for that as well."\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].\r\t(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= (date + (numDays - 1) days)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/24/2019 11:05',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:startDate:endDate:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar startDate: sDate endDate: eDate\r\t"Returns true if the requested aCar can be rented in the interval of dates [ sDate, eDate ] and false otherwise."\r\t| rentals idxPrev idxNext boundsCheck|\r\t"The variable rentals is a SortedCollection of CarRent objects."\r\trentals := (dictRentals at: aCar ifAbsent: [ ^false ]).\r\t\r\t"Using binary search, find the indices of the two rentals that have starting dates closest to the given date."\r\trentals findBinaryIndex: [ :arg | (sDate - (arg startDate)) asDays ] \r\t\tdo: [:found | idxPrev := found. idxNext := found] \r\t\tifNone: [:prev :next | idxPrev := prev. idxNext := next ].\r\t\r\t"We need to check if the interval of dates [a,b] := [ sDate, eDate ] is free for rental. We can check this as follows. There is a conflict if and only if the rental starting date at idxPrev >= a OR the rental ending date at idxNext <= b. The binary search may return invalid indices so we need to check for that as well."\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentals size) ].\r\t(boundsCheck value: idxPrev) ifTrue: [((rentals at: idxPrev ) endDate >= sDate) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNext ) ifTrue: [((rentals at: idxNext ) startDate <= eDate) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/24/2019 11:06',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:07:36.156975+02:00' ],		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:days:',			#protocol : #action,			#sourceCode : 'availableCars: date days: numDays\r\t^ cars\r\t\tselect: [ :aCar | self carIsAvailable: aCar startDate: date endDate: numDays ]',			#stamp : 'JN 6/24/2019 11:05',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:days:',			#protocol : #action,			#sourceCode : 'availableCars: date days: numDays\r\t^ cars\r\t\tselect: [ :aCar | self carIsAvailable: aCar startDate: date endDate: date + (numDays - 1) days ]',			#stamp : 'JN 6/24/2019 11:07',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:08:38.553697+02:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'rent:days:startingOn:',		#newSelector : #'rent:startDate:days:',		#affectedClassName : 'CarRental>>#rent:days:startingOn:'	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ],		#time : DateAndTime [ '2019-06-24T11:08:38.566152+02:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startDate:days:',			#protocol : #action,			#sourceCode : 'rent: aCar startDate: date days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar startDate: date endDate: numDays)\r\t\tifFalse: [ ^ false ].\r\t(dictRentals at: aCar)\r\t\tadd: (CarRent startDate: date endDate: date + (numDays - 1) days).\r\t^ true',			#stamp : 'JN 6/24/2019 11:08',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ],		#time : DateAndTime [ '2019-06-24T11:08:38.57626+02:00' ],		#trigger : OmReference [ '90' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\t\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 100 days.\r\tcarRental rent: redPanda days: 5 startingOn: Date today + 100 days.\r\t\r\tself assert: carRental availableCars size equals: 1.\r\tself assert: (carRental availableCars: Date today + 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 1 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days) size equals: 1. \r\t\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 2.\r\tself assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.\r\tself assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 1 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 2 days days: 1 type: #panda) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.\r\t\r\t^ true.',			#stamp : 'JN 6/24/2019 09:47',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\tself assert: carRental availableCars size equals: 2.\r\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda startDate: Date today - 10 days days: 5.\r\tcarRental rent: redPanda startDate: Date today - 100 days days: 5.\r\tcarRental rent: redPanda startDate: Date today + 100 days days: 5.\r\tself assert: carRental availableCars size equals: 1.\r\tself\r\t\tassert: (carRental availableCars: Date today + 20 days) size\r\t\tequals: 2.\r\tself\r\t\tassert: (carRental availableCars: Date today - 20 days) size\r\t\tequals: 2.\r\tself\r\t\tassert: (carRental availableCars: Date today - 1 days) size\r\t\tequals: 2.\r\tself\r\t\tassert: (carRental availableCars: Date today + 3 days) size\r\t\tequals: 1.\r\tself\r\t\tassert: (carRental availableCars: Date today - 7 days) size\r\t\tequals: 1.\r\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 2.\r\tself\r\t\tassert: (carRental availableCars: Date today days: 1 type: #panda) size\r\t\tequals: 0.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today - 20 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 2.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today + 20 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 2.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today - 1 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 2.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today + 2 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 1.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today - 7 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 1.\r\t^ true',			#stamp : 'JN 6/24/2019 11:08',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ],		#time : DateAndTime [ '2019-06-24T11:08:38.580659+02:00' ],		#trigger : OmReference [ '90' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t^ self rent: aCar days: numDays startingOn: Date today',			#stamp : 'JN 6/22/2019 16:20',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t^ self rent: aCar startDate: Date today days: numDays',			#stamp : 'JN 6/24/2019 11:08',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ],		#time : DateAndTime [ '2019-06-24T11:08:38.585776+02:00' ],		#trigger : OmReference [ '90' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:startingOn:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays startingOn: date\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\r\t| possibleCars |\r\tpossibleCars := self availableCars: date days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first days: numDays startingOn: date ]',			#stamp : 'JN 6/22/2019 16:20',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:startingOn:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays startingOn: date\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\r\t| possibleCars |\r\tpossibleCars := self availableCars: date days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first startDate: date days: numDays ]',			#stamp : 'JN 6/24/2019 11:08',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ],		#time : DateAndTime [ '2019-06-24T11:08:38.628981+02:00' ],		#trigger : OmReference [ '90' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:startingOn:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays startingOn: date\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar startDate: date endDate: numDays)\r\t\tifFalse: [ ^ false ].\r\t(dictRentals at: aCar)\r\t\tadd: (CarRent startDate: date endDate: date + (numDays - 1) days).\r\t^ true',			#stamp : 'JN 6/24/2019 11:05',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:startingOn:',			#protocol : #'as yet unclassified',			#sourceCode : 'rent: aCar days: numDays startingOn: date\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar startDate: date endDate: numDays)\r\t\tifFalse: [ ^ false ].\r\t(dictRentals at: aCar)\r\t\tadd: (CarRent startDate: date endDate: date + (numDays - 1) days).\r\t^ true',			#stamp : 'JN 6/24/2019 11:05',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ],		#time : DateAndTime [ '2019-06-24T11:08:38.635197+02:00' ],		#trigger : OmReference [ '90' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:startingOn:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays startingOn: date\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar startDate: date endDate: numDays)\r\t\tifFalse: [ ^ false ].\r\t(dictRentals at: aCar)\r\t\tadd: (CarRent startDate: date endDate: date + (numDays - 1) days).\r\t^ true',			#stamp : 'JN 6/24/2019 11:05',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:09:05.173156+02:00' ],		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'rent:startDate:days:',		#newSelector : #'rent:startDate:endDate:',		#affectedClassName : 'CarRental>>#rent:startDate:days:'	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ],		#time : DateAndTime [ '2019-06-24T11:09:05.185465+02:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startDate:endDate:',			#protocol : #action,			#sourceCode : 'rent: aCar startDate: date endDate: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar startDate: date endDate: numDays)\r\t\tifFalse: [ ^ false ].\r\t(dictRentals at: aCar)\r\t\tadd: (CarRent startDate: date endDate: date + (numDays - 1) days).\r\t^ true',			#stamp : 'JN 6/24/2019 11:09',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ],		#time : DateAndTime [ '2019-06-24T11:09:05.195921+02:00' ],		#trigger : OmReference [ '97' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\tself assert: carRental availableCars size equals: 2.\r\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda startDate: Date today - 10 days days: 5.\r\tcarRental rent: redPanda startDate: Date today - 100 days days: 5.\r\tcarRental rent: redPanda startDate: Date today + 100 days days: 5.\r\tself assert: carRental availableCars size equals: 1.\r\tself\r\t\tassert: (carRental availableCars: Date today + 20 days) size\r\t\tequals: 2.\r\tself\r\t\tassert: (carRental availableCars: Date today - 20 days) size\r\t\tequals: 2.\r\tself\r\t\tassert: (carRental availableCars: Date today - 1 days) size\r\t\tequals: 2.\r\tself\r\t\tassert: (carRental availableCars: Date today + 3 days) size\r\t\tequals: 1.\r\tself\r\t\tassert: (carRental availableCars: Date today - 7 days) size\r\t\tequals: 1.\r\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 2.\r\tself\r\t\tassert: (carRental availableCars: Date today days: 1 type: #panda) size\r\t\tequals: 0.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today - 20 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 2.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today + 20 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 2.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today - 1 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 2.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today + 2 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 1.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today - 7 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 1.\r\t^ true',			#stamp : 'JN 6/24/2019 11:08',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\tself assert: carRental availableCars size equals: 2.\r\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda startDate: Date today - 10 days endDate: 5.\r\tcarRental rent: redPanda startDate: Date today - 100 days endDate: 5.\r\tcarRental rent: redPanda startDate: Date today + 100 days endDate: 5.\r\tself assert: carRental availableCars size equals: 1.\r\tself\r\t\tassert: (carRental availableCars: Date today + 20 days) size\r\t\tequals: 2.\r\tself\r\t\tassert: (carRental availableCars: Date today - 20 days) size\r\t\tequals: 2.\r\tself\r\t\tassert: (carRental availableCars: Date today - 1 days) size\r\t\tequals: 2.\r\tself\r\t\tassert: (carRental availableCars: Date today + 3 days) size\r\t\tequals: 1.\r\tself\r\t\tassert: (carRental availableCars: Date today - 7 days) size\r\t\tequals: 1.\r\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 2.\r\tself\r\t\tassert: (carRental availableCars: Date today days: 1 type: #panda) size\r\t\tequals: 0.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today - 20 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 2.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today + 20 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 2.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today - 1 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 2.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today + 2 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 1.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today - 7 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 1.\r\t^ true',			#stamp : 'JN 6/24/2019 11:09',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ],		#time : DateAndTime [ '2019-06-24T11:09:05.201038+02:00' ],		#trigger : OmReference [ '97' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t^ self rent: aCar startDate: Date today days: numDays',			#stamp : 'JN 6/24/2019 11:08',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t^ self rent: aCar startDate: Date today endDate: numDays',			#stamp : 'JN 6/24/2019 11:09',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ],		#time : DateAndTime [ '2019-06-24T11:09:05.206382+02:00' ],		#trigger : OmReference [ '97' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:startingOn:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays startingOn: date\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\r\t| possibleCars |\r\tpossibleCars := self availableCars: date days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first startDate: date days: numDays ]',			#stamp : 'JN 6/24/2019 11:08',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:startingOn:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays startingOn: date\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\r\t| possibleCars |\r\tpossibleCars := self availableCars: date days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first startDate: date endDate: numDays ]',			#stamp : 'JN 6/24/2019 11:09',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ],		#time : DateAndTime [ '2019-06-24T11:09:05.23666+02:00' ],		#trigger : OmReference [ '97' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startDate:days:',			#protocol : #action,			#sourceCode : 'rent: aCar startDate: date days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar startDate: date endDate: numDays)\r\t\tifFalse: [ ^ false ].\r\t(dictRentals at: aCar)\r\t\tadd: (CarRent startDate: date endDate: date + (numDays - 1) days).\r\t^ true',			#stamp : 'JN 6/24/2019 11:08',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startDate:days:',			#protocol : #'as yet unclassified',			#sourceCode : 'rent: aCar startDate: date days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar startDate: date endDate: numDays)\r\t\tifFalse: [ ^ false ].\r\t(dictRentals at: aCar)\r\t\tadd: (CarRent startDate: date endDate: date + (numDays - 1) days).\r\t^ true',			#stamp : 'JN 6/24/2019 11:08',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ],		#time : DateAndTime [ '2019-06-24T11:09:05.240673+02:00' ],		#trigger : OmReference [ '97' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startDate:days:',			#protocol : #action,			#sourceCode : 'rent: aCar startDate: date days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar startDate: date endDate: numDays)\r\t\tifFalse: [ ^ false ].\r\t(dictRentals at: aCar)\r\t\tadd: (CarRent startDate: date endDate: date + (numDays - 1) days).\r\t^ true',			#stamp : 'JN 6/24/2019 11:08',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:09:54.083949+02:00' ],		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startDate:endDate:',			#protocol : #action,			#sourceCode : 'rent: aCar startDate: date endDate: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar startDate: date endDate: numDays)\r\t\tifFalse: [ ^ false ].\r\t(dictRentals at: aCar)\r\t\tadd: (CarRent startDate: date endDate: date + (numDays - 1) days).\r\t^ true',			#stamp : 'JN 6/24/2019 11:09',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startDate:endDate:',			#protocol : #action,			#sourceCode : 'rent: aCar startDate: sDate endDate: eDate\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar startDate: sDate endDate: eDate)\r\t\tifFalse: [ ^ false ].\r\t(dictRentals at: aCar)\r\t\tadd: (CarRent startDate: sDate endDate: eDate).\r\t^ true',			#stamp : 'JN 6/24/2019 11:09',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:10:05.028308+02:00' ],		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'ManifestLifewareHR class'			},			#name : #ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #\'2019-06-22T14:22:00.415583+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days: #false)) #\'2019-06-22T16:13:01.383293+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days:type: #false)) #\'2019-06-22T16:14:27.070015+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:days:startingOn: #false)) #\'2019-06-22T16:20:23.601853+02:00\') )',			#stamp : 'JN 6/22/2019 16:20',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'ManifestLifewareHR class'			},			#name : #ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #\'2019-06-22T14:22:00.415583+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days: #false)) #\'2019-06-22T16:13:01.383293+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days:type: #false)) #\'2019-06-22T16:14:27.070015+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:days:startingOn: #false)) #\'2019-06-22T16:20:23.601853+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startDate:endDate: #false)) #\'2019-06-24T11:10:05.020725+02:00\') )',			#stamp : 'JN 6/24/2019 11:10',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:11:04.646248+02:00' ],		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t^ self rent: aCar startDate: Date today endDate: numDays',			#stamp : 'JN 6/24/2019 11:09',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t^ self rent: aCar startDate: Date today endDate: Date today + (numDays - 1) days',			#stamp : 'JN 6/24/2019 11:11',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:12:50.121362+02:00' ],		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:rentalData:',			#protocol : #action,			#sourceCode : 'rent: aCar rentalData: aCarRent\r\t',			#stamp : 'JN 6/24/2019 11:03',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:rentalData:',			#protocol : #action,			#sourceCode : 'rent: aCar rentalData: aCarRent\r\t"Tries to rent the given aCar with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar startDate: aCarRent startDate endDate: aCarRent endDate)\r\t\tifFalse: [ ^ false ].\r\t(dictRentals at: aCar) add: aCarRent.\r\t^ true',			#stamp : 'JN 6/24/2019 11:12',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:12:54.534549+02:00' ],		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'ManifestLifewareHR class'			},			#name : #ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #\'2019-06-22T14:22:00.415583+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days: #false)) #\'2019-06-22T16:13:01.383293+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days:type: #false)) #\'2019-06-22T16:14:27.070015+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:days:startingOn: #false)) #\'2019-06-22T16:20:23.601853+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startDate:endDate: #false)) #\'2019-06-24T11:10:05.020725+02:00\') )',			#stamp : 'JN 6/24/2019 11:10',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'ManifestLifewareHR class'			},			#name : #ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #\'2019-06-22T14:22:00.415583+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days: #false)) #\'2019-06-22T16:13:01.383293+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days:type: #false)) #\'2019-06-22T16:14:27.070015+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:days:startingOn: #false)) #\'2019-06-22T16:20:23.601853+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startDate:endDate: #false)) #\'2019-06-24T11:10:05.020725+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:rentalData: #false)) #\'2019-06-24T11:12:54.52723+02:00\') )',			#stamp : 'JN 6/24/2019 11:12',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:14:09.356502+02:00' ],		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:',			#protocol : #action,			#sourceCode : 'rentedCars: date days: numDays\r\t"returns the cars that are rented at some point in the requested time period"\r\r\t^ cars\r\t\treject: [ :aCar | self carIsAvailable: aCar startDate: date endDate: numDays ]',			#stamp : 'JN 6/24/2019 11:05',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:',			#protocol : #action,			#sourceCode : 'rentedCars: date days: numDays\r\t"returns the cars that are rented at some point in the requested time period"\r\r\t^ cars\r\t\treject: [ :aCar | self carIsAvailable: aCar startDate: date endDate: date + (numDays - 1) days ]',			#stamp : 'JN 6/24/2019 11:14',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:15:39.683275+02:00' ],		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:startingOn:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays startingOn: date\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\r\t| possibleCars |\r\tpossibleCars := self availableCars: date days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first startDate: date endDate: numDays ]',			#stamp : 'JN 6/24/2019 11:09',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:startingOn:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays startingOn: date\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\r\t| possibleCars |\r\tpossibleCars := self availableCars: date days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first startDate: date endDate: date + (numDays - 1) days ]',			#stamp : 'JN 6/24/2019 11:15',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:18:01.421281+02:00' ],		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\tself assert: carRental availableCars size equals: 2.\r\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda startDate: Date today - 10 days endDate: 5.\r\tcarRental rent: redPanda startDate: Date today - 100 days endDate: 5.\r\tcarRental rent: redPanda startDate: Date today + 100 days endDate: 5.\r\tself assert: carRental availableCars size equals: 1.\r\tself\r\t\tassert: (carRental availableCars: Date today + 20 days) size\r\t\tequals: 2.\r\tself\r\t\tassert: (carRental availableCars: Date today - 20 days) size\r\t\tequals: 2.\r\tself\r\t\tassert: (carRental availableCars: Date today - 1 days) size\r\t\tequals: 2.\r\tself\r\t\tassert: (carRental availableCars: Date today + 3 days) size\r\t\tequals: 1.\r\tself\r\t\tassert: (carRental availableCars: Date today - 7 days) size\r\t\tequals: 1.\r\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 2.\r\tself\r\t\tassert: (carRental availableCars: Date today days: 1 type: #panda) size\r\t\tequals: 0.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today - 20 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 2.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today + 20 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 2.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today - 1 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 2.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today + 2 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 1.\r\tself\r\t\tassert:\r\t\t\t(carRental availableCars: Date today - 7 days days: 1 type: #panda)\r\t\t\t\tsize\r\t\tequals: 1.\r\t^ true',			#stamp : 'JN 6/24/2019 11:09',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\tself assert: carRental availableCars size equals: 2.\r\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda startDate: Date today - 10 days endDate: 5.\r\tcarRental rent: redPanda startDate: Date today - 100 days endDate: 5.\r\tcarRental rent: redPanda startDate: Date today + 100 days endDate: 5.\r\tself assert: carRental availableCars size equals: 1.\r\tself assert: (carRental availableCars: Date today + 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 1 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days) size equals: 1.\r\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 2.\r\tself assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.\r\tself assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 1 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 2 days days: 1 type: #panda) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.\r\t^ true',			#stamp : 'JN 6/24/2019 11:18',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:19:11.400814+02:00' ],		#prior : OmReference [ '111' ],		#self : OmReference [ '112' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\tself assert: carRental availableCars size equals: 2.\r\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda startDate: Date today - 10 days endDate: 5.\r\tcarRental rent: redPanda startDate: Date today - 100 days endDate: 5.\r\tcarRental rent: redPanda startDate: Date today + 100 days endDate: 5.\r\tself assert: carRental availableCars size equals: 1.\r\tself assert: (carRental availableCars: Date today + 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 1 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days) size equals: 1.\r\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 2.\r\tself assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.\r\tself assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 1 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 2 days days: 1 type: #panda) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.\r\t^ true',			#stamp : 'JN 6/24/2019 11:18',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'4 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\tself assert: carRental availableCars size equals: 2.\r\r\t"Rent the same car on different times, both times for 5 days."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda startDate: Date today - 10 days endDate: Date today - 5 days.\r\tcarRental rent: redPanda startDate: Date today - 100 days endDate: Date today - 5 days.\r\tcarRental rent: redPanda startDate: Date today + 100 days endDate: Date today - 5 days.\r\tself assert: carRental availableCars size equals: 1.\r\tself assert: (carRental availableCars: Date today + 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 20 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 1 days) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 3 days) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days) size equals: 1.\r\r\t"Rent also the other car"\r\tcarRental rent: yellowPanda days: 2.\r\tself assert: (carRental availableCars: Date today days: 1 type: #panda) size equals: 0.\r\tself assert: (carRental availableCars: Date today - 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 20 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today - 1 days days: 1 type: #panda) size equals: 2.\r\tself assert: (carRental availableCars: Date today + 2 days days: 1 type: #panda) size equals: 1.\r\tself assert: (carRental availableCars: Date today - 7 days days: 1 type: #panda) size equals: 1.\r\t^ true',			#stamp : 'JN 6/24/2019 11:19',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:23:05.011151+02:00' ],		#prior : OmReference [ '112' ],		#self : OmReference [ '113' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalData:',			#protocol : #action,			#sourceCode : 'rentType: aType rentalData: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars := self availableCars: aCarRent startDate days: ((aCarRent startDate - aCarRent endDate) asDays) type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 11:23',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:24:11.024452+02:00' ],		#prior : OmReference [ '113' ],		#self : OmReference [ '114' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalData:',			#protocol : #action,			#sourceCode : 'rentType: aType rentalData: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars := self availableCars: aCarRent startDate days: ((aCarRent startDate - aCarRent endDate) asDays) type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 11:23',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalData:',			#protocol : #action,			#sourceCode : 'rentType: aType rentalData: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars := self availableCars: aCarRent startDate days: ((aCarRent startDate - aCarRent endDate) asDays + 1) type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 11:24',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:25:25.622149+02:00' ],		#prior : OmReference [ '114' ],		#self : OmReference [ '115' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'rentType:days:startingOn:',		#newSelector : #'rentType:startDate:endDate:',		#affectedClassName : 'CarRental>>#rentType:days:startingOn:'	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '115' ],		#self : OmReference [ '116' ],		#time : DateAndTime [ '2019-06-24T11:25:25.633603+02:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:startDate:endDate:',			#protocol : #action,			#sourceCode : 'rentType: aType startDate: date endDate: numDays\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\r\t| possibleCars |\r\tpossibleCars := self availableCars: date days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first startDate: date endDate: date + (numDays - 1) days ]',			#stamp : 'JN 6/24/2019 11:25',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '116' ],		#self : OmReference [ '117' ],		#time : DateAndTime [ '2019-06-24T11:25:25.64349+02:00' ],		#trigger : OmReference [ '115' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that checking the available cars work for the case of golf. See also the test \'testCarIsAvailable\'."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tself assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test the Tesla renting with discount"\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla days: 5 startingOn: date) equals: true.\r\t',			#stamp : 'JN 6/24/2019 09:55',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r\t| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [ :i | carRental addCar: Car panda ].\r\t1 to: 2 do: [ :i | carRental addCar: Car tesla ].\r\t1 to: 1 do: [ :i | carRental addCar: Car golf ].\r\tself assert: carRental availableCars size equals: 6.\r\r\t"Test that checking the available cars work for the case of golf. See also the test \'testCarIsAvailable\'."\r\tdate := Date year: 2019 month: 4 day: 1.\r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself\r\t\tassert: (carRental availableCars: date days: 4 type: #golf) size\r\t\tequals: 1.\r\tself\r\t\tassert: (carRental rentType: #golf startDate: date - 5 days endDate: 8)\r\t\tequals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself\r\t\tassert: (carRental availableCars: date days: 1 type: #golf) size\r\t\tequals: 0.\r\r\t"Test the Tesla renting with discount"\r\tself\r\t\tassert: (carRental availableCars: date days: 5 type: #tesla) size\r\t\tequals: 2.\r\tself\r\t\tassert: (carRental rentType: #tesla startDate: date endDate: 5)\r\t\tequals: true',			#stamp : 'JN 6/24/2019 11:25',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '117' ],		#self : OmReference [ '118' ],		#time : DateAndTime [ '2019-06-24T11:25:25.772489+02:00' ],		#trigger : OmReference [ '115' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays\r\t^ self rentType: aType days: numDays startingOn: Date today.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:19',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays\r\t^ self rentType: aType startDate: Date today endDate: numDays',			#stamp : 'JN 6/24/2019 11:25',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '118' ],		#self : OmReference [ '119' ],		#time : DateAndTime [ '2019-06-24T11:25:25.802274+02:00' ],		#trigger : OmReference [ '115' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:startingOn:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays startingOn: date\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\r\t| possibleCars |\r\tpossibleCars := self availableCars: date days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first startDate: date endDate: date + (numDays - 1) days ]',			#stamp : 'JN 6/24/2019 11:15',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:startingOn:',			#protocol : #'as yet unclassified',			#sourceCode : 'rentType: aType days: numDays startingOn: date\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\r\t| possibleCars |\r\tpossibleCars := self availableCars: date days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first startDate: date endDate: date + (numDays - 1) days ]',			#stamp : 'JN 6/24/2019 11:15',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '119' ],		#self : OmReference [ '120' ],		#time : DateAndTime [ '2019-06-24T11:25:25.805098+02:00' ],		#trigger : OmReference [ '115' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:startingOn:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays startingOn: date\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\r\t| possibleCars |\r\tpossibleCars := self availableCars: date days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first startDate: date endDate: date + (numDays - 1) days ]',			#stamp : 'JN 6/24/2019 11:15',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:27:28.894261+02:00' ],		#prior : OmReference [ '120' ],		#self : OmReference [ '121' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:startDate:endDate:',			#protocol : #action,			#sourceCode : 'rentType: aType startDate: date endDate: numDays\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\r\t| possibleCars |\r\tpossibleCars := self availableCars: date days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first startDate: date endDate: date + (numDays - 1) days ]',			#stamp : 'JN 6/24/2019 11:25',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:startDate:endDate:',			#protocol : #action,			#sourceCode : 'rentType: aType startDate: sDate endDate: eDate\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\t^ self rentType: aType rentalData: (CarRent startDate: sDate endDate:eDate).',			#stamp : 'JN 6/24/2019 11:27',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:28:31.933191+02:00' ],		#prior : OmReference [ '121' ],		#self : OmReference [ '122' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays\r\t^ self rentType: aType startDate: Date today endDate: numDays',			#stamp : 'JN 6/24/2019 11:25',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays\r\t^ self rentType: aType startDate: Date today endDate: (Date today + (numDays - 1) days)',			#stamp : 'JN 6/24/2019 11:28',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:40:39.895514+02:00' ],		#prior : OmReference [ '122' ],		#self : OmReference [ '123' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startDate:endDate:',			#protocol : #action,			#sourceCode : 'rent: aCar startDate: sDate endDate: eDate\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar startDate: sDate endDate: eDate)\r\t\tifFalse: [ ^ false ].\r\t(dictRentals at: aCar)\r\t\tadd: (CarRent startDate: sDate endDate: eDate).\r\t^ true',			#stamp : 'JN 6/24/2019 11:09',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startDate:endDate:',			#protocol : #action,			#sourceCode : 'rent: aCar startDate: sDate endDate: eDate\r\t^ self rent: aCar rentalData: (CarRent startDate: sDate endDate: eDate totalPrice: (self priceFor: aCar days: ((sDate - eDate) asDays + 1 ) ) )',			#stamp : 'JN 6/24/2019 11:40',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:45:04.157786+02:00' ],		#prior : OmReference [ '123' ],		#self : OmReference [ '124' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRental\r\tinstanceVariableNames: \'cars dictRentals\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRental,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #cars,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #dictRentals,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRental class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRental class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRental				},				#parent : @7,				#content : 'commentStamp: \'LWhr 3/28/2017 14:51\' prior: 0',				#stamp : 'VincentBlondeau 3/25/2019 10:12'			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		},		#protocol : #action-private	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:45:12.990178+02:00' ],		#prior : OmReference [ '124' ],		#self : OmReference [ '125' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:rentalData:',			#protocol : #action,			#sourceCode : 'rent: aCar rentalData: aCarRent\r\t"Tries to rent the given aCar with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar startDate: aCarRent startDate endDate: aCarRent endDate)\r\t\tifFalse: [ ^ false ].\r\t(dictRentals at: aCar) add: aCarRent.\r\t^ true',			#stamp : 'JN 6/24/2019 11:12',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:rentalData:',			#protocol : #action-private,			#sourceCode : 'rent: aCar rentalData: aCarRent\r\t"Tries to rent the given aCar with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar startDate: aCarRent startDate endDate: aCarRent endDate)\r\t\tifFalse: [ ^ false ].\r\t(dictRentals at: aCar) add: aCarRent.\r\t^ true',			#stamp : 'JN 6/24/2019 11:12',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:45:15.564295+02:00' ],		#prior : OmReference [ '125' ],		#self : OmReference [ '126' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalData:',			#protocol : #action,			#sourceCode : 'rentType: aType rentalData: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars := self availableCars: aCarRent startDate days: ((aCarRent startDate - aCarRent endDate) asDays + 1) type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 11:29',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalData:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalData: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars := self availableCars: aCarRent startDate days: ((aCarRent startDate - aCarRent endDate) asDays + 1) type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 11:29',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:49:35.891597+02:00' ],		#prior : OmReference [ '126' ],		#self : OmReference [ '127' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays\r\t^ self rentType: aType startDate: Date today endDate: (Date today + (numDays - 1) days)',			#stamp : 'JN 6/24/2019 11:28',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:',			#protocol : #'as yet unclassified',			#sourceCode : 'rentType: aType days: numDays\r\t^ self rentType: aType startDate: Date today endDate: (Date today + (numDays - 1) days)',			#stamp : 'JN 6/24/2019 11:28',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:49:35.896673+02:00' ],		#prior : OmReference [ '127' ],		#self : OmReference [ '128' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays\r\t^ self rentType: aType startDate: Date today endDate: (Date today + (numDays - 1) days)',			#stamp : 'JN 6/24/2019 11:28',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:52:11.40957+02:00' ],		#prior : OmReference [ '128' ],		#self : OmReference [ '129' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalData:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalData: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars := self availableCars: aCarRent startDate days: ((aCarRent startDate - aCarRent endDate) asDays + 1) type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 11:29',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalData:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalData: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars := self availableCars: aCarRent startDate days: ((aCarRent endDate - aCarRent startDate) asDays + 1) type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 11:52',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:52:56.64651+02:00' ],		#prior : OmReference [ '129' ],		#self : OmReference [ '130' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r\t| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [ :i | carRental addCar: Car panda ].\r\t1 to: 2 do: [ :i | carRental addCar: Car tesla ].\r\t1 to: 1 do: [ :i | carRental addCar: Car golf ].\r\tself assert: carRental availableCars size equals: 6.\r\r\t"Test that checking the available cars work for the case of golf. See also the test \'testCarIsAvailable\'."\r\tdate := Date year: 2019 month: 4 day: 1.\r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself\r\t\tassert: (carRental availableCars: date days: 4 type: #golf) size\r\t\tequals: 1.\r\tself\r\t\tassert: (carRental rentType: #golf startDate: date - 5 days endDate: 8)\r\t\tequals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself\r\t\tassert: (carRental availableCars: date days: 1 type: #golf) size\r\t\tequals: 0.\r\r\t"Test the Tesla renting with discount"\r\tself\r\t\tassert: (carRental availableCars: date days: 5 type: #tesla) size\r\t\tequals: 2.\r\tself\r\t\tassert: (carRental rentType: #tesla startDate: date endDate: 5)\r\t\tequals: true',			#stamp : 'JN 6/24/2019 11:25',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r\t| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [ :i | carRental addCar: Car panda ].\r\t1 to: 2 do: [ :i | carRental addCar: Car tesla ].\r\t1 to: 1 do: [ :i | carRental addCar: Car golf ].\r\tself assert: carRental availableCars size equals: 6.\r\r\t"Test that checking the available cars work for the case of golf. See also the test \'testCarIsAvailable\'."\r\tdate := Date year: 2019 month: 4 day: 1.\r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself\r\t\tassert: (carRental availableCars: date days: 4 type: #golf) size\r\t\tequals: 1.\r\tself\r\t\tassert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days)\r\t\tequals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself\r\t\tassert: (carRental availableCars: date days: 1 type: #golf) size\r\t\tequals: 0.\r\r\t"Test the Tesla renting with discount"\r\tself\r\t\tassert: (carRental availableCars: date days: 5 type: #tesla) size\r\t\tequals: 2.\r\tself\r\t\tassert: (carRental rentType: #tesla startDate: date endDate: 5)\r\t\tequals: true',			#stamp : 'JN 6/24/2019 11:52',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:53:23.723187+02:00' ],		#prior : OmReference [ '130' ],		#self : OmReference [ '131' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r\t| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [ :i | carRental addCar: Car panda ].\r\t1 to: 2 do: [ :i | carRental addCar: Car tesla ].\r\t1 to: 1 do: [ :i | carRental addCar: Car golf ].\r\tself assert: carRental availableCars size equals: 6.\r\r\t"Test that checking the available cars work for the case of golf. See also the test \'testCarIsAvailable\'."\r\tdate := Date year: 2019 month: 4 day: 1.\r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself\r\t\tassert: (carRental availableCars: date days: 4 type: #golf) size\r\t\tequals: 1.\r\tself\r\t\tassert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days)\r\t\tequals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself\r\t\tassert: (carRental availableCars: date days: 1 type: #golf) size\r\t\tequals: 0.\r\r\t"Test the Tesla renting with discount"\r\tself\r\t\tassert: (carRental availableCars: date days: 5 type: #tesla) size\r\t\tequals: 2.\r\tself\r\t\tassert: (carRental rentType: #tesla startDate: date endDate: 5)\r\t\tequals: true',			#stamp : 'JN 6/24/2019 11:52',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r\t| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [ :i | carRental addCar: Car panda ].\r\t1 to: 2 do: [ :i | carRental addCar: Car tesla ].\r\t1 to: 1 do: [ :i | carRental addCar: Car golf ].\r\tself assert: carRental availableCars size equals: 6.\r\r\t"Test that checking the available cars work for the case of golf. See also the test \'testCarIsAvailable\'."\r\tdate := Date year: 2019 month: 4 day: 1.\r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself\r\t\tassert: (carRental availableCars: date days: 4 type: #golf) size\r\t\tequals: 1.\r\tself\r\t\tassert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days)\r\t\tequals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself\r\t\tassert: (carRental availableCars: date days: 1 type: #golf) size\r\t\tequals: 0.\r\r\t"Test the Tesla renting with discount"\r\tself\r\t\tassert: (carRental availableCars: date days: 5 type: #tesla) size\r\t\tequals: 2.\r\tself\r\t\tassert: (carRental rentType: #tesla startDate: date endDate: date + 4 days)\r\t\tequals: true',			#stamp : 'JN 6/24/2019 11:53',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:55:48.673839+02:00' ],		#prior : OmReference [ '131' ],		#self : OmReference [ '132' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startDate:endDate:discount:',			#protocol : #'as yet unclassified',			#sourceCode : 'rent: aCar startDate: sDate endDate: eDate discount: disc\r\t^ self rent: aCar rentalData: (CarRent startDate: sDate endDate: eDate totalPrice: (self priceFor: aCar days: ((sDate - eDate) asDays + 1 ) ) )',			#stamp : 'JN 6/24/2019 11:55',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:56:05.729502+02:00' ],		#prior : OmReference [ '132' ],		#self : OmReference [ '133' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startDate:endDate:discount:',			#protocol : #'as yet unclassified',			#sourceCode : 'rent: aCar startDate: sDate endDate: eDate discount: disc\r\t^ self rent: aCar rentalData: (CarRent startDate: sDate endDate: eDate totalPrice: (self priceFor: aCar days: ((sDate - eDate) asDays + 1 ) ) )',			#stamp : 'JN 6/24/2019 11:55',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startDate:endDate:discount:',			#protocol : #'as yet unclassified',			#sourceCode : 'rent: aCar startDate: sDate endDate: eDate discount: disc\r\t^ self rent: aCar rentalData: (CarRent startDate: sDate endDate: eDate totalPrice: (self priceFor: aCar days: ((sDate - eDate) asDays + 1 ) discount: disc ) )',			#stamp : 'JN 6/24/2019 11:56',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:56:21.316459+02:00' ],		#prior : OmReference [ '133' ],		#self : OmReference [ '134' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'priceFor:days:discount:',			#protocol : #action,			#sourceCode : 'priceFor: aCar days: numDays discount: disc\r\t| price |\r\t"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"\r\tprice := aCar price * numDays.\r\t(numDays > 3)\r\t\tifTrue: [ price := price - (numDays - 3 * aCar price * 0.1) ].\r\t"Alternatively we could write in one line"\r\t"price := (aCar price * numDays) -  ((numDays - 3 max: 0) * aCar price * 0.1)."\r\t^ price',			#stamp : 'JN 6/24/2019 11:56',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:57:59.988175+02:00' ],		#prior : OmReference [ '134' ],		#self : OmReference [ '135' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'priceFor:days:discount:',			#protocol : #action,			#sourceCode : 'priceFor: aCar days: numDays discount: disc\r\t| price |\r\t"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"\r\tprice := aCar price * numDays.\r\t(numDays > 3)\r\t\tifTrue: [ price := price - (numDays - 3 * aCar price * 0.1) ].\r\t"Alternatively we could write in one line"\r\t"price := (aCar price * numDays) -  ((numDays - 3 max: 0) * aCar price * 0.1)."\r\t^ price',			#stamp : 'JN 6/24/2019 11:56',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'priceFor:days:discount:',			#protocol : #action,			#sourceCode : 'priceFor: aCar days: numDays discount: disc\r\t| price |\r\t"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"\r\tprice := aCar price * numDays.\r\t(numDays > 3)\r\t\tifTrue: [ price := price - (numDays - 3 * aCar price * 0.1) ].\r\tprice := 0 max: price - (disc * numDays).\r\t^ price',			#stamp : 'JN 6/24/2019 11:57',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:58:37.934713+02:00' ],		#prior : OmReference [ '135' ],		#self : OmReference [ '136' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'priceFor:days:',			#protocol : #action,			#sourceCode : 'priceFor: aCar days: numDays\r\t| price |\r\t"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"\r\tprice := aCar price * numDays.\r\t(numDays > 3)\r\t\tifTrue: [ price := price - (numDays - 3 * aCar price * 0.1) ].\r\t"Alternatively we could write in one line"\r\t"price := (aCar price * numDays) -  ((numDays - 3 max: 0) * aCar price * 0.1)."\r\t^ price',			#stamp : 'JN 6/22/2019 12:50',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'priceFor:days:',			#protocol : #action,			#sourceCode : 'priceFor: aCar days: numDays\r\t^ self priceFor: aCar days: numDays discount: 0.',			#stamp : 'JN 6/24/2019 11:58',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:58:50.18747+02:00' ],		#prior : OmReference [ '136' ],		#self : OmReference [ '137' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startDate:endDate:discount:',			#protocol : #'as yet unclassified',			#sourceCode : 'rent: aCar startDate: sDate endDate: eDate discount: disc\r\t^ self rent: aCar rentalData: (CarRent startDate: sDate endDate: eDate totalPrice: (self priceFor: aCar days: ((sDate - eDate) asDays + 1 ) discount: disc ) )',			#stamp : 'JN 6/24/2019 11:56',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startDate:endDate:discount:',			#protocol : #action,			#sourceCode : 'rent: aCar startDate: sDate endDate: eDate discount: disc\r\t^ self rent: aCar rentalData: (CarRent startDate: sDate endDate: eDate totalPrice: (self priceFor: aCar days: ((sDate - eDate) asDays + 1 ) discount: disc ) )',			#stamp : 'JN 6/24/2019 11:56',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T11:59:56.811616+02:00' ],		#prior : OmReference [ '137' ],		#self : OmReference [ '138' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startDate:endDate:',			#protocol : #action,			#sourceCode : 'rent: aCar startDate: sDate endDate: eDate\r\t^ self rent: aCar rentalData: (CarRent startDate: sDate endDate: eDate totalPrice: (self priceFor: aCar days: ((sDate - eDate) asDays + 1 ) ) )',			#stamp : 'JN 6/24/2019 11:40',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startDate:endDate:',			#protocol : #action,			#sourceCode : 'rent: aCar startDate: sDate endDate: eDate\r\t^ self rent: aCar startDate: sDate endDate: eDate discount: 0.',			#stamp : 'JN 6/24/2019 11:59',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:02:37.560008+02:00' ],		#prior : OmReference [ '138' ],		#self : OmReference [ '139' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalData:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalData: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars := self availableCars: aCarRent startDate days: ((aCarRent endDate - aCarRent startDate) asDays + 1) type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 11:52',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalData:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalData: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars := self availableCars: aCarRent startDate days: ((aCarRent endDate - aCarRent startDate) asDays + 1) type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalprice: 5.\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:02',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:03:43.2603+02:00' ],		#prior : OmReference [ '139' ],		#self : OmReference [ '140' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalData:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalData: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars := self availableCars: aCarRent startDate days: ((aCarRent endDate - aCarRent startDate) asDays + 1) type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalprice: 5.\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:02',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalData:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalData: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars := self availableCars: aCarRent startDate days: ((aCarRent endDate - aCarRent startDate) asDays + 1) type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalPrice: (self priceFor: possibleCars first days: (1) ).\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:03',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:05:08.467647+02:00' ],		#prior : OmReference [ '140' ],		#self : OmReference [ '141' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalData:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalData: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars := self availableCars: aCarRent startDate days: ((aCarRent endDate - aCarRent startDate) asDays + 1) type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalPrice: (self priceFor: possibleCars first days: (1) ).\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:03',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalData:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalData: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars numDays|\r\tnumDays := (aCarRent endDate - aCarRent startDate) asDays + 1.\r\tpossibleCars := self availableCars: aCarRent startDate days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalPrice: (self priceFor: possibleCars first days: numDays ).\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:05',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:06:20.221948+02:00' ],		#prior : OmReference [ '141' ],		#self : OmReference [ '142' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'rentType:rentalData:',		#newSelector : #'rentType:rentalDataWithoutPrice:',		#affectedClassName : 'CarRental>>#rentType:rentalData:'	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '142' ],		#self : OmReference [ '143' ],		#time : DateAndTime [ '2019-06-24T12:06:20.23289+02:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalDataWithoutPrice:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalDataWithoutPrice: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars numDays|\r\tnumDays := (aCarRent endDate - aCarRent startDate) asDays + 1.\r\tpossibleCars := self availableCars: aCarRent startDate days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalPrice: (self priceFor: possibleCars first days: numDays ).\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:06',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '143' ],		#self : OmReference [ '144' ],		#time : DateAndTime [ '2019-06-24T12:06:20.240134+02:00' ],		#trigger : OmReference [ '142' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:startDate:endDate:',			#protocol : #action,			#sourceCode : 'rentType: aType startDate: sDate endDate: eDate\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\t^ self rentType: aType rentalData: (CarRent startDate: sDate endDate:eDate).',			#stamp : 'JN 6/24/2019 11:27',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:startDate:endDate:',			#protocol : #action,			#sourceCode : 'rentType: aType startDate: sDate endDate: eDate\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\t^ self rentType: aType rentalDataWithoutPrice: (CarRent startDate: sDate endDate:eDate).',			#stamp : 'JN 6/24/2019 12:06',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '144' ],		#self : OmReference [ '145' ],		#time : DateAndTime [ '2019-06-24T12:06:20.270552+02:00' ],		#trigger : OmReference [ '142' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalData:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalData: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars numDays|\r\tnumDays := (aCarRent endDate - aCarRent startDate) asDays + 1.\r\tpossibleCars := self availableCars: aCarRent startDate days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalPrice: (self priceFor: possibleCars first days: numDays ).\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:06',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalData:',			#protocol : #'as yet unclassified',			#sourceCode : 'rentType: aType rentalData: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars numDays|\r\tnumDays := (aCarRent endDate - aCarRent startDate) asDays + 1.\r\tpossibleCars := self availableCars: aCarRent startDate days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalPrice: (self priceFor: possibleCars first days: numDays ).\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:06',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '145' ],		#self : OmReference [ '146' ],		#time : DateAndTime [ '2019-06-24T12:06:20.273726+02:00' ],		#trigger : OmReference [ '142' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalData:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalData: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars numDays|\r\tnumDays := (aCarRent endDate - aCarRent startDate) asDays + 1.\r\tpossibleCars := self availableCars: aCarRent startDate days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalPrice: (self priceFor: possibleCars first days: numDays ).\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:06',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:07:33.773111+02:00' ],		#prior : OmReference [ '146' ],		#self : OmReference [ '147' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalDataWithoutPrice:discount:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalDataWithoutPrice: aCarRent discount: disc\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars numDays|\r\tnumDays := (aCarRent endDate - aCarRent startDate) asDays + 1.\r\tpossibleCars := self availableCars: aCarRent startDate days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalPrice: (self priceFor: possibleCars first days: numDays ).\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:07',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:07:46.467375+02:00' ],		#prior : OmReference [ '147' ],		#self : OmReference [ '148' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalDataWithoutPrice:discount:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalDataWithoutPrice: aCarRent discount: disc\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars numDays|\r\tnumDays := (aCarRent endDate - aCarRent startDate) asDays + 1.\r\tpossibleCars := self availableCars: aCarRent startDate days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalPrice: (self priceFor: possibleCars first days: numDays ).\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:07',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalDataWithoutPrice:discount:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalDataWithoutPrice: aCarRent discount: disc\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars numDays|\r\tnumDays := (aCarRent endDate - aCarRent startDate) asDays + 1.\r\tpossibleCars := self availableCars: aCarRent startDate days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalPrice: (self priceFor: possibleCars first days: numDays discount: disc).\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:07',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:08:14.818069+02:00' ],		#prior : OmReference [ '148' ],		#self : OmReference [ '149' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:startDate:endDate:',			#protocol : #action,			#sourceCode : 'rentType: aType startDate: sDate endDate: eDate\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\t^ self rentType: aType rentalDataWithoutPrice: (CarRent startDate: sDate endDate:eDate).',			#stamp : 'JN 6/24/2019 12:06',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:startDate:endDate:',			#protocol : #action,			#sourceCode : 'rentType: aType startDate: sDate endDate: eDate\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\t^ self rentType: aType rentalDataWithoutPrice: (CarRent startDate: sDate endDate:eDate) discount: 0.',			#stamp : 'JN 6/24/2019 12:08',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:08:18.53042+02:00' ],		#prior : OmReference [ '149' ],		#self : OmReference [ '150' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:startDate:endDate:',			#protocol : #action,			#sourceCode : 'rentType: aType startDate: sDate endDate: eDate\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\t^ self rentType: aType rentalDataWithoutPrice: (CarRent startDate: sDate endDate:eDate) discount: 0.',			#stamp : 'JN 6/24/2019 12:08',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:startDate:endDate:',			#protocol : #action,			#sourceCode : 'rentType: aType startDate: sDate endDate: eDate\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\t^ self rentType: aType rentalDataWithoutPrice: (CarRent startDate: sDate endDate: eDate) discount: 0.',			#stamp : 'JN 6/24/2019 12:08',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:08:34.850183+02:00' ],		#prior : OmReference [ '150' ],		#self : OmReference [ '151' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:startDate:endDate:discount:',			#protocol : #'as yet unclassified',			#sourceCode : 'rentType: aType startDate: sDate endDate: eDate discount: disc\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\t^ self rentType: aType rentalDataWithoutPrice: (CarRent startDate: sDate endDate: eDate) discount: 0.',			#stamp : 'JN 6/24/2019 12:08',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:08:41.78632+02:00' ],		#prior : OmReference [ '151' ],		#self : OmReference [ '152' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:startDate:endDate:discount:',			#protocol : #'as yet unclassified',			#sourceCode : 'rentType: aType startDate: sDate endDate: eDate discount: disc\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\t^ self rentType: aType rentalDataWithoutPrice: (CarRent startDate: sDate endDate: eDate) discount: 0.',			#stamp : 'JN 6/24/2019 12:08',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:startDate:endDate:discount:',			#protocol : #'as yet unclassified',			#sourceCode : 'rentType: aType startDate: sDate endDate: eDate discount: disc\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\t^ self rentType: aType rentalDataWithoutPrice: (CarRent startDate: sDate endDate: eDate) discount: disc.',			#stamp : 'JN 6/24/2019 12:08',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:08:45.80251+02:00' ],		#prior : OmReference [ '152' ],		#self : OmReference [ '153' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:startDate:endDate:discount:',			#protocol : #'as yet unclassified',			#sourceCode : 'rentType: aType startDate: sDate endDate: eDate discount: disc\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\t^ self rentType: aType rentalDataWithoutPrice: (CarRent startDate: sDate endDate: eDate) discount: disc.',			#stamp : 'JN 6/24/2019 12:08',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:startDate:endDate:discount:',			#protocol : #action,			#sourceCode : 'rentType: aType startDate: sDate endDate: eDate discount: disc\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\t^ self rentType: aType rentalDataWithoutPrice: (CarRent startDate: sDate endDate: eDate) discount: disc.',			#stamp : 'JN 6/24/2019 12:08',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:09:49.067655+02:00' ],		#prior : OmReference [ '153' ],		#self : OmReference [ '154' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalDataWithoutPrice:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalDataWithoutPrice: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars numDays|\r\tnumDays := (aCarRent endDate - aCarRent startDate) asDays + 1.\r\tpossibleCars := self availableCars: aCarRent startDate days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalPrice: (self priceFor: possibleCars first days: numDays ).\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:06',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalDataWithoutPrice:',			#protocol : #'as yet unclassified',			#sourceCode : 'rentType: aType rentalDataWithoutPrice: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars numDays|\r\tnumDays := (aCarRent endDate - aCarRent startDate) asDays + 1.\r\tpossibleCars := self availableCars: aCarRent startDate days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalPrice: (self priceFor: possibleCars first days: numDays ).\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:06',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:09:49.073602+02:00' ],		#prior : OmReference [ '154' ],		#self : OmReference [ '155' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalDataWithoutPrice:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalDataWithoutPrice: aCarRent\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars numDays|\r\tnumDays := (aCarRent endDate - aCarRent startDate) asDays + 1.\r\tpossibleCars := self availableCars: aCarRent startDate days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalPrice: (self priceFor: possibleCars first days: numDays ).\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:06',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:10:44.237047+02:00' ],		#prior : OmReference [ '155' ],		#self : OmReference [ '156' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalDataWithoutPrice:discount:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalDataWithoutPrice: aCarRent discount: disc\r\t"Tries to rent the given car type with the rental period and price given in aCarRent."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars numDays|\r\tnumDays := (aCarRent endDate - aCarRent startDate) asDays + 1.\r\tpossibleCars := self availableCars: aCarRent startDate days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalPrice: (self priceFor: possibleCars first days: numDays discount: disc).\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:07',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalDataWithoutPrice:discount:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalDataWithoutPrice: aCarRent discount: disc\r\t"Tries to rent the given car type with the rental period given in aCarRent."\r\t"The price is determined by the car found and the discount"\r\t"Returns true upon success and false otherwise."\r\t| possibleCars numDays|\r\tnumDays := (aCarRent endDate - aCarRent startDate) asDays + 1.\r\tpossibleCars := self availableCars: aCarRent startDate days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalPrice: (self priceFor: possibleCars first days: numDays discount: disc).\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:10',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:10:49.70838+02:00' ],		#prior : OmReference [ '156' ],		#self : OmReference [ '157' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalDataWithoutPrice:discount:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalDataWithoutPrice: aCarRent discount: disc\r\t"Tries to rent the given car type with the rental period given in aCarRent."\r\t"The price is determined by the car found and the discount"\r\t"Returns true upon success and false otherwise."\r\t| possibleCars numDays|\r\tnumDays := (aCarRent endDate - aCarRent startDate) asDays + 1.\r\tpossibleCars := self availableCars: aCarRent startDate days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalPrice: (self priceFor: possibleCars first days: numDays discount: disc).\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:10',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:rentalDataWithoutPrice:discount:',			#protocol : #action-private,			#sourceCode : 'rentType: aType rentalDataWithoutPrice: aCarRent discount: disc\r\t"Tries to rent the given car type with the rental period given in aCarRent."\r\t"The price is determined by the car found and by the discount."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars numDays|\r\tnumDays := (aCarRent endDate - aCarRent startDate) asDays + 1.\r\tpossibleCars := self availableCars: aCarRent startDate days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ \r\t\t\taCarRent totalPrice: (self priceFor: possibleCars first days: numDays discount: disc).\r\t\t\t^ self rent: possibleCars first rentalData: aCarRent ]',			#stamp : 'JN 6/24/2019 12:10',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:15:58.778659+02:00' ],		#prior : OmReference [ '157' ],		#self : OmReference [ '158' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'getRentals:',			#protocol : #accessing,			#sourceCode : 'getRentals: aCar\r\t"Returns all the rentals for a given car"\r\t^ dictRentals at: aCar',			#stamp : 'JN 6/24/2019 12:15',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:16:23.602215+02:00' ],		#prior : OmReference [ '158' ],		#self : OmReference [ '159' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'getRentals:',			#protocol : #accessing,			#sourceCode : 'getRentals: aCar\r\t"Returns all the rentals for a given car"\r\t^ dictRentals at: aCar',			#stamp : 'JN 6/24/2019 12:15',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'getRentals:',			#protocol : #accessing,			#sourceCode : 'getRentals: aCar\r\t"Returns all the rentals for a given car."\r\t^ dictRentals at: aCar',			#stamp : 'JN 6/24/2019 12:16',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:17:07.136439+02:00' ],		#prior : OmReference [ '159' ],		#self : OmReference [ '160' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r\t| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [ :i | carRental addCar: Car panda ].\r\t1 to: 2 do: [ :i | carRental addCar: Car tesla ].\r\t1 to: 1 do: [ :i | carRental addCar: Car golf ].\r\tself assert: carRental availableCars size equals: 6.\r\r\t"Test that checking the available cars work for the case of golf. See also the test \'testCarIsAvailable\'."\r\tdate := Date year: 2019 month: 4 day: 1.\r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself\r\t\tassert: (carRental availableCars: date days: 4 type: #golf) size\r\t\tequals: 1.\r\tself\r\t\tassert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days)\r\t\tequals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself\r\t\tassert: (carRental availableCars: date days: 1 type: #golf) size\r\t\tequals: 0.\r\r\t"Test the Tesla renting with discount"\r\tself\r\t\tassert: (carRental availableCars: date days: 5 type: #tesla) size\r\t\tequals: 2.\r\tself\r\t\tassert: (carRental rentType: #tesla startDate: date endDate: date + 4 days)\r\t\tequals: true',			#stamp : 'JN 6/24/2019 11:53',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla days: 5 startingOn: date) equals: true.\r\t\r\t\r\t',			#stamp : 'JN 6/24/2019 12:17',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:19:19.922078+02:00' ],		#prior : OmReference [ '160' ],		#self : OmReference [ '161' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla days: 5 startingOn: date) equals: true.\r\t\r\t\r\t',			#stamp : 'JN 6/24/2019 12:17',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla days: 5 startingOn: date) equals: true.\r\t\r\t\r\t',			#stamp : 'JN 6/24/2019 12:19',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:19:47.900831+02:00' ],		#prior : OmReference [ '161' ],		#self : OmReference [ '162' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla days: 5 startingOn: date) equals: true.\r\t\r\t\r\t',			#stamp : 'JN 6/24/2019 12:19',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla startDate: date endDate: date + 5 days) equals: true.\r\t\r\t\r\t',			#stamp : 'JN 6/24/2019 12:19',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:20:16.257751+02:00' ],		#prior : OmReference [ '162' ],		#self : OmReference [ '163' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla startDate: date endDate: date + 5 days) equals: true.\r\t\r\t\r\t',			#stamp : 'JN 6/24/2019 12:19',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla startDate: date endDate: date + 5 days discount: 10) equals: true.\r\t\r\t\r\t',			#stamp : 'JN 6/24/2019 12:20',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:23:24.160205+02:00' ],		#prior : OmReference [ '163' ],		#self : OmReference [ '164' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:type:',			#protocol : #'as yet unclassified',			#sourceCode : 'rentedCars: date days: numDays type: aType\r\t"returns the cars that are rented at some point in the requested time period"\r\r\t^ cars\r\t\treject: [ :aCar | (self carIsAvailable: aCar startDate: date endDate: date + (numDays - 1) days) | (aCar type ~= aType) ]',			#stamp : 'JN 6/24/2019 12:23',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:25:25.748188+02:00' ],		#prior : OmReference [ '164' ],		#self : OmReference [ '165' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla startDate: date endDate: date + 5 days discount: 10) equals: true.\r\t\r\t\r\t',			#stamp : 'JN 6/24/2019 12:20',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date cars |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla startDate: date endDate: date + 5 days discount: 10) equals: true.\r\tcars := carRental rentedCars: date days: 1 type: #tesla.\r\tself assert: (cars size) equals: 1.\r\t\r\t',			#stamp : 'JN 6/24/2019 12:25',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:27:26.125007+02:00' ],		#prior : OmReference [ '165' ],		#self : OmReference [ '166' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:type:',			#protocol : #'as yet unclassified',			#sourceCode : 'rentedCars: date days: numDays type: aType\r\t"returns the cars that are rented at some point in the requested time period"\r\r\t^ cars\r\t\treject: [ :aCar | (self carIsAvailable: aCar startDate: date endDate: date + (numDays - 1) days) | (aCar type ~= aType) ]',			#stamp : 'JN 6/24/2019 12:23',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:type:',			#protocol : #accessing,			#sourceCode : 'rentedCars: date days: numDays type: aType\r\t"returns the cars that are rented at some point in the requested time period"\r\r\t^ cars\r\t\treject: [ :aCar | (self carIsAvailable: aCar startDate: date endDate: date + (numDays - 1) days) | (aCar type ~= aType) ]',			#stamp : 'JN 6/24/2019 12:23',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:27:42.293995+02:00' ],		#prior : OmReference [ '166' ],		#self : OmReference [ '167' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:type:',			#protocol : #accessing,			#sourceCode : 'rentedCars: date days: numDays type: aType\r\t"returns the cars that are rented at some point in the requested time period"\r\r\t^ cars\r\t\treject: [ :aCar | (self carIsAvailable: aCar startDate: date endDate: date + (numDays - 1) days) | (aCar type ~= aType) ]',			#stamp : 'JN 6/24/2019 12:23',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:type:',			#protocol : #action,			#sourceCode : 'rentedCars: date days: numDays type: aType\r\t"returns the cars that are rented at some point in the requested time period"\r\r\t^ cars\r\t\treject: [ :aCar | (self carIsAvailable: aCar startDate: date endDate: date + (numDays - 1) days) | (aCar type ~= aType) ]',			#stamp : 'JN 6/24/2019 12:23',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:29:23.826745+02:00' ],		#prior : OmReference [ '167' ],		#self : OmReference [ '168' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date cars |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla startDate: date endDate: date + 5 days discount: 10) equals: true.\r\tcars := carRental rentedCars: date days: 1 type: #tesla.\r\tself assert: (cars size) equals: 1.\r\t\r\t',			#stamp : 'JN 6/24/2019 12:25',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date cars rentals |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla startDate: date endDate: date + 4 days discount: 10) equals: true.\r\tcars := carRental rentedCars: date days: 1 type: #tesla.\r\tself assert: (cars size) equals: 1.\r\trentals = carRental getRentals: cars first.\r\tself assert: (rentals size) equals: 1.\r\tself assert: (rentals first) totalPrice equals: (400 - 10) * 5.\r\t',			#stamp : 'JN 6/24/2019 12:29',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:29:29.620858+02:00' ],		#prior : OmReference [ '168' ],		#self : OmReference [ '169' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date cars rentals |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla startDate: date endDate: date + 4 days discount: 10) equals: true.\r\tcars := carRental rentedCars: date days: 1 type: #tesla.\r\tself assert: (cars size) equals: 1.\r\trentals = carRental getRentals: cars first.\r\tself assert: (rentals size) equals: 1.\r\tself assert: (rentals first) totalPrice equals: (400 - 10) * 5.\r\t',			#stamp : 'JN 6/24/2019 12:29',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date cars rentals |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla startDate: date endDate: date + 4 days discount: 10) equals: true.\r\tcars := carRental rentedCars: date days: 1 type: #tesla.\r\tself assert: (cars size) equals: 1.\r\trentals := carRental getRentals: cars first.\r\tself assert: (rentals size) equals: 1.\r\tself assert: (rentals first) totalPrice equals: (400 - 10) * 5.\r\t',			#stamp : 'JN 6/24/2019 12:29',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:33:35.923238+02:00' ],		#prior : OmReference [ '169' ],		#self : OmReference [ '170' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date cars rentals |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla startDate: date endDate: date + 4 days discount: 10) equals: true.\r\tcars := carRental rentedCars: date days: 1 type: #tesla.\r\tself assert: (cars size) equals: 1.\r\trentals := carRental getRentals: cars first.\r\tself assert: (rentals size) equals: 1.\r\tself assert: (rentals first) totalPrice equals: (400 - 10) * 5.\r\t',			#stamp : 'JN 6/24/2019 12:29',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date cars rentals |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla startDate: date endDate: date + 4 days discount: 10) equals: true.\r\tcars := carRental rentedCars: date days: 1 type: #tesla.\r\tself assert: (cars size) equals: 1.\r\trentals := carRental getRentals: cars first.\r\tself assert: (rentals size) equals: 1.\r\tself assert: (rentals first) totalPrice equals: 400 - 2 * 40 - 5 * 10. "10 % discount from the last two days and the additional 10 euro discount for each day."\r\t',			#stamp : 'JN 6/24/2019 12:33',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:33:49.000855+02:00' ],		#prior : OmReference [ '170' ],		#self : OmReference [ '171' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date cars rentals |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla startDate: date endDate: date + 4 days discount: 10) equals: true.\r\tcars := carRental rentedCars: date days: 1 type: #tesla.\r\tself assert: (cars size) equals: 1.\r\trentals := carRental getRentals: cars first.\r\tself assert: (rentals size) equals: 1.\r\tself assert: (rentals first) totalPrice equals: 400 - 2 * 40 - 5 * 10. "10 % discount from the last two days and the additional 10 euro discount for each day."\r\t',			#stamp : 'JN 6/24/2019 12:33',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date cars rentals |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla startDate: date endDate: date + 4 days discount: 10) equals: true.\r\tcars := carRental rentedCars: date days: 1 type: #tesla.\r\tself assert: (cars size) equals: 1.\r\trentals := carRental getRentals: cars first.\r\tself assert: (rentals size) equals: 1.\r\tself assert: (rentals first) totalPrice equals: 400 - (2 * 40) - (5 * 10). "10 % discount from the last two days and the additional 10 euro discount for each day."\r\t',			#stamp : 'JN 6/24/2019 12:33',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-24T12:34:17.377176+02:00' ],		#prior : OmReference [ '171' ],		#self : OmReference [ '172' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date cars rentals |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla startDate: date endDate: date + 4 days discount: 10) equals: true.\r\tcars := carRental rentedCars: date days: 1 type: #tesla.\r\tself assert: (cars size) equals: 1.\r\trentals := carRental getRentals: cars first.\r\tself assert: (rentals size) equals: 1.\r\tself assert: (rentals first) totalPrice equals: 400 - (2 * 40) - (5 * 10). "10 % discount from the last two days and the additional 10 euro discount for each day."\r\t',			#stamp : 'JN 6/24/2019 12:33',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date cars rentals |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t"Test that the renting and that checking the available cars work."\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\tself assert: (carRental rentType: #golf startDate: date - 5 days endDate: date + 2 days) equals: true.\r\t\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t"Test that the Teslas are available and rent one with a 10 euro discount per day."\r\tself assert: (carRental availableCars: date days: 5 type: #tesla) size equals: 2.\r\tself assert: (carRental rentType: #tesla startDate: date endDate: date + 4 days discount: 10) equals: true.\r\tcars := carRental rentedCars: date days: 1 type: #tesla.\r\tself assert: (cars size) equals: 1.\r\trentals := carRental getRentals: cars first.\r\tself assert: (rentals size) equals: 1.\r\tself assert: (rentals first) totalPrice equals: 5 * 400 - (2 * 40) - (5 * 10). "10 % discount from the last two days and the additional 10 euro discount for each day."\r\t',			#stamp : 'JN 6/24/2019 12:34',			#package : #LifewareHR		}	}}