OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T10:43:17.509648+02:00' ],		#prior : OmReference [ 'Pharo7.0-SNAPSHOT-32bit-9f17218.7raqf0upz9vvde3apnwi2z433', '24' ],		#self : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'Car class'			},			#name : #'price:type:',			#protocol : #'instance creation',			#sourceCode : 'price: aPrice type: aType\r\t^ self new \r\t\tsetPrice: aPrice; \r\t\tsetType: aType',			#stamp : 'JN 6/22/2019 10:43',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T10:43:51.231048+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'Car class'			},			#name : #panda,			#protocol : #'instance creation',			#sourceCode : 'panda\r\t| newCar |\r\tnewCar := self new.\r\tnewCar price: 50; type: \'panda\'.\r\t^ newCar\r\t"^ self price: 50"',			#stamp : 'JN 6/20/2019 12:10',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'Car class'			},			#name : #panda,			#protocol : #'instance creation',			#sourceCode : 'panda\r\t"| newCar |\r\tnewCar := self new.\r\tnewCar price: 50; type: \'panda\'.\r\t^ newCar"\r\t^ self price: 50 type: \'panda\'',			#stamp : 'JN 6/22/2019 10:43',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T10:45:54.254023+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'Car class'			},			#name : #golf,			#protocol : #'instance creation',			#sourceCode : 'golf\r\t| newCar |\r\tnewCar := self new.\r\tnewCar price: 100; type: \'golf\'.\r\t^ newCar\r\t"^ self price: 100"',			#stamp : 'JN 6/20/2019 12:08',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'Car class'			},			#name : #golf,			#protocol : #'instance creation',			#sourceCode : 'golf\r\t^ self price: 100 type: \'golf\'',			#stamp : 'JN 6/22/2019 10:45',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T10:45:58.489091+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'Car class'			},			#name : #panda,			#protocol : #'instance creation',			#sourceCode : 'panda\r\t"| newCar |\r\tnewCar := self new.\r\tnewCar price: 50; type: \'panda\'.\r\t^ newCar"\r\t^ self price: 50 type: \'panda\'',			#stamp : 'JN 6/22/2019 10:43',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'Car class'			},			#name : #panda,			#protocol : #'instance creation',			#sourceCode : 'panda\r\t^ self price: 50 type: \'panda\'',			#stamp : 'JN 6/22/2019 10:45',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T10:46:12.615141+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'Car class'			},			#name : #tesla,			#protocol : #'instance creation',			#sourceCode : 'tesla\r\t| newCar |\r\tnewCar := self new.\r\tnewCar price: 400; type: \'tesla\'.\r\t^ newCar\r\t"^ self price: 400; type: \'tesla\'"',			#stamp : 'JN 6/20/2019 12:06',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'Car class'			},			#name : #tesla,			#protocol : #'instance creation',			#sourceCode : 'tesla\r\t^ self price: 400; type: \'tesla\'',			#stamp : 'JN 6/22/2019 10:46',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T10:46:21.51282+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'Car class'			},			#name : #tesla,			#protocol : #'instance creation',			#sourceCode : 'tesla\r\t^ self price: 400; type: \'tesla\'',			#stamp : 'JN 6/22/2019 10:46',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'Car class'			},			#name : #tesla,			#protocol : #'instance creation',			#sourceCode : 'tesla\r\t^ self price: 400 type: \'tesla\'',			#stamp : 'JN 6/22/2019 10:46',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T10:57:56.981814+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'Car class'			},			#name : #tesla,			#protocol : #'instance creation',			#sourceCode : 'tesla\r\t^ self price: 400 type: \'tesla\'',			#stamp : 'JN 6/22/2019 10:46',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'Car class'			},			#name : #tesla,			#protocol : #'instance creation',			#sourceCode : 'tesla\r\t^ self price: 400 type: #tesla',			#stamp : 'JN 6/22/2019 10:57',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T10:58:01.419838+02:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'Car class'			},			#name : #panda,			#protocol : #'instance creation',			#sourceCode : 'panda\r\t^ self price: 50 type: \'panda\'',			#stamp : 'JN 6/22/2019 10:45',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'Car class'			},			#name : #panda,			#protocol : #'instance creation',			#sourceCode : 'panda\r\t^ self price: 50 type: #panda',			#stamp : 'JN 6/22/2019 10:58',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T10:58:07.266973+02:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'Car class'			},			#name : #golf,			#protocol : #'instance creation',			#sourceCode : 'golf\r\t^ self price: 100 type: \'golf\'',			#stamp : 'JN 6/22/2019 10:48',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'Car class'			},			#name : #golf,			#protocol : #'instance creation',			#sourceCode : 'golf\r\t^ self price: 100 type: #golf',			#stamp : 'JN 6/22/2019 10:58',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T11:45:50.910177+02:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRental\r\tinstanceVariableNames: \'cars numTotalCars\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRental,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #cars,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #numTotalCars,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRental class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRental class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRental				},				#parent : @7,				#content : 'commentStamp: \'LWhr 3/28/2017 14:51\' prior: 0',				#stamp : 'VincentBlondeau 3/25/2019 10:12'			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRental\r\tinstanceVariableNames: \'cars numTotalCars carRentalDates\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRental,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #cars,					#parent : @25				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #numTotalCars,					#parent : @25				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #carRentalDates,					#parent : @25				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRental class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRental class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @25			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRental				},				#parent : @25,				#content : 'commentStamp: \'LWhr 3/28/2017 14:51\' prior: 0',				#stamp : 'VincentBlondeau 3/25/2019 10:12'			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T11:48:23.343933+02:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\tnumTotalCars := 0',			#stamp : 'JN 6/20/2019 12:23',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\tnumTotalCars := 0.\r\t"The dictionary maps a Car to a Sorted collection of Points, each of which contains the starting and ending dates of rental periods as their x and y coordinates, respectively. These rental periods are non-overlapping for each given car."\r\tcarRentalDates = Dictionary new',			#stamp : 'JN 6/22/2019 11:48',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T11:48:30.33454+02:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\tnumTotalCars := 0.\r\t"The dictionary maps a Car to a Sorted collection of Points, each of which contains the starting and ending dates of rental periods as their x and y coordinates, respectively. These rental periods are non-overlapping for each given car."\r\tcarRentalDates = Dictionary new',			#stamp : 'JN 6/22/2019 11:48',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\tnumTotalCars := 0.\r\t"The dictionary maps a Car to a Sorted collection of Points, each of which contains the starting and ending dates of rental periods as their x and y coordinates, respectively. These rental periods are non-overlapping for each given car."\r\tcarRentalDates := Dictionary new',			#stamp : 'JN 6/22/2019 11:48',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T11:50:21.237622+02:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:ForDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date ForDays: numDays\r\t',			#stamp : 'JN 6/22/2019 11:50',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T11:50:24.571499+02:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:ForDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date ForDays: numDays\r\t',			#stamp : 'JN 6/22/2019 11:50',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:ForDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date ForDays: numDays\r\t\t',			#stamp : 'JN 6/22/2019 11:50',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T11:54:07.439401+02:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:ForDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date ForDays: numDays\r\t\t',			#stamp : 'JN 6/22/2019 11:50',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:ForDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date ForDays: numDays\r\tcarRentalDates includesKey: car\r\t\tifFalse: [ ^false ].',			#stamp : 'JN 6/22/2019 11:54',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T11:55:05.983547+02:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:ForDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date ForDays: numDays\r\tcarRentalDates includesKey: car\r\t\tifFalse: [ ^false ].',			#stamp : 'JN 6/22/2019 11:54',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:ForDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date ForDays: numDays\r\t(carRentalDates includesKey: car)\r\t\tifFalse: [ ^false ].',			#stamp : 'JN 6/22/2019 11:55',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T11:57:10.409615+02:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:ForDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date ForDays: numDays\r\t(carRentalDates includesKey: car)\r\t\tifFalse: [ ^false ].',			#stamp : 'JN 6/22/2019 11:55',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:ForDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date ForDays: numDays\r\t| rentalDates |\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).',			#stamp : 'JN 6/22/2019 11:57',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T11:57:12.400629+02:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:ForDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date ForDays: numDays\r\t| rentalDates |\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).',			#stamp : 'JN 6/22/2019 11:57',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:ForDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date ForDays: numDays\r\t| rentalDates |.\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).',			#stamp : 'JN 6/22/2019 11:57',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T11:57:59.99531+02:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:ForDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date ForDays: numDays\r\t| rentalDates |.\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).',			#stamp : 'JN 6/22/2019 11:57',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:ForDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date ForDays: numDays\r\t| rentalDates |\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).',			#stamp : 'JN 6/22/2019 11:57',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T11:58:15.380224+02:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:ForDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date ForDays: numDays\r\t| rentalDates |\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).',			#stamp : 'JN 6/22/2019 11:57',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:ForDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date ForDays: numDays\r\t| rentalDates |\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).\r\t^ true',			#stamp : 'JN 6/22/2019 11:58',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T11:59:06.68606+02:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:forDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date forDays: numDays\r\t| rentalDates |\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).\r\t\r\t^ true',			#stamp : 'JN 6/22/2019 11:59',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:09:56.497729+02:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:forDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date forDays: numDays\r\t| rentalDates |\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).\r\t\r\t^ true',			#stamp : 'JN 6/22/2019 11:59',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:forDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date forDays: numDays\r\t| rentalDates |\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).\r\trentalDates findBinary: (date@date) dp: [ ^false ] ifNone: [ ^true ].\r\t\r\t^ true',			#stamp : 'JN 6/22/2019 12:09',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:11:24.481424+02:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'addCar:',			#protocol : #adding,			#sourceCode : 'addCar: newCar\r\tcars add: newCar',			#stamp : 'JerriNummenpalo 6/19/2019 23:42',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'addCar:',			#protocol : #adding,			#sourceCode : 'addCar: newCar\r\tcars add: newCar.\r\tcarRentalDates at: newCar put: SortedCollection new.\t',			#stamp : 'JN 6/22/2019 12:11',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:11:54.346155+02:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:forDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date forDays: numDays\r\t| rentalDates |\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).\r\trentalDates findBinary: (date@date) dp: [ ^false ] ifNone: [ ^true ].\r\t\r\t^ true',			#stamp : 'JN 6/22/2019 12:09',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:forDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date forDays: numDays\r\t| rentalDates |\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).\r\trentalDates findBinary: (date@date) do: [ ^false ] ifNone: [ ^true ].\r\t\r\t^ true',			#stamp : 'JN 6/22/2019 12:11',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:38:26.119197+02:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:forDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date forDays: numDays\r\t| rentalDates |\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).\r\trentalDates findBinary: (date@date) do: [ ^false ] ifNone: [ ^true ].\r\t\r\t^ true',			#stamp : 'JN 6/22/2019 12:11',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:forDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date forDays: numDays\r\t"Returns true if the requested car can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalDates |\r\t"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).\r\t\r\t"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."\r\trentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] \r\t\tifNone: [:previousRental :nextRental | \r\t\t\t((previousRental ~= nil) & (previousRental y >= date))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t\t((nextRental ~= nil) & (nextRental x < (date + numDays)))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t].\r\t^ true',			#stamp : 'JN 6/22/2019 12:38',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:38:50.804808+02:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:forDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date forDays: numDays\r\t"Returns true if the requested car can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalDates |\r\t"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).\r\t\r\t"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."\r\trentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] \r\t\tifNone: [:previousRental :nextRental | \r\t\t\t((previousRental ~= nil) & (previousRental y >= date))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t\t((nextRental ~= nil) & (nextRental x < (date + numDays)))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t].\r\t^ true',			#stamp : 'JN 6/22/2019 12:38',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:forDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date forDays: numDays\r\t"Returns true if the requested car can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalDates |\r\t"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).\r\t\r\t"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."\r\trentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] \r\t\tifNone: [:previousRental :nextRental | \r\t\t\t((previousRental notNil) & (previousRental y >= date))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t\t((nextRental notNil) & (nextRental x < (date + numDays)))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t].\r\t^ true',			#stamp : 'JN 6/22/2019 12:38',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:43:13.817239+02:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:ForDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date ForDays: numDays\r\t| rentalDates |\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).\r\t^ true',			#stamp : 'JN 6/22/2019 11:58',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:ForDays:',			#protocol : #'as yet unclassified',			#sourceCode : 'isAvailable: car startingOn: date ForDays: numDays\r\t| rentalDates |\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).\r\t^ true',			#stamp : 'JN 6/22/2019 11:58',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:43:13.822213+02:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:ForDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date ForDays: numDays\r\t| rentalDates |\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).\r\t^ true',			#stamp : 'JN 6/22/2019 11:58',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:43:59.943261+02:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: car days: numDays\r\t"Tries to rent the given car for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t| temporary variable names |\r\t(self isAvailable: car startingOn: Date today forDays: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t^true',			#stamp : 'JN 6/22/2019 12:43',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:44:21.319953+02:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: car days: numDays\r\t"Tries to rent the given car for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t| temporary variable names |\r\t(self isAvailable: car startingOn: Date today forDays: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t^true',			#stamp : 'JN 6/22/2019 12:43',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: car days: numDays\r\t"Tries to rent the given car for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: car startingOn: Date today forDays: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t^true',			#stamp : 'JN 6/22/2019 12:44',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:45:46.171669+02:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: car days: numDays\r\t"Tries to rent the given car for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: car startingOn: Date today forDays: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t^true',			#stamp : 'JN 6/22/2019 12:45',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: car days: numDays\r\t"Tries to rent the given car for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: car startingOn: Date today forDays: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t\r\t^true',			#stamp : 'JN 6/22/2019 12:45',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:47:55.930769+02:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: car days: numDays\r\t"Tries to rent the given car for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: car startingOn: Date today forDays: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t\r\t^true',			#stamp : 'JN 6/22/2019 12:45',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: car days: numDays\r\t"Tries to rent the given car for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: car startingOn: Date today forDays: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\tcarRentalDates at: car add: (Date today @ (Date today + numDays - 1)).\r\t^true',			#stamp : 'JN 6/22/2019 12:47',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:49:29.677515+02:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'isAvailable:startingOn:forDays:',		#newSelector : #'isAvailable:startingOn:days:',		#affectedClassName : 'CarRental>>#isAvailable:startingOn:forDays:'	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ],		#time : DateAndTime [ '2019-06-22T12:49:29.689925+02:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date days: numDays\r\t"Returns true if the requested car can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalDates |\r\t"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).\r\t\r\t"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."\r\trentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] \r\t\tifNone: [:previousRental :nextRental | \r\t\t\t((previousRental notNil) & (previousRental y >= date))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t\t((nextRental notNil) & (nextRental x < (date + numDays)))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t].\r\t^ true',			#stamp : 'JN 6/22/2019 12:49',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ],		#time : DateAndTime [ '2019-06-22T12:49:29.697509+02:00' ],		#trigger : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: car days: numDays\r\t"Tries to rent the given car for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: car startingOn: Date today forDays: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\tcarRentalDates at: car add: (Date today @ (Date today + numDays - 1)).\r\t^true',			#stamp : 'JN 6/22/2019 12:47',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: car days: numDays\r\t"Tries to rent the given car for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: car startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\tcarRentalDates at: car add: (Date today @ (Date today + numDays - 1)).\r\t^true',			#stamp : 'JN 6/22/2019 12:49',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ],		#time : DateAndTime [ '2019-06-22T12:49:29.727207+02:00' ],		#trigger : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:forDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date forDays: numDays\r\t"Returns true if the requested car can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalDates |\r\t"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).\r\t\r\t"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."\r\trentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] \r\t\tifNone: [:previousRental :nextRental | \r\t\t\t((previousRental notNil) & (previousRental y >= date))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t\t((nextRental notNil) & (nextRental x < (date + numDays)))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t].\r\t^ true',			#stamp : 'JN 6/22/2019 12:38',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:forDays:',			#protocol : #'as yet unclassified',			#sourceCode : 'isAvailable: car startingOn: date forDays: numDays\r\t"Returns true if the requested car can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalDates |\r\t"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).\r\t\r\t"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."\r\trentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] \r\t\tifNone: [:previousRental :nextRental | \r\t\t\t((previousRental notNil) & (previousRental y >= date))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t\t((nextRental notNil) & (nextRental x < (date + numDays)))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t].\r\t^ true',			#stamp : 'JN 6/22/2019 12:38',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ],		#time : DateAndTime [ '2019-06-22T12:49:29.730476+02:00' ],		#trigger : OmReference [ '33' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:forDays:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date forDays: numDays\r\t"Returns true if the requested car can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalDates |\r\t"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).\r\t\r\t"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."\r\trentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] \r\t\tifNone: [:previousRental :nextRental | \r\t\t\t((previousRental notNil) & (previousRental y >= date))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t\t((nextRental notNil) & (nextRental x < (date + numDays)))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t].\r\t^ true',			#stamp : 'JN 6/22/2019 12:38',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:50:13.784586+02:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: car startingOn: date days: numDays\r\t"Returns true if the requested car can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalDates |\r\t"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."\r\trentalDates := (carRentalDates at: car ifAbsent: [^false]).\r\t\r\t"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."\r\trentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] \r\t\tifNone: [:previousRental :nextRental | \r\t\t\t((previousRental notNil) & (previousRental y >= date))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t\t((nextRental notNil) & (nextRental x < (date + numDays)))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t].\r\t^ true',			#stamp : 'JN 6/22/2019 12:49',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalDates |\r\t"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."\r\trentalDates := (carRentalDates at: aCar ifAbsent: [^false]).\r\t\r\t"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."\r\trentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] \r\t\tifNone: [:previousRental :nextRental | \r\t\t\t((previousRental notNil) & (previousRental y >= date))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t\t((nextRental notNil) & (nextRental x < (date + numDays)))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t].\r\t^ true',			#stamp : 'JN 6/22/2019 12:50',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:50:30.498878+02:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: car days: numDays\r\t"Tries to rent the given car for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: car startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\tcarRentalDates at: car add: (Date today @ (Date today + numDays - 1)).\r\t^true',			#stamp : 'JN 6/22/2019 12:49',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\tcarRentalDates at: aCar add: (Date today @ (Date today + numDays - 1)).\r\t^true',			#stamp : 'JN 6/22/2019 12:50',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:50:51.724617+02:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'priceFor:days:',			#protocol : #action,			#sourceCode : 'priceFor: aCar days: anInteger\r\t| price |\r\t"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"\r\tprice := aCar price * anInteger.\r\t(anInteger > 3)\r\t\tifTrue: [ price := price - (anInteger - 3 * aCar price * 0.1) ].\r\t"Alternatively we could write in one line"\r\t"price := (aCar price * anInteger) -  ((anInteger - 3 max: 0) * aCar price * 0.1)."\r\t^ price',			#stamp : 'JerriNummenpalo 6/19/2019 23:34',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'priceFor:days:',			#protocol : #action,			#sourceCode : 'priceFor: aCar days: numDays\r\t| price |\r\t"Starting from the 4th day, the customer gets a rebate of 10% on the daily rate"\r\tprice := aCar price * numDays.\r\t(numDays > 3)\r\t\tifTrue: [ price := price - (numDays - 3 * aCar price * 0.1) ].\r\t"Alternatively we could write in one line"\r\t"price := (aCar price * numDays) -  ((numDays - 3 max: 0) * aCar price * 0.1)."\r\t^ price',			#stamp : 'JN 6/22/2019 12:50',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:55:55.296418+02:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:days:',			#protocol : #accessing,			#sourceCode : 'availableCars: date days: numDays\r\t^ cars select: [ :aCar | self isAvailable: aCar startingOn: date days: numDays ]',			#stamp : 'JN 6/22/2019 12:55',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:56:08.297119+02:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:days:',			#protocol : #accessing,			#sourceCode : 'availableCars: date days: numDays\r\t^ cars select: [ :aCar | self isAvailable: aCar startingOn: date days: numDays ]',			#stamp : 'JN 6/22/2019 12:55',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:days:',			#protocol : #action,			#sourceCode : 'availableCars: date days: numDays\r\t^ cars select: [ :aCar | self isAvailable: aCar startingOn: date days: numDays ]',			#stamp : 'JN 6/22/2019 12:55',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:56:48.619442+02:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #availableCars,			#protocol : #'as yet unclassified',			#sourceCode : 'availableCars\r\t^ self availableCars: Date today days: 1',			#stamp : 'JN 6/22/2019 12:56',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:57:03.277431+02:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #availableCars,			#protocol : #'as yet unclassified',			#sourceCode : 'availableCars\r\t^ self availableCars: Date today days: 1',			#stamp : 'JN 6/22/2019 12:56',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #availableCars,			#protocol : #action,			#sourceCode : 'availableCars\r\t^ self availableCars: Date today days: 1',			#stamp : 'JN 6/22/2019 12:56',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T12:59:31.103566+02:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:',			#protocol : #action,			#sourceCode : 'rentedCars: date days: numDays\r\t"returns the cars that are rented in the requested time period"\r\t^ cars select: [ :aCar | self isAvailable: aCar startingOn: date days: numDays ].',			#stamp : 'JN 6/22/2019 12:59',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:00:21.318735+02:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #rentedCars,			#protocol : #action,			#sourceCode : 'rentedCars\r\t"Returns all the cars that are rented today"\r\t^ self rentedCars: Date today days: 1',			#stamp : 'JN 6/22/2019 13:00',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:07:39.359753+02:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalDates |\r\t"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."\r\trentalDates := (carRentalDates at: aCar ifAbsent: [^false]).\r\t\r\t"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."\r\trentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] \r\t\tifNone: [:previousRental :nextRental | \r\t\t\t((previousRental notNil) & (previousRental y >= date))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t\t((nextRental notNil) & (nextRental x < (date + numDays)))\r\t\t\t\tifTrue: [ ^ false ].\r\t\t].\r\t^ true',			#stamp : 'JN 6/22/2019 12:50',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalDates |\r\t"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."\r\trentalDates := (carRentalDates at: aCar ifAbsent: [^false]).\r\t\r\t"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."\r\trentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] \r\t\tifNone: [:previousRental :nextRental | \r\t\t\tpreviousRental ifNotNil: [ (previousRental y >= date) ifTrue: [^ false]].\r\t\t\tnextRental ifNotNil: [ (nextRental x < (date + numDays)) ifTrue: [^ false] ].\r\t\t].\r\t^ true',			#stamp : 'JN 6/22/2019 13:07',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:10:30.547089+02:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\tcarRentalDates at: aCar add: (Date today @ (Date today + numDays - 1)).\r\t^true',			#stamp : 'JN 6/22/2019 12:50',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\tcarRentalDates at: aCar add: (Date today @ (Date today + numDays days - 1 day)).\r\t^true',			#stamp : 'JN 6/22/2019 13:10',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:11:37.053949+02:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testFixedNumberOfCars,			#protocol : #'as yet unclassified',			#sourceCode : 'testFixedNumberOfCars\r\t"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"\r\r\t| carRental |\r\tcarRental := CarRental new.\r\tcarRental\r\t\taddCar: Car panda;\r\t\taddCar: Car panda;\r\t\taddCar: Car tesla.\r\t\r\tself assert: carRental totalCars size equals: 3',			#stamp : 'JN 6/22/2019 10:46',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testFixedNumberOfCars,			#protocol : #'2 exercise',			#sourceCode : 'testFixedNumberOfCars\r\t"Our car rental has now a fixed number of cars. Extend the code to make this test green: define the missing (red) methods in the class CarRental"\r\r\t| carRental |\r\tcarRental := CarRental new.\r\tcarRental\r\t\taddCar: Car panda;\r\t\taddCar: Car panda;\r\t\taddCar: Car tesla.\r\t\r\tself assert: carRental totalCars size equals: 3',			#stamp : 'JN 6/22/2019 10:46',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:16:17.837257+02:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCustom,			#protocol : #'0 examples',			#sourceCode : 'testCustom\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tself assert: true.',			#stamp : 'JN 6/22/2019 13:16',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:25:38.364282+02:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRenting,			#protocol : #'3 exercise',			#sourceCode : 'testRenting\r\t"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"\r\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tself assert: carRental availableCars size equals: 3.\r\tcarRental rent: redPanda days: 5.\r\tself assert: carRental availableCars size equals: 2.\r\tself assert: carRental rentedCars size equals: 1',			#stamp : 'VincentBlondeau 3/22/2019 14:43',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRenting,			#protocol : #'3 exercise',			#sourceCode : 'testRenting\r\t"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"\r\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tself assert: (carRental availableCars size) equals: 3.\r\tcarRental rent: redPanda days: 5.\r\tself assert: carRental availableCars size equals: 2.\r\tself assert: carRental rentedCars size equals: 1',			#stamp : 'JN 6/22/2019 13:25',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:25:51.843016+02:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRenting,			#protocol : #'3 exercise',			#sourceCode : 'testRenting\r\t"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"\r\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tself assert: (carRental availableCars size) equals: 3.\r\tcarRental rent: redPanda days: 5.\r\tself assert: carRental availableCars size equals: 2.\r\tself assert: carRental rentedCars size equals: 1',			#stamp : 'JN 6/22/2019 13:25',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRenting,			#protocol : #'3 exercise',			#sourceCode : 'testRenting\r\t"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"\r\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tself assert: (carRental availableCars size) equals: 3.\r\tcarRental rent: redPanda days: 5.\r\tself assert: (carRental availableCars size) equals: 2.\r\tself assert: (carRental rentedCars size) equals: 1',			#stamp : 'JN 6/22/2019 13:25',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:26:24.654001+02:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCustom,			#protocol : #'0 examples',			#sourceCode : 'testCustom\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tself assert: true.',			#stamp : 'JN 6/22/2019 13:16',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCustom,			#protocol : #'0 examples',			#sourceCode : 'testCustom\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tself assert: (carRental availableCars size) equals: 3.\r\tself assert: true.',			#stamp : 'JN 6/22/2019 13:26',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:26:43.766849+02:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRenting,			#protocol : #'3 exercise',			#sourceCode : 'testRenting\r\t"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"\r\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tself assert: (carRental availableCars size) equals: 3.\r\tcarRental rent: redPanda days: 5.\r\tself assert: (carRental availableCars size) equals: 2.\r\tself assert: (carRental rentedCars size) equals: 1',			#stamp : 'JN 6/22/2019 13:25',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRenting,			#protocol : #'3 exercise',			#sourceCode : 'testRenting\r\t"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"\r\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tself assert: (carRental availableCars size) equals: 3.\r\t"carRental rent: redPanda days: 5.\r\tself assert: (carRental availableCars size) equals: 2.\r\tself assert: (carRental rentedCars size) equals: 1"',			#stamp : 'JN 6/22/2019 13:26',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:26:55.925149+02:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRenting,			#protocol : #'3 exercise',			#sourceCode : 'testRenting\r\t"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"\r\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tself assert: (carRental availableCars size) equals: 3.\r\t"carRental rent: redPanda days: 5.\r\tself assert: (carRental availableCars size) equals: 2.\r\tself assert: (carRental rentedCars size) equals: 1"',			#stamp : 'JN 6/22/2019 13:26',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRenting,			#protocol : #'3 exercise',			#sourceCode : 'testRenting\r\t"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"\r\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tself assert: (carRental availableCars size) equals: 3.\r\tcarRental rent: redPanda days: 5.\r\t"self assert: (carRental availableCars size) equals: 2.\r\tself assert: (carRental rentedCars size) equals: 1"',			#stamp : 'JN 6/22/2019 13:26',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:27:08.47095+02:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRenting,			#protocol : #'3 exercise',			#sourceCode : 'testRenting\r\t"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"\r\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tself assert: (carRental availableCars size) equals: 3.\r\tcarRental rent: redPanda days: 5.\r\t"self assert: (carRental availableCars size) equals: 2.\r\tself assert: (carRental rentedCars size) equals: 1"',			#stamp : 'JN 6/22/2019 13:26',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRenting,			#protocol : #'3 exercise',			#sourceCode : 'testRenting\r\t"The same car cannot be rented twice. Extend the code to make this test green: define the missing (red) methods in the class CarRental"\r\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tself assert: (carRental availableCars size) equals: 3.\r\tcarRental rent: redPanda days: 5.\r\tself assert: (carRental availableCars size) equals: 2.\r\tself assert: (carRental rentedCars size) equals: 1',			#stamp : 'JN 6/22/2019 13:27',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:37:41.255692+02:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\tcarRentalDates at: aCar add: (Date today @ (Date today + numDays days - 1 day)).\r\t^true',			#stamp : 'JN 6/22/2019 13:10',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(carRentalDates at: aCar) add: {Date today . (Date today + numDays days - 1 day)}.\r\t^true',			#stamp : 'JN 6/22/2019 13:37',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:38:11.470394+02:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalDates |\r\t"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."\r\trentalDates := (carRentalDates at: aCar ifAbsent: [^false]).\r\t\r\t"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."\r\trentalDates findBinary: [ :arg | ((arg x) - date) asDays ] do: [ ^false ] \r\t\tifNone: [:previousRental :nextRental | \r\t\t\tpreviousRental ifNotNil: [ (previousRental y >= date) ifTrue: [^ false]].\r\t\t\tnextRental ifNotNil: [ (nextRental x < (date + numDays)) ifTrue: [^ false] ].\r\t\t].\r\t^ true',			#stamp : 'JN 6/22/2019 13:07',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalDates |\r\t"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."\r\trentalDates := (carRentalDates at: aCar ifAbsent: [^false]).\r\t\r\t"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."\r\trentalDates findBinary: [ :arg | ((arg first) - date) asDays ] do: [ ^false ] \r\t\tifNone: [:previousRental :nextRental | \r\t\t\tpreviousRental ifNotNil: [ (previousRental y >= date) ifTrue: [^ false]].\r\t\t\tnextRental ifNotNil: [ (nextRental x < (date + numDays)) ifTrue: [^ false] ].\r\t\t].\r\t^ true',			#stamp : 'JN 6/22/2019 13:38',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:39:18.84392+02:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalDates |\r\t"Variable rentalDates is a SortedSequence of Points that contain date pairs (start and end date of a rental)."\r\trentalDates := (carRentalDates at: aCar ifAbsent: [^false]).\r\t\r\t"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."\r\trentalDates findBinary: [ :arg | ((arg first) - date) asDays ] do: [ ^false ] \r\t\tifNone: [:previousRental :nextRental | \r\t\t\tpreviousRental ifNotNil: [ (previousRental y >= date) ifTrue: [^ false]].\r\t\t\tnextRental ifNotNil: [ (nextRental x < (date + numDays)) ifTrue: [^ false] ].\r\t\t].\r\t^ true',			#stamp : 'JN 6/22/2019 13:38',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalDates |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalDates := (carRentalDates at: aCar ifAbsent: [^false]).\r\t\r\t"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."\r\trentalDates findBinary: [ :arg | ((arg first) - date) asDays ] do: [ ^false ] \r\t\tifNone: [:previousRental :nextRental | \r\t\t\tpreviousRental ifNotNil: [ (previousRental last >= date) ifTrue: [^ false]].\r\t\t\tnextRental ifNotNil: [ (nextRental first < (date + numDays)) ifTrue: [^ false] ].\r\t\t].\r\t^ true',			#stamp : 'JN 6/22/2019 13:39',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:39:40.059945+02:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(carRentalDates at: aCar) add: {Date today . (Date today + numDays days - 1 day)}.\r\t^true',			#stamp : 'JN 6/22/2019 13:37',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\tcarRentalDates at: aCar add: {Date today . (Date today + numDays days - 1 day)}.\r\t^true',			#stamp : 'JN 6/22/2019 13:39',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:45:57.678792+02:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRental\r\tinstanceVariableNames: \'cars numTotalCars carRentalDates\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRental,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #cars,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #numTotalCars,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #carRentalDates,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRental class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRental class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRental				},				#parent : @7,				#content : 'commentStamp: \'LWhr 3/28/2017 14:51\' prior: 0',				#stamp : 'VincentBlondeau 3/25/2019 10:12'			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRental\r\tinstanceVariableNames: \'cars numTotalCars carRentalStartingDates carRentalEndingDates\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRental,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #cars,					#parent : @27				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #numTotalCars,					#parent : @27				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #carRentalStartingDates,					#parent : @27				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #carRentalEndingDates,					#parent : @27				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRental class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRental class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @27			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRental				},				#parent : @27,				#content : 'commentStamp: \'LWhr 3/28/2017 14:51\' prior: 0',				#stamp : 'VincentBlondeau 3/25/2019 10:12'			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:46:23.24978+02:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\tnumTotalCars := 0.\r\t"The dictionary maps a Car to a Sorted collection of Points, each of which contains the starting and ending dates of rental periods as their x and y coordinates, respectively. These rental periods are non-overlapping for each given car."\r\tcarRentalDates := Dictionary new',			#stamp : 'JN 6/22/2019 11:48',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\tnumTotalCars := 0.\r\t"The dictionary maps a Car to a Sorted collection of Points, each of which contains the starting and ending dates of rental periods as their x and y coordinates, respectively. These rental periods are non-overlapping for each given car."\r\tcarRentalStartingDates := Dictionary new',			#stamp : 'JN 6/22/2019 13:46',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:46:40.153663+02:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\tnumTotalCars := 0.\r\t"The dictionary maps a Car to a Sorted collection of Points, each of which contains the starting and ending dates of rental periods as their x and y coordinates, respectively. These rental periods are non-overlapping for each given car."\r\tcarRentalStartingDates := Dictionary new',			#stamp : 'JN 6/22/2019 13:46',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\tnumTotalCars := 0.\r\t"The dictionary maps a Car to a Sorted collection of Points, each of which contains the starting and ending dates of rental periods as their x and y coordinates, respectively. These rental periods are non-overlapping for each given car."\r\tcarRentalStartingDates := Dictionary new.\r\tcarRentalEndingDates := Dictionary new',			#stamp : 'JN 6/22/2019 13:46',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:47:40.204013+02:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\tnumTotalCars := 0.\r\t"The dictionary maps a Car to a Sorted collection of Points, each of which contains the starting and ending dates of rental periods as their x and y coordinates, respectively. These rental periods are non-overlapping for each given car."\r\tcarRentalStartingDates := Dictionary new.\r\tcarRentalEndingDates := Dictionary new',			#stamp : 'JN 6/22/2019 13:46',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\tnumTotalCars := 0.\r\t"The dictionaries maps a Car to a Sorted collection of Dates, which contain the starting dates and ending dates of rentals. The resulting intervals of rentals periods are non-overlapping."\r\tcarRentalStartingDates := Dictionary new.\r\tcarRentalEndingDates := Dictionary new',			#stamp : 'JN 6/22/2019 13:47',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:48:51.131436+02:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\tnumTotalCars := 0.\r\t"The dictionaries maps a Car to a Sorted collection of Dates, which contain the starting dates and ending dates of rentals. The resulting intervals of rentals periods are non-overlapping."\r\tcarRentalStartingDates := Dictionary new.\r\tcarRentalEndingDates := Dictionary new',			#stamp : 'JN 6/22/2019 13:47',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\tnumTotalCars := 0.\r\t"The dictionaries maps a Car to a Sorted collection of Dates, which contain the starting dates and ending dates of rentals. For a given car the i\'th entry for a given car gives the start and end date of a rental period. The resulting intervals of rentals periods are non-overlapping."\r\tcarRentalStartingDates := Dictionary new.\r\tcarRentalEndingDates := Dictionary new',			#stamp : 'JN 6/22/2019 13:48',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:49:08.166582+02:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'addCar:',			#protocol : #adding,			#sourceCode : 'addCar: newCar\r\tcars add: newCar.\r\tcarRentalDates at: newCar put: SortedCollection new.\t',			#stamp : 'JN 6/22/2019 12:11',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'addCar:',			#protocol : #adding,			#sourceCode : 'addCar: newCar\r\tcars add: newCar.\r\tcarRentalStartingDates at: newCar put: SortedCollection new.\t',			#stamp : 'JN 6/22/2019 13:49',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:49:17.136856+02:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'addCar:',			#protocol : #adding,			#sourceCode : 'addCar: newCar\r\tcars add: newCar.\r\tcarRentalStartingDates at: newCar put: SortedCollection new.\t',			#stamp : 'JN 6/22/2019 13:49',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'addCar:',			#protocol : #adding,			#sourceCode : 'addCar: newCar\r\tcars add: newCar.\r\tcarRentalStartingDates at: newCar put: SortedCollection new.\r\tcarRentalEndingDates at: newCar put: SortedCollection new.\t',			#stamp : 'JN 6/22/2019 13:49',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:49:26.4289+02:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\tcarRentalDates at: aCar add: {Date today . (Date today + numDays days - 1 day)}.\r\t^true',			#stamp : 'JN 6/22/2019 13:39',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\tcarRentalStartingDates at: aCar add: {Date today . (Date today + numDays days - 1 day)}.\r\t^true',			#stamp : 'JN 6/22/2019 13:49',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:49:51.430486+02:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\tcarRentalStartingDates at: aCar add: {Date today . (Date today + numDays days - 1 day)}.\r\t^true',			#stamp : 'JN 6/22/2019 13:49',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\tcarRentalStartingDates at: aCar add: Date today.\r\tcarRentalStartingDates at: aCar add: Date today + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 13:49',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:49:57.934051+02:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\tcarRentalStartingDates at: aCar add: Date today.\r\tcarRentalStartingDates at: aCar add: Date today + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 13:49',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\tcarRentalStartingDates at: aCar add: Date today.\r\tcarRentalEndingDates at: aCar add: Date today + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 13:49',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:50:27.285993+02:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalDates |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalDates := (carRentalDates at: aCar ifAbsent: [^false]).\r\t\r\t"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."\r\trentalDates findBinary: [ :arg | ((arg first) - date) asDays ] do: [ ^false ] \r\t\tifNone: [:previousRental :nextRental | \r\t\t\tpreviousRental ifNotNil: [ (previousRental last >= date) ifTrue: [^ false]].\r\t\t\tnextRental ifNotNil: [ (nextRental first < (date + numDays)) ifTrue: [^ false] ].\r\t\t].\r\t^ true',			#stamp : 'JN 6/22/2019 13:39',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalDates |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalDates := (carRentalStartingDates at: aCar ifAbsent: [^false]).\r\t\r\t"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."\r\trentalDates findBinary: [ :arg | ((arg first) - date) asDays ] do: [ ^false ] \r\t\tifNone: [:previousRental :nextRental | \r\t\t\tpreviousRental ifNotNil: [ (previousRental last >= date) ifTrue: [^ false]].\r\t\t\tnextRental ifNotNil: [ (nextRental first < (date + numDays)) ifTrue: [^ false] ].\r\t\t].\r\t^ true',			#stamp : 'JN 6/22/2019 13:50',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:56:43.598641+02:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRental\r\tinstanceVariableNames: \'cars numTotalCars carRentalStartingDates carRentalEndingDates\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRental,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #cars,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #numTotalCars,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #carRentalStartingDates,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #carRentalEndingDates,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRental class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRental class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRental				},				#parent : @7,				#content : 'commentStamp: \'LWhr 3/28/2017 14:51\' prior: 0',				#stamp : 'VincentBlondeau 3/25/2019 10:12'			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRental\r\tinstanceVariableNames: \'cars numTotalCars carRentalStartingDates dictRentalEndingDates\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRental,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #cars,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #numTotalCars,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #carRentalStartingDates,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #dictRentalEndingDates,					#parent : @29				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRental class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRental class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @29			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRental				},				#parent : @29,				#content : 'commentStamp: \'LWhr 3/28/2017 14:51\' prior: 0',				#stamp : 'VincentBlondeau 3/25/2019 10:12'			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:57:10.23315+02:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRental\r\tinstanceVariableNames: \'cars numTotalCars carRentalStartingDates dictRentalEndingDates\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRental,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #cars,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #numTotalCars,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #carRentalStartingDates,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #dictRentalEndingDates,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRental class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRental class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRental				},				#parent : @7,				#content : 'commentStamp: \'LWhr 3/28/2017 14:51\' prior: 0',				#stamp : 'VincentBlondeau 3/25/2019 10:12'			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #CarRental\r\tinstanceVariableNames: \'cars numTotalCars dictRentalStartingDates dictRentalEndingDates\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LifewareHR-Core\''			},			#name : #CarRental,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #cars,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #numTotalCars,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #dictRentalStartingDates,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #CarRental					},					#name : #dictRentalEndingDates,					#parent : @29				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'CarRental class\r\tinstanceVariableNames: \'\''				},				#name : #'CarRental class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @29			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #CarRental				},				#parent : @29,				#content : 'commentStamp: \'LWhr 3/28/2017 14:51\' prior: 0',				#stamp : 'VincentBlondeau 3/25/2019 10:12'			},			#classVariables : OrderedCollection [ ],			#category : #LifewareHR-Core,			#package : #LifewareHR,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:57:18.521677+02:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'addCar:',			#protocol : #adding,			#sourceCode : 'addCar: newCar\r\tcars add: newCar.\r\tcarRentalStartingDates at: newCar put: SortedCollection new.\r\tcarRentalEndingDates at: newCar put: SortedCollection new.\t',			#stamp : 'JN 6/22/2019 13:49',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'addCar:',			#protocol : #adding,			#sourceCode : 'addCar: newCar\r\tcars add: newCar.\r\tdictRentalStartingDates at: newCar put: SortedCollection new.\r\tdictRentalEndingDates at: newCar put: SortedCollection new.\t',			#stamp : 'JN 6/22/2019 13:57',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T13:57:48.946023+02:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\tcarRentalStartingDates at: aCar add: Date today.\r\tcarRentalEndingDates at: aCar add: Date today + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 13:49',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\tdictRentalStartingDates at: aCar add: Date today.\r\tdictRentalEndingDates at: aCar add: Date today + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 13:57',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T14:12:19.363842+02:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalDates |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalDates := (carRentalStartingDates at: aCar ifAbsent: [^false]).\r\t\r\t"Find the rental dates (if any) with the closest dates to the requested date and check if they are in a conflict with the requested rental period."\r\trentalDates findBinary: [ :arg | ((arg first) - date) asDays ] do: [ ^false ] \r\t\tifNone: [:previousRental :nextRental | \r\t\t\tpreviousRental ifNotNil: [ (previousRental last >= date) ifTrue: [^ false]].\r\t\t\tnextRental ifNotNil: [ (nextRental first < (date + numDays)) ifTrue: [^ false] ].\r\t\t].\r\t^ true',			#stamp : 'JN 6/22/2019 13:50',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\t\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] \r\t\tifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] \r\t\tifNone: [:prev :next | prev].\r\t^ true',			#stamp : 'JN 6/22/2019 14:12',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T14:14:57.750283+02:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\t\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] \r\t\tifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] \r\t\tifNone: [:prev :next | prev].\r\t^ true',			#stamp : 'JN 6/22/2019 14:12',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\t\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] \r\t\tifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] \r\t\tifNone: [:prev :next | next].\r\tidxPrevRentalDate ifNil: [ ^true ].\r\tidxNextRentalDate ifNil: [ ^true ].\r\t^ (idxNextRentalDate - idxPrevRentalDate == 1)',			#stamp : 'JN 6/22/2019 14:14',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T14:15:11.784271+02:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\tnumTotalCars := 0.\r\t"The dictionaries maps a Car to a Sorted collection of Dates, which contain the starting dates and ending dates of rentals. For a given car the i\'th entry for a given car gives the start and end date of a rental period. The resulting intervals of rentals periods are non-overlapping."\r\tcarRentalStartingDates := Dictionary new.\r\tcarRentalEndingDates := Dictionary new',			#stamp : 'JN 6/22/2019 13:48',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcars := OrderedCollection new.\r\tnumTotalCars := 0.\r\t"The dictionaries maps a Car to a Sorted collection of Dates, which contain the starting dates and ending dates of rentals. For a given car the i\'th entry for a given car gives the start and end date of a rental period. The resulting intervals of rentals periods are non-overlapping."\r\tdictRentalStartingDates := Dictionary new.\r\tdictRentalEndingDates := Dictionary new',			#stamp : 'JN 6/22/2019 14:15',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T14:18:27.288721+02:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\t\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] \r\t\tifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] \r\t\tifNone: [:prev :next | next].\r\tidxPrevRentalDate ifNil: [ ^true ].\r\tidxNextRentalDate ifNil: [ ^true ].\r\t^ (idxNextRentalDate - idxPrevRentalDate == 1)',			#stamp : 'JN 6/22/2019 14:14',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] \r\t\tifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] \r\t\tifNone: [:prev :next | next].\r\tidxPrevRentalDate ifNil: [ ^true ].\r\tidxNextRentalDate ifNil: [ ^true ].\r\t^ (idxNextRentalDate - idxPrevRentalDate == 1)',			#stamp : 'JN 6/22/2019 14:18',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T14:19:00.456607+02:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\tdictRentalStartingDates at: aCar add: Date today.\r\tdictRentalEndingDates at: aCar add: Date today + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 13:57',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: Date today.\r\t(dictRentalEndingDates at: aCar) add: Date today + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 14:19',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T14:22:00.412319+02:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'ManifestLifewareHR class'			},			#name : #ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive\r\t^ #()',			#stamp : 'JN 6/22/2019 14:22',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T14:22:00.417902+02:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'ManifestLifewareHR class'			},			#name : #ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive\r\t^ #()',			#stamp : 'JN 6/22/2019 14:22',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'ManifestLifewareHR class'			},			#name : #ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #\'2019-06-22T14:22:00.415583+02:00\') )',			#stamp : 'JN 6/22/2019 14:22',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T14:24:20.460946+02:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] \r\t\tifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] \r\t\tifNone: [:prev :next | next].\r\tidxPrevRentalDate ifNil: [ ^true ].\r\tidxNextRentalDate ifNil: [ ^true ].\r\t^ (idxNextRentalDate - idxPrevRentalDate == 1)',			#stamp : 'JN 6/22/2019 14:18',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | next].\r\tidxPrevRentalDate ifNil: [ ^true ].\r\tidxNextRentalDate ifNil: [ ^true ].\r\t^ (idxNextRentalDate - idxPrevRentalDate == 1)',			#stamp : 'JN 6/22/2019 14:24',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T14:29:00.177115+02:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | next].\r\tidxPrevRentalDate ifNil: [ ^true ].\r\tidxNextRentalDate ifNil: [ ^true ].\r\t^ (idxNextRentalDate - idxPrevRentalDate == 1)',			#stamp : 'JN 6/22/2019 14:24',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | next].\r\tidxPrevRentalDate == 0 ifTrue: [ ^true ].\r\tidxNextRentalDate == 0 ifTrue: [ ^true ].\r\t^ (idxNextRentalDate - idxPrevRentalDate == 1)',			#stamp : 'JN 6/22/2019 14:29',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T14:29:13.150246+02:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == nil or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == nil or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == nil or idxNextRentalDate == nil or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | next].\r\tidxPrevRentalDate == 0 ifTrue: [ ^true ].\r\tidxNextRentalDate == 0 ifTrue: [ ^true ].\r\t^ (idxNextRentalDate - idxPrevRentalDate == 1)',			#stamp : 'JN 6/22/2019 14:29',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | next].\r\tidxPrevRentalDate == 0 ifTrue: [ ^true ].\r\tidxNextRentalDate == 0 ifTrue: [ ^true ].\r\t^ (idxNextRentalDate - idxPrevRentalDate == 1)',			#stamp : 'JN 6/22/2019 14:29',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T14:33:03.37303+02:00' ],		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (arg - date) asDays ] do: [ ^false ] ifNone: [:prev :next | next].\r\tidxPrevRentalDate == 0 ifTrue: [ ^true ].\r\tidxNextRentalDate == 0 ifTrue: [ ^true ].\r\t^ (idxNextRentalDate - idxPrevRentalDate == 1)',			#stamp : 'JN 6/22/2019 14:29',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [ ^false ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [ ^false ] ifNone: [:prev :next | next].\r\tidxPrevRentalDate == 0 ifTrue: [ ^true ].\r\tidxNextRentalDate == 0 ifTrue: [ ^true ].\r\t^ (idxNextRentalDate - idxPrevRentalDate == 1)',			#stamp : 'JN 6/22/2019 14:33',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T14:37:26.5659+02:00' ],		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [ ^false ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [ ^false ] ifNone: [:prev :next | next].\r\tidxPrevRentalDate == 0 ifTrue: [ ^true ].\r\tidxNextRentalDate == 0 ifTrue: [ ^true ].\r\t^ (idxNextRentalDate - idxPrevRentalDate == 1)',			#stamp : 'JN 6/22/2019 14:33',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t(idxPrevRentalDate == 0 | ((rentalEndingDates at: idxPrevRentalDate ) < date)) ifFalse: [ ^false ].\r\t(idxNextRentalDate == 0 | ((rentalStartingDates at: idxNextRentalDate ) < date)) ifFalse: [ ^false ].\r\t^ (idxNextRentalDate - idxPrevRentalDate == 1)',			#stamp : 'JN 6/22/2019 14:37',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T14:48:03.747338+02:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t(idxPrevRentalDate == 0 | ((rentalEndingDates at: idxPrevRentalDate ) < date)) ifFalse: [ ^false ].\r\t(idxNextRentalDate == 0 | ((rentalStartingDates at: idxNextRentalDate ) < date)) ifFalse: [ ^false ].\r\t^ (idxNextRentalDate - idxPrevRentalDate == 1)',			#stamp : 'JN 6/22/2019 14:37',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tidxPrevRentalDate isZero ifFalse: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\tidxNextRentalDate isZero ifFalse: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].\r\tidxPrevRentalDate isZero ifFalse: [ idxNextRentalDate isZero ifFalse: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 14:48',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T14:48:11.771215+02:00' ],		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [^false]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [^false]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tidxPrevRentalDate isZero ifFalse: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\tidxNextRentalDate isZero ifFalse: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].\r\tidxPrevRentalDate isZero ifFalse: [ idxNextRentalDate isZero ifFalse: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 14:48',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tidxPrevRentalDate isZero ifFalse: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\tidxNextRentalDate isZero ifFalse: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].\r\tidxPrevRentalDate isZero ifFalse: [ idxNextRentalDate isZero ifFalse: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 14:48',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T15:01:57.130215+02:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate |\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate == 0 or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate == 0 or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate == 0 or idxNextRentalDate == 0 or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tidxPrevRentalDate isZero ifFalse: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\tidxNextRentalDate isZero ifFalse: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].\r\tidxPrevRentalDate isZero ifFalse: [ idxNextRentalDate isZero ifFalse: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 14:48',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | idx > 0 & idx < rentalEndingDates size ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 15:01',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T15:04:47.526407+02:00' ],		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | idx > 0 & idx < rentalEndingDates size ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 15:01',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx < rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 15:04',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T15:09:08.368371+02:00' ],		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|\r\t"Variable rentalDates is a SortedSequence of arrays of size 2 that contain date pairs (start and end date of a rental)."\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx < rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 15:04',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx < rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 15:09',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T15:13:18.798929+02:00' ],		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCustom,			#protocol : #'0 examples',			#sourceCode : 'testCustom\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tself assert: (carRental availableCars size) equals: 3.\r\tself assert: true.',			#stamp : 'JN 6/22/2019 13:26',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCustom,			#protocol : #'0 examples',			#sourceCode : 'testCustom\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tcarRental availableCars size.\r\tcarRental rent: redPanda days: 5.\r\tself assert: (carRental availableCars size) equals: 2.\r\tself assert: (carRental rentedCars size) equals: 1\r',			#stamp : 'JN 6/22/2019 15:13',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T15:14:23.233954+02:00' ],		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCustom,			#protocol : #'0 examples',			#sourceCode : 'testCustom\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tcarRental availableCars size.\r\tcarRental rent: redPanda days: 5.\r\tself assert: (carRental availableCars size) equals: 2.\r\tself assert: (carRental rentedCars size) equals: 1\r',			#stamp : 'JN 6/22/2019 15:13',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCustom,			#protocol : #'0 examples',			#sourceCode : 'testCustom\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tcarRental availableCars. \r\tcarRental rent: redPanda days: 5.\r\tcarRental availableCars.\r\tself assert: (carRental rentedCars size) equals: 1\r',			#stamp : 'JN 6/22/2019 15:14',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T15:23:04.650844+02:00' ],		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx < rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 15:09',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 15:23',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T15:24:19.823071+02:00' ],		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCustom,			#protocol : #'0 examples',			#sourceCode : 'testCustom\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tcarRental availableCars. \r\tcarRental rent: redPanda days: 5.\r\tcarRental availableCars.\r\tself assert: (carRental rentedCars size) equals: 1\r',			#stamp : 'JN 6/22/2019 15:14',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCustom,			#protocol : #'0 examples',			#sourceCode : 'testCustom\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tcarRental availableCars. \r\tcarRental rent: redPanda days: 5.\r\tcarRental availableCars.\r\t"self assert: (carRental rentedCars size) equals: 1"\r',			#stamp : 'JN 6/22/2019 15:24',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T15:25:43.272443+02:00' ],		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > date + numDays days - 1 day) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 15:23',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > (date + numDays days - 1 day)) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 15:25',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T15:27:22.87056+02:00' ],		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:',			#protocol : #action,			#sourceCode : 'rentedCars: date days: numDays\r\t"returns the cars that are rented in the requested time period"\r\t^ cars select: [ :aCar | self isAvailable: aCar startingOn: date days: numDays ].',			#stamp : 'JN 6/22/2019 12:59',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:',			#protocol : #action,			#sourceCode : 'rentedCars: date days: numDays\r\t"returns the cars that are rented at some point in the requested time period"\r\t^ cars select: [ :aCar | (self isAvailable: aCar startingOn: date days: numDays) not ].',			#stamp : 'JN 6/22/2019 15:27',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T15:27:30.224548+02:00' ],		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ],		#time : DateAndTime [ '2019-06-22T15:27:30.235037+02:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:',			#protocol : #action,			#sourceCode : 'rentedCars: date days: numDays\r\t"returns the cars that are rented at some point in the requested time period"\r\t^ cars select: [ :aCar | (self isAvailable: aCar startingOn: date days: numDays) not ].',			#stamp : 'JN 6/22/2019 15:27',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:',			#protocol : #action,			#sourceCode : 'rentedCars: date days: numDays\r\t"returns the cars that are rented at some point in the requested time period"\r\r\t^ cars\r\t\treject: [ :aCar | self isAvailable: aCar startingOn: date days: numDays ]',			#stamp : 'JN 6/22/2019 15:27',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T15:27:40.855205+02:00' ],		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:',			#protocol : #action,			#sourceCode : 'rentedCars: date days: numDays\r\t"returns the cars that are rented at some point in the requested time period"\r\r\t^ cars\r\t\treject: [ :aCar | self isAvailable: aCar startingOn: date days: numDays ]',			#stamp : 'JN 6/22/2019 15:27',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:',			#protocol : #action,			#sourceCode : 'rentedCars: date days: numDays\r\t"returns the cars that are rented at some point in the requested time period"\r\r\t^ cars reject: [ :aCar | self isAvailable: aCar startingOn: date days: numDays ]',			#stamp : 'JN 6/22/2019 15:27',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T15:44:50.178823+02:00' ],		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r\tself error. "remove this"',			#stamp : 'JN 6/20/2019 12:26',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [ carRental addCar: Car panda].\r\t1 to: 2 do: [ carRental addCar: Car tesla].\r\t1 to: 1 do: [ carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t',			#stamp : 'JN 6/22/2019 15:44',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T15:45:53.811616+02:00' ],		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [ carRental addCar: Car panda].\r\t1 to: 2 do: [ carRental addCar: Car tesla].\r\t1 to: 1 do: [ carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t',			#stamp : 'JN 6/22/2019 15:44',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tcarRental availableCars\r\tself assert: (carRental availableCars size) equals: 6.\r\t',			#stamp : 'JN 6/22/2019 15:45',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T15:46:07.763599+02:00' ],		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tcarRental availableCars\r\tself assert: (carRental availableCars size) equals: 6.\r\t',			#stamp : 'JN 6/22/2019 15:45',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t',			#stamp : 'JN 6/22/2019 15:46',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T15:48:07.786887+02:00' ],		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t',			#stamp : 'JN 6/22/2019 15:46',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t',			#stamp : 'JN 6/22/2019 15:48',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T15:49:09.890883+02:00' ],		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'isAvailable:startingOn:days:',		#newSelector : #'carIsAvailable:startingOn:days:',		#affectedClassName : 'CarRental>>#isAvailable:startingOn:days:'	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ],		#time : DateAndTime [ '2019-06-22T15:49:09.907534+02:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > (date + numDays days - 1 day)) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 15:49',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ],		#time : DateAndTime [ '2019-06-22T15:49:09.914458+02:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:days:',			#protocol : #action,			#sourceCode : 'availableCars: date days: numDays\r\t^ cars select: [ :aCar | self isAvailable: aCar startingOn: date days: numDays ]',			#stamp : 'JN 6/22/2019 12:55',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:days:',			#protocol : #action,			#sourceCode : 'availableCars: date days: numDays\r\t^ cars select: [ :aCar | self carIsAvailable: aCar startingOn: date days: numDays ]',			#stamp : 'JN 6/22/2019 15:49',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ],		#time : DateAndTime [ '2019-06-22T15:49:09.919842+02:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self isAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: Date today.\r\t(dictRentalEndingDates at: aCar) add: Date today + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 14:19',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self carIsAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: Date today.\r\t(dictRentalEndingDates at: aCar) add: Date today + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 15:49',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ],		#time : DateAndTime [ '2019-06-22T15:49:09.923272+02:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:',			#protocol : #action,			#sourceCode : 'rentedCars: date days: numDays\r\t"returns the cars that are rented at some point in the requested time period"\r\r\t^ cars reject: [ :aCar | self isAvailable: aCar startingOn: date days: numDays ]',			#stamp : 'JN 6/22/2019 15:27',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:',			#protocol : #action,			#sourceCode : 'rentedCars: date days: numDays\r\t"returns the cars that are rented at some point in the requested time period"\r\r\t^ cars reject: [ :aCar | self carIsAvailable: aCar startingOn: date days: numDays ]',			#stamp : 'JN 6/22/2019 15:49',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ],		#time : DateAndTime [ '2019-06-22T15:49:09.95412+02:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > (date + numDays days - 1 day)) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 15:25',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #'as yet unclassified',			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > (date + numDays days - 1 day)) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 15:25',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '111' ],		#self : OmReference [ '112' ],		#time : DateAndTime [ '2019-06-22T15:49:09.9579+02:00' ],		#trigger : OmReference [ '106' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'isAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'isAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > (date + numDays days - 1 day)) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 15:25',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T15:53:29.029336+02:00' ],		#prior : OmReference [ '112' ],		#self : OmReference [ '113' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:days:type:',			#protocol : #action,			#sourceCode : 'availableCars: date days: numDays type: aType\r\t^ cars select: [ :aCar | (aCar type == aType) & (self carIsAvailable: aCar startingOn: date days: numDays) ]',			#stamp : 'JN 6/22/2019 15:53',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:01:25.443205+02:00' ],		#prior : OmReference [ '113' ],		#self : OmReference [ '114' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\t',			#stamp : 'JN 6/22/2019 15:48',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate = Date year: 2019 month: 4 day: 1. \r\t"self assert (carRental availableCars: date days: 4 type: #golf)."\r\t\r\t',			#stamp : 'JN 6/22/2019 16:01',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:02:06.683769+02:00' ],		#prior : OmReference [ '114' ],		#self : OmReference [ '115' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate = Date year: 2019 month: 4 day: 1. \r\t"self assert (carRental availableCars: date days: 4 type: #golf)."\r\t\r\t',			#stamp : 'JN 6/22/2019 16:01',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\t"self assert (carRental availableCars: date days: 4 type: #golf)."\r\t\r\t',			#stamp : 'JN 6/22/2019 16:02',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:02:40.459038+02:00' ],		#prior : OmReference [ '115' ],		#self : OmReference [ '116' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\t"self assert (carRental availableCars: date days: 4 type: #golf)."\r\t\r\t',			#stamp : 'JN 6/22/2019 16:02',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4 type: #golf) equals: 1.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:02',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:03:14.292773+02:00' ],		#prior : OmReference [ '116' ],		#self : OmReference [ '117' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4 type: #golf) equals: 1.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:02',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4 type: #golf size) equals: 1.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:03',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:03:31.499402+02:00' ],		#prior : OmReference [ '117' ],		#self : OmReference [ '118' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4 type: #golf size) equals: 1.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:03',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:03',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:08:33.555121+02:00' ],		#prior : OmReference [ '118' ],		#self : OmReference [ '119' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:',			#protocol : #'as yet unclassified',			#sourceCode : 'rentType: aType days: numDays\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: Date today days: numDays type: aType).\r\t(possibleCars size > 0) ifFalse: [ ^false ].\r\t\r\t^ self rent: possibleCars first days: numDays.',			#stamp : 'JN 6/22/2019 16:08',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:09:03.115058+02:00' ],		#prior : OmReference [ '119' ],		#self : OmReference [ '120' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:',			#protocol : #'as yet unclassified',			#sourceCode : 'rentType: aType days: numDays\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: Date today days: numDays type: aType).\r\t(possibleCars size > 0) ifFalse: [ ^false ].\r\t\r\t^ self rent: possibleCars first days: numDays.',			#stamp : 'JN 6/22/2019 16:08',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:',			#protocol : #'as yet unclassified',			#sourceCode : 'rentType: aType days: numDays\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: Date today days: numDays type: aType).\r\t(possibleCars isEmpty) ifTrue: [ ^false ].\r\t\r\t^ self rent: possibleCars first days: numDays.',			#stamp : 'JN 6/22/2019 16:09',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:09:11.481819+02:00' ],		#prior : OmReference [ '120' ],		#self : OmReference [ '121' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:',			#protocol : #'as yet unclassified',			#sourceCode : 'rentType: aType days: numDays\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: Date today days: numDays type: aType).\r\t(possibleCars isEmpty) ifTrue: [ ^false ].\r\t\r\t^ self rent: possibleCars first days: numDays.',			#stamp : 'JN 6/22/2019 16:09',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: Date today days: numDays type: aType).\r\t(possibleCars isEmpty) ifTrue: [ ^false ].\r\t\r\t^ self rent: possibleCars first days: numDays.',			#stamp : 'JN 6/22/2019 16:09',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:09:44.837264+02:00' ],		#prior : OmReference [ '121' ],		#self : OmReference [ '122' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: Date today days: numDays type: aType).\r\t(possibleCars isEmpty) ifTrue: [ ^false ].\r\t\r\t^ self rent: possibleCars first days: numDays.',			#stamp : 'JN 6/22/2019 16:09',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: Date today days: numDays type: aType).\r\t(possibleCars isEmpty) \r\t\tifTrue: [ ^false ]\r\t\tifFalse: [ ^ self rent: possibleCars first days: numDays ].\r\t\r\t',			#stamp : 'JN 6/22/2019 16:09',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:11:03.469568+02:00' ],		#prior : OmReference [ '122' ],		#self : OmReference [ '123' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:type:',			#protocol : #action,			#sourceCode : 'rent: date days: numDays type: aType\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: Date today days: numDays type: aType).\r\t(possibleCars isEmpty) \r\t\tifTrue: [ ^false ]\r\t\tifFalse: [ ^ self rent: possibleCars first days: numDays ].\r\t\r\t',			#stamp : 'JN 6/22/2019 16:11',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:12:39.192963+02:00' ],		#prior : OmReference [ '123' ],		#self : OmReference [ '124' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startingOn:days:',			#protocol : #action,			#sourceCode : 'rent: aCar startingOn: date days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self carIsAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: Date today.\r\t(dictRentalEndingDates at: aCar) add: Date today + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 16:12',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:12:52.401293+02:00' ],		#prior : OmReference [ '124' ],		#self : OmReference [ '125' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startingOn:days:',			#protocol : #action,			#sourceCode : 'rent: aCar startingOn: date days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self carIsAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: Date today.\r\t(dictRentalEndingDates at: aCar) add: Date today + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 16:12',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startingOn:days:',			#protocol : #action,			#sourceCode : 'rent: aCar startingOn: date days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self carIsAvailable: aCar startingOn: date days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: Date today.\r\t(dictRentalEndingDates at: aCar) add: Date today + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 16:12',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:13:01.392028+02:00' ],		#prior : OmReference [ '125' ],		#self : OmReference [ '126' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'ManifestLifewareHR class'			},			#name : #ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #\'2019-06-22T14:22:00.415583+02:00\') )',			#stamp : 'JN 6/22/2019 14:22',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'ManifestLifewareHR class'			},			#name : #ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #\'2019-06-22T14:22:00.415583+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days: #false)) #\'2019-06-22T16:13:01.383293+02:00\') )',			#stamp : 'JN 6/22/2019 16:13',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:13:14.249924+02:00' ],		#prior : OmReference [ '126' ],		#self : OmReference [ '127' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startingOn:days:',			#protocol : #action,			#sourceCode : 'rent: aCar startingOn: date days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self carIsAvailable: aCar startingOn: date days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: Date today.\r\t(dictRentalEndingDates at: aCar) add: Date today + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 16:12',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startingOn:days:',			#protocol : #action,			#sourceCode : 'rent: aCar startingOn: date days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self carIsAvailable: aCar startingOn: date days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: date.\r\t(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 16:13',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:13:49.161745+02:00' ],		#prior : OmReference [ '127' ],		#self : OmReference [ '128' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self carIsAvailable: aCar startingOn: Date today days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: Date today.\r\t(dictRentalEndingDates at: aCar) add: Date today + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 15:49',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t^ self rent: aCar startingOn: Date today days: numDays.',			#stamp : 'JN 6/22/2019 16:13',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:14:22.062567+02:00' ],		#prior : OmReference [ '128' ],		#self : OmReference [ '129' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startingOn:days:type:',			#protocol : #action,			#sourceCode : 'rent: aCar startingOn: date days: numDays type: aType\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self carIsAvailable: aCar startingOn: date days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: date.\r\t(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 16:14',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:14:27.077409+02:00' ],		#prior : OmReference [ '129' ],		#self : OmReference [ '130' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'ManifestLifewareHR class'			},			#name : #ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #\'2019-06-22T14:22:00.415583+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days: #false)) #\'2019-06-22T16:13:01.383293+02:00\') )',			#stamp : 'JN 6/22/2019 16:13',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'ManifestLifewareHR class'			},			#name : #ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #\'2019-06-22T14:22:00.415583+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days: #false)) #\'2019-06-22T16:13:01.383293+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days:type: #false)) #\'2019-06-22T16:14:27.070015+02:00\') )',			#stamp : 'JN 6/22/2019 16:14',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:14:52.379563+02:00' ],		#prior : OmReference [ '130' ],		#self : OmReference [ '131' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startingOn:days:type:',			#protocol : #action,			#sourceCode : 'rent: aCar startingOn: date days: numDays type: aType\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self carIsAvailable: aCar startingOn: date days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: date.\r\t(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 16:14',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startingOn:days:type:',			#protocol : #action,			#sourceCode : 'rent: aCar startingOn: date days: numDays type: aType\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: date days: numDays type: aType).\r\t(possibleCars isEmpty) \r\t\tifTrue: [ ^false ]\r\t\tifFalse: [ ^ self rent: possibleCars first days: numDays ].',			#stamp : 'JN 6/22/2019 16:14',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:15:13.412189+02:00' ],		#prior : OmReference [ '131' ],		#self : OmReference [ '132' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startingOn:days:type:',			#protocol : #action,			#sourceCode : 'rent: aCar startingOn: date days: numDays type: aType\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: date days: numDays type: aType).\r\t(possibleCars isEmpty) \r\t\tifTrue: [ ^false ]\r\t\tifFalse: [ ^ self rent: possibleCars first days: numDays ].',			#stamp : 'JN 6/22/2019 16:14',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startingOn:days:type:',			#protocol : #action,			#sourceCode : 'rent: aCar startingOn: date days: numDays type: aType\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: date days: numDays type: aType).\r\t(possibleCars isEmpty) \r\t\tifTrue: [ ^false ]\r\t\tifFalse: [ ^ self rent: possibleCars first startingOn: date days: numDays ].',			#stamp : 'JN 6/22/2019 16:15',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:17:31.06266+02:00' ],		#prior : OmReference [ '132' ],		#self : OmReference [ '133' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:startingOn:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays startingOn: date\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: Date today days: numDays type: aType).\r\t(possibleCars isEmpty) \r\t\tifTrue: [ ^false ]\r\t\tifFalse: [ ^ self rent: possibleCars first days: numDays ].\r\t\r\t',			#stamp : 'JN 6/22/2019 16:17',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:17:42.36691+02:00' ],		#prior : OmReference [ '133' ],		#self : OmReference [ '134' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:startingOn:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays startingOn: date\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: Date today days: numDays type: aType).\r\t(possibleCars isEmpty) \r\t\tifTrue: [ ^false ]\r\t\tifFalse: [ ^ self rent: possibleCars first days: numDays ].\r\t\r\t',			#stamp : 'JN 6/22/2019 16:17',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:startingOn:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays startingOn: date\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: date days: numDays type: aType).\r\t(possibleCars isEmpty) \r\t\tifTrue: [ ^false ]\r\t\tifFalse: [ ^ self rent: possibleCars first days: numDays ].\r\t\r\t',			#stamp : 'JN 6/22/2019 16:17',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:18:07.30818+02:00' ],		#prior : OmReference [ '134' ],		#self : OmReference [ '135' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:startingOn:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays startingOn: date\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: date days: numDays type: aType).\r\t(possibleCars isEmpty) \r\t\tifTrue: [ ^false ]\r\t\tifFalse: [ ^ self rent: possibleCars first days: numDays ].\r\t\r\t',			#stamp : 'JN 6/22/2019 16:17',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:startingOn:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays startingOn: date\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: date days: numDays type: aType).\r\t(possibleCars isEmpty) \r\t\tifTrue: [ ^false ]\r\t\tifFalse: [ ^ self rent: possibleCars first startingOn: date days: numDays ].',			#stamp : 'JN 6/22/2019 16:18',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:18:51.166416+02:00' ],		#prior : OmReference [ '135' ],		#self : OmReference [ '136' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:type:',			#protocol : #action,			#sourceCode : 'rent: date days: numDays type: aType\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: Date today days: numDays type: aType).\r\t(possibleCars isEmpty) \r\t\tifTrue: [ ^false ]\r\t\tifFalse: [ ^ self rent: possibleCars first days: numDays ].\r\t\r\t',			#stamp : 'JN 6/22/2019 16:11',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:type:',			#protocol : #'as yet unclassified',			#sourceCode : 'rent: date days: numDays type: aType\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: Date today days: numDays type: aType).\r\t(possibleCars isEmpty) \r\t\tifTrue: [ ^false ]\r\t\tifFalse: [ ^ self rent: possibleCars first days: numDays ].\r\t\r\t',			#stamp : 'JN 6/22/2019 16:11',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:18:51.172297+02:00' ],		#prior : OmReference [ '136' ],		#self : OmReference [ '137' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:type:',			#protocol : #action,			#sourceCode : 'rent: date days: numDays type: aType\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: Date today days: numDays type: aType).\r\t(possibleCars isEmpty) \r\t\tifTrue: [ ^false ]\r\t\tifFalse: [ ^ self rent: possibleCars first days: numDays ].\r\t\r\t',			#stamp : 'JN 6/22/2019 16:11',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:19:29.219511+02:00' ],		#prior : OmReference [ '137' ],		#self : OmReference [ '138' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: Date today days: numDays type: aType).\r\t(possibleCars isEmpty) \r\t\tifTrue: [ ^false ]\r\t\tifFalse: [ ^ self rent: possibleCars first days: numDays ].\r\t\r\t',			#stamp : 'JN 6/22/2019 16:09',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays\r\t^ self rentType: aType days: numDays startingOn: Date today.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:19',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:19:42.574708+02:00' ],		#prior : OmReference [ '138' ],		#self : OmReference [ '139' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:startingOn:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays startingOn: date\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self carIsAvailable: aCar startingOn: date days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: date.\r\t(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 16:19',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:19:51.270317+02:00' ],		#prior : OmReference [ '139' ],		#self : OmReference [ '140' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:startingOn:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays startingOn: date\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self carIsAvailable: aCar startingOn: date days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: date.\r\t(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 16:19',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:startingOn:',			#protocol : #'as yet unclassified',			#sourceCode : 'rent: aCar days: numDays startingOn: date\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self carIsAvailable: aCar startingOn: date days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: date.\r\t(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 16:19',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:19:51.275588+02:00' ],		#prior : OmReference [ '140' ],		#self : OmReference [ '141' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:startingOn:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays startingOn: date\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self carIsAvailable: aCar startingOn: date days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: date.\r\t(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 16:19',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:20:16.561349+02:00' ],		#prior : OmReference [ '141' ],		#self : OmReference [ '142' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'rent:startingOn:days:',		#newSelector : #'rent:days:startingOn:',		#affectedClassName : 'CarRental>>#rent:startingOn:days:'	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '142' ],		#self : OmReference [ '143' ],		#time : DateAndTime [ '2019-06-22T16:20:16.57307+02:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:startingOn:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays startingOn: date\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self carIsAvailable: aCar startingOn: date days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: date.\r\t(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 16:20',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '143' ],		#self : OmReference [ '144' ],		#time : DateAndTime [ '2019-06-22T16:20:16.57987+02:00' ],		#trigger : OmReference [ '142' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t^ self rent: aCar startingOn: Date today days: numDays.',			#stamp : 'JN 6/22/2019 16:13',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t^ self rent: aCar days: numDays startingOn: Date today',			#stamp : 'JN 6/22/2019 16:20',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '144' ],		#self : OmReference [ '145' ],		#time : DateAndTime [ '2019-06-22T16:20:16.584576+02:00' ],		#trigger : OmReference [ '142' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startingOn:days:type:',			#protocol : #action,			#sourceCode : 'rent: aCar startingOn: date days: numDays type: aType\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: date days: numDays type: aType).\r\t(possibleCars isEmpty) \r\t\tifTrue: [ ^false ]\r\t\tifFalse: [ ^ self rent: possibleCars first startingOn: date days: numDays ].',			#stamp : 'JN 6/22/2019 16:15',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startingOn:days:type:',			#protocol : #action,			#sourceCode : 'rent: aCar startingOn: date days: numDays type: aType\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\r\t| possibleCars |\r\tpossibleCars := self availableCars: date days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first days: numDays startingOn: date ]',			#stamp : 'JN 6/22/2019 16:20',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '145' ],		#self : OmReference [ '146' ],		#time : DateAndTime [ '2019-06-22T16:20:16.588096+02:00' ],		#trigger : OmReference [ '142' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:startingOn:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays startingOn: date\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\t"Returns true upon success and false otherwise."\r\t| possibleCars |\r\tpossibleCars :=\t(self availableCars: date days: numDays type: aType).\r\t(possibleCars isEmpty) \r\t\tifTrue: [ ^false ]\r\t\tifFalse: [ ^ self rent: possibleCars first startingOn: date days: numDays ].',			#stamp : 'JN 6/22/2019 16:18',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentType:days:startingOn:',			#protocol : #action,			#sourceCode : 'rentType: aType days: numDays startingOn: date\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\r\t| possibleCars |\r\tpossibleCars := self availableCars: date days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first days: numDays startingOn: date ]',			#stamp : 'JN 6/22/2019 16:20',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '146' ],		#self : OmReference [ '147' ],		#time : DateAndTime [ '2019-06-22T16:20:16.615414+02:00' ],		#trigger : OmReference [ '142' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startingOn:days:',			#protocol : #action,			#sourceCode : 'rent: aCar startingOn: date days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self carIsAvailable: aCar startingOn: date days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: date.\r\t(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 16:13',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startingOn:days:',			#protocol : #'as yet unclassified',			#sourceCode : 'rent: aCar startingOn: date days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self carIsAvailable: aCar startingOn: date days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: date.\r\t(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 16:13',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '147' ],		#self : OmReference [ '148' ],		#time : DateAndTime [ '2019-06-22T16:20:16.618556+02:00' ],		#trigger : OmReference [ '142' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startingOn:days:',			#protocol : #action,			#sourceCode : 'rent: aCar startingOn: date days: numDays\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self carIsAvailable: aCar startingOn: date days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: date.\r\t(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 16:13',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:20:23.609127+02:00' ],		#prior : OmReference [ '148' ],		#self : OmReference [ '149' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'ManifestLifewareHR class'			},			#name : #ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #\'2019-06-22T14:22:00.415583+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days: #false)) #\'2019-06-22T16:13:01.383293+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days:type: #false)) #\'2019-06-22T16:14:27.070015+02:00\') )',			#stamp : 'JN 6/22/2019 16:14',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'ManifestLifewareHR class'			},			#name : #ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleRBCollectionMessagesToExternalObjectRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#CarRental #rent:days: #false)) #\'2019-06-22T14:22:00.415583+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days: #false)) #\'2019-06-22T16:13:01.383293+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:startingOn:days:type: #false)) #\'2019-06-22T16:14:27.070015+02:00\') #(#(#RGMethodDefinition #(#CarRental #rent:days:startingOn: #false)) #\'2019-06-22T16:20:23.601853+02:00\') )',			#stamp : 'JN 6/22/2019 16:20',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:20:37.971334+02:00' ],		#prior : OmReference [ '149' ],		#self : OmReference [ '150' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startingOn:days:type:',			#protocol : #action,			#sourceCode : 'rent: aCar startingOn: date days: numDays type: aType\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\r\t| possibleCars |\r\tpossibleCars := self availableCars: date days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first days: numDays startingOn: date ]',			#stamp : 'JN 6/22/2019 16:20',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startingOn:days:type:',			#protocol : #'as yet unclassified',			#sourceCode : 'rent: aCar startingOn: date days: numDays type: aType\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\r\t| possibleCars |\r\tpossibleCars := self availableCars: date days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first days: numDays startingOn: date ]',			#stamp : 'JN 6/22/2019 16:20',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:20:37.976112+02:00' ],		#prior : OmReference [ '150' ],		#self : OmReference [ '151' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:startingOn:days:type:',			#protocol : #action,			#sourceCode : 'rent: aCar startingOn: date days: numDays type: aType\r\t"Tries to rent a car of the given type for the given number of days starting today."\r\r\t"Returns true upon success and false otherwise."\r\r\t| possibleCars |\r\tpossibleCars := self availableCars: date days: numDays type: aType.\r\tpossibleCars isEmpty\r\t\tifTrue: [ ^ false ]\r\t\tifFalse: [ ^ self rent: possibleCars first days: numDays startingOn: date ]',			#stamp : 'JN 6/22/2019 16:20',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:22:13.119682+02:00' ],		#prior : OmReference [ '151' ],		#self : OmReference [ '152' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #rentedCars,			#protocol : #action,			#sourceCode : 'rentedCars\r\t"Returns all the cars that are rented today"\r\t^ self rentedCars: Date today days: 1',			#stamp : 'JN 6/22/2019 13:00',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #rentedCars,			#protocol : #action,			#sourceCode : 'rentedCars\r\t"Returns all the cars that are rented by someone today"\r\t^ self rentedCars: Date today days: 1',			#stamp : 'JN 6/22/2019 16:22',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:23:48.904096+02:00' ],		#prior : OmReference [ '152' ],		#self : OmReference [ '153' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:03',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tcarRental rentType: #golf days: 7 startingOn: (date - 5 days).\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:23',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:23:54.801953+02:00' ],		#prior : OmReference [ '153' ],		#self : OmReference [ '154' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tcarRental rentType: #golf days: 7 startingOn: (date - 5 days).\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:23',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tcarRental rentType: #golf days: 7 startingOn: (date - 5 days).\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:23',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:25:33.943446+02:00' ],		#prior : OmReference [ '154' ],		#self : OmReference [ '155' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tcarRental rentType: #golf days: 7 startingOn: (date - 5 days).\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:23',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tcarRental rentType: #golf days: 7 startingOn: (date - 5 days).\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:25',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:31:37.553746+02:00' ],		#prior : OmReference [ '155' ],		#self : OmReference [ '156' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tcarRental rentType: #golf days: 7 startingOn: (date - 5 days).\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:30',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tcarRental rentType: #golf days: 8 startingOn: (date - 5 days).\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:31',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:31:57.827181+02:00' ],		#prior : OmReference [ '156' ],		#self : OmReference [ '157' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tcarRental rentType: #golf days: 8 startingOn: (date - 5 days).\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:31',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tcarRental rentType: #golf days: 8 startingOn: (date - 5 days).\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:31',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:32:30.736841+02:00' ],		#prior : OmReference [ '157' ],		#self : OmReference [ '158' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tcarRental rentType: #golf days: 8 startingOn: (date - 5 days).\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:31',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tcarRental rentType: #golf days: 8 startingOn: (date - 5 days).\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:32',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:33:14.223972+02:00' ],		#prior : OmReference [ '158' ],		#self : OmReference [ '159' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:',			#protocol : #action,			#sourceCode : 'availableCars: date\r\t^ self availableCars: Date today days: 1',			#stamp : 'JN 6/22/2019 16:33',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:33:36.972974+02:00' ],		#prior : OmReference [ '159' ],		#self : OmReference [ '160' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:',			#protocol : #action,			#sourceCode : 'availableCars: date\r\t^ self availableCars: Date today days: 1',			#stamp : 'JN 6/22/2019 16:33',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:',			#protocol : #action,			#sourceCode : 'availableCars: date\r\t^ cars select: [ :aCar | self carIsAvailable: aCar startingOn: date days: 1 ]',			#stamp : 'JN 6/22/2019 16:33',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:34:09.517675+02:00' ],		#prior : OmReference [ '160' ],		#self : OmReference [ '161' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:',			#protocol : #action,			#sourceCode : 'availableCars: date\r\t^ cars select: [ :aCar | self carIsAvailable: aCar startingOn: date days: 1 ]',			#stamp : 'JN 6/22/2019 16:33',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:',			#protocol : #action,			#sourceCode : 'availableCars: date\r\t^ self availableCars: date days: 1.',			#stamp : 'JN 6/22/2019 16:34',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:35:25.354063+02:00' ],		#prior : OmReference [ '161' ],		#self : OmReference [ '162' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:days:type:',			#protocol : #action,			#sourceCode : 'availableCars: date days: numDays type: aType\r\t^ cars select: [ :aCar | (aCar type == aType) & (self carIsAvailable: aCar startingOn: date days: numDays) ]',			#stamp : 'JN 6/22/2019 15:53',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:days:type:',			#protocol : #action,			#sourceCode : 'availableCars: date days: numDays type: aType\r\t^ (self availableCars: date days: numDays) select: [ :aCar | aCar type == aType  ]',			#stamp : 'JN 6/22/2019 16:35',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:39:35.077263+02:00' ],		#prior : OmReference [ '162' ],		#self : OmReference [ '163' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\t1 to: 1 do: [:i | carRental addCar: Car golf].\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tcarRental rentType: #golf days: 8 startingOn: (date - 5 days).\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:32',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date golf |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\tgolf := Car golf.\r\tcarRental addCar: golf.\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tcarRental rentType: #golf days: 8 startingOn: (date - 5 days).\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:39',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:39:58.832445+02:00' ],		#prior : OmReference [ '163' ],		#self : OmReference [ '164' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date golf |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\tgolf := Car golf.\r\tcarRental addCar: golf.\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tcarRental rentType: #golf days: 8 startingOn: (date - 5 days).\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:39',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date golf |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\tgolf := Car golf.\r\tcarRental addCar: golf.\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tcarRental rentType: #golf days: 8 startingOn: (date - 5 days).\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:39',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:40:29.364506+02:00' ],		#prior : OmReference [ '164' ],		#self : OmReference [ '165' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date golf |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\tgolf := Car golf.\r\tcarRental addCar: golf.\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tcarRental rentType: #golf days: 8 startingOn: (date - 5 days).\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:39',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date golf |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\tgolf := Car golf.\r\tcarRental addCar: golf.\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tcarRental rentType: #golf days: 8 startingOn: (date - 5 days).\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:40',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:42:56.523334+02:00' ],		#prior : OmReference [ '165' ],		#self : OmReference [ '166' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date golf |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\tgolf := Car golf.\r\tcarRental addCar: golf.\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tcarRental rentType: #golf days: 8 startingOn: (date - 5 days).\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:40',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date golf |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\tgolf := Car golf.\r\tcarRental addCar: golf.\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tself assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:42',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:44:45.758955+02:00' ],		#prior : OmReference [ '166' ],		#self : OmReference [ '167' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date golf |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\tgolf := Car golf.\r\tcarRental addCar: golf.\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\tself assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:42',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testRentingWithDates,			#protocol : #'4 exercise',			#sourceCode : 'testRentingWithDates\r\t"Extend the code and write a test for the following scenario: Our car rentals has 3 pandas, 2 tesla and 1 golf. Customer Bob calls our service asking for a golf for 5 days starting on the 1st of April. Unfortunately the golf is already rented up to the 3rd of april. Our service tells Bob that we have two available teslas, and that they can provide an individual discount of 10 euros per day. \r\rOur informatic system should offer the functionalities to sustain the above scenario, for example it should know whether the panda is free in the requested period and so on...\r\rwrite test case(s) and code to simulate this scenario"\r\r| carRental date golf |\r\tcarRental := CarRental new.\r\t1 to: 3 do: [:i | carRental addCar: Car panda].\r\t1 to: 2 do: [:i | carRental addCar: Car tesla].\r\tgolf := Car golf.\r\tcarRental addCar: golf.\r\tself assert: (carRental availableCars size) equals: 6.\r\t\r\tdate := Date year: 2019 month: 4 day: 1. \r\tself assert: (carRental availableCars: date days: 4) size equals: 6.\r\tself assert: (carRental availableCars: date days: 4 type: #golf ) size equals: 1.\r\t"self assert: (carRental rentType: #golf days: 8 startingOn: (date - 5 days)) equals: true."\r\tself assert: (carRental rent: golf days: 8 startingOn: (date - 5 days)) equals: true.\r\tself assert: (carRental availableCars: date days: 1) size equals: 5.\r\tself assert: (carRental rentedCars: date days: 1) size equals: 1.\r\tself assert: (carRental availableCars: date days: 1 type: #golf ) size equals: 0.\r\t\r\t',			#stamp : 'JN 6/22/2019 16:44',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:49:03.272569+02:00' ],		#prior : OmReference [ '167' ],		#self : OmReference [ '168' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'carIsAvailable:startingOn:days:',		#newSelector : #'carIsAvailable:days:startingOn:',		#affectedClassName : 'CarRental>>#carIsAvailable:startingOn:days:'	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '168' ],		#self : OmReference [ '169' ],		#time : DateAndTime [ '2019-06-22T16:49:03.290028+02:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > (date + numDays days - 1 day)) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 16:49',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '169' ],		#self : OmReference [ '170' ],		#time : DateAndTime [ '2019-06-22T16:49:03.29641+02:00' ],		#trigger : OmReference [ '168' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:days:',			#protocol : #action,			#sourceCode : 'availableCars: date days: numDays\r\t^ cars select: [ :aCar | self carIsAvailable: aCar startingOn: date days: numDays ]',			#stamp : 'JN 6/22/2019 15:49',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'availableCars:days:',			#protocol : #action,			#sourceCode : 'availableCars: date days: numDays\r\t^ cars\r\t\tselect: [ :aCar | self carIsAvailable: aCar days: numDays startingOn: date ]',			#stamp : 'JN 6/22/2019 16:49',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '170' ],		#self : OmReference [ '171' ],		#time : DateAndTime [ '2019-06-22T16:49:03.301656+02:00' ],		#trigger : OmReference [ '168' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:',			#protocol : #action,			#sourceCode : 'rentedCars: date days: numDays\r\t"returns the cars that are rented at some point in the requested time period"\r\r\t^ cars reject: [ :aCar | self carIsAvailable: aCar startingOn: date days: numDays ]',			#stamp : 'JN 6/22/2019 15:49',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rentedCars:days:',			#protocol : #action,			#sourceCode : 'rentedCars: date days: numDays\r\t"returns the cars that are rented at some point in the requested time period"\r\r\t^ cars\r\t\treject: [ :aCar | self carIsAvailable: aCar days: numDays startingOn: date ]',			#stamp : 'JN 6/22/2019 16:49',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '171' ],		#self : OmReference [ '172' ],		#time : DateAndTime [ '2019-06-22T16:49:03.305279+02:00' ],		#trigger : OmReference [ '168' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:startingOn:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays startingOn: date\r\t"Tries to rent the given aCar for the given number of days."\r\t"Returns true upon success and false otherwise."\r\t(self carIsAvailable: aCar startingOn: date days: numDays)\r\t\tifFalse: [ ^false ].\r\t\r\t(dictRentalStartingDates at: aCar) add: date.\r\t(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.\r\t^true',			#stamp : 'JN 6/22/2019 16:20',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'rent:days:startingOn:',			#protocol : #action,			#sourceCode : 'rent: aCar days: numDays startingOn: date\r\t"Tries to rent the given aCar for the given number of days."\r\r\t"Returns true upon success and false otherwise."\r\r\t(self carIsAvailable: aCar days: numDays startingOn: date)\r\t\tifFalse: [ ^ false ].\r\t(dictRentalStartingDates at: aCar) add: date.\r\t(dictRentalEndingDates at: aCar) add: date + numDays days - 1 day.\r\t^ true',			#stamp : 'JN 6/22/2019 16:49',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '172' ],		#self : OmReference [ '173' ],		#time : DateAndTime [ '2019-06-22T16:49:03.338055+02:00' ],		#trigger : OmReference [ '168' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > (date + numDays days - 1 day)) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 15:49',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:startingOn:days:',			#protocol : #'as yet unclassified',			#sourceCode : 'carIsAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > (date + numDays days - 1 day)) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 15:49',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#prior : OmReference [ '173' ],		#self : OmReference [ '174' ],		#time : DateAndTime [ '2019-06-22T16:49:03.341535+02:00' ],		#trigger : OmReference [ '168' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:startingOn:days:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar startingOn: date days: numDays\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > (date + numDays days - 1 day)) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 15:49',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:50:48.505315+02:00' ],		#prior : OmReference [ '174' ],		#self : OmReference [ '175' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\t^ true.',			#stamp : 'JN 6/22/2019 16:50',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:51:16.502888+02:00' ],		#prior : OmReference [ '175' ],		#self : OmReference [ '176' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCustom,			#protocol : #'0 examples',			#sourceCode : 'testCustom\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tcarRental availableCars. \r\tcarRental rent: redPanda days: 5.\r\tcarRental availableCars.\r\t"self assert: (carRental rentedCars size) equals: 1"\r',			#stamp : 'JN 6/22/2019 15:24',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCustom,			#protocol : #'as yet unclassified',			#sourceCode : 'testCustom\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tcarRental availableCars. \r\tcarRental rent: redPanda days: 5.\r\tcarRental availableCars.\r\t"self assert: (carRental rentedCars size) equals: 1"\r',			#stamp : 'JN 6/22/2019 15:24',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:51:16.509051+02:00' ],		#prior : OmReference [ '176' ],		#self : OmReference [ '177' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCustom,			#protocol : #'0 examples',			#sourceCode : 'testCustom\r\t| carRental redPanda yellowPanda blackTesla |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tblackTesla := Car tesla.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda;\r\t\taddCar: blackTesla.\r\tcarRental availableCars. \r\tcarRental rent: redPanda days: 5.\r\tcarRental availableCars.\r\t"self assert: (carRental rentedCars size) equals: 1"\r',			#stamp : 'JN 6/22/2019 15:24',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:51:40.432197+02:00' ],		#prior : OmReference [ '177' ],		#self : OmReference [ '178' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\t^ true.',			#stamp : 'JN 6/22/2019 16:50',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\tself assert: (carRental availableCars size) equals: 2.\r\tcarRental rent: redPanda days: 5.\r\t^ true.',			#stamp : 'JN 6/22/2019 16:51',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:54:29.602582+02:00' ],		#prior : OmReference [ '178' ],		#self : OmReference [ '179' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\tself assert: (carRental availableCars size) equals: 2.\r\tcarRental rent: redPanda days: 5.\r\t^ true.',			#stamp : 'JN 6/22/2019 16:51',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\tself assert: (carRental availableCars size) equals: 2.\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\t^ true.',			#stamp : 'JN 6/22/2019 16:54',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:56:29.463565+02:00' ],		#prior : OmReference [ '179' ],		#self : OmReference [ '180' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\tself assert: (carRental availableCars size) equals: 2.\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\t^ true.',			#stamp : 'JN 6/22/2019 16:54',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\t^ true.',			#stamp : 'JN 6/22/2019 16:56',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:56:59.764476+02:00' ],		#prior : OmReference [ '180' ],		#self : OmReference [ '181' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\t^ true.',			#stamp : 'JN 6/22/2019 16:56',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/22/2019 16:56',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:57:27.956011+02:00' ],		#prior : OmReference [ '181' ],		#self : OmReference [ '182' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/22/2019 16:56',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/22/2019 16:57',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T16:57:31.024523+02:00' ],		#prior : OmReference [ '182' ],		#self : OmReference [ '183' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/22/2019 16:57',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/22/2019 16:57',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T17:00:52.983624+02:00' ],		#prior : OmReference [ '183' ],		#self : OmReference [ '184' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\tself assert: (carRental availableCars size) equals: 2.\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\tself assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 1.\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/22/2019 16:57',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRentalTest			},			#name : #testCarIsAvailable,			#protocol : #'3 exercise',			#sourceCode : 'testCarIsAvailable\r\t| carRental redPanda yellowPanda |\r\tcarRental := CarRental new.\r\tredPanda := Car panda.\r\tyellowPanda := Car panda.\r\tcarRental\r\t\taddCar: redPanda;\r\t\taddCar: yellowPanda.\r\t\t\r\t"self assert: (carRental availableCars size) equals: 2."\r\tcarRental rent: redPanda days: 5.\r\tcarRental rent: redPanda days: 5 startingOn: Date today - 10 days.\r\t"self assert: (carRental availableCars size) equals: 1.\r\tself assert: ((carRental availableCars: Date today + 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 20 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today - 3 days) size) equals: 2.\r\tself assert: ((carRental availableCars: Date today + 3 days) size) equals: 1."\r\tself assert: ((carRental availableCars: Date today - 7 days) size) equals: 1.\r\t^ true.',			#stamp : 'JN 6/22/2019 17:00',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T17:22:25.782345+02:00' ],		#prior : OmReference [ '184' ],		#self : OmReference [ '185' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalDate idxNextRentalDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [date, date + numDays - 1] is free. We can check this as follows. Let idxPrevRentalDate be the index of the last entry in rentalEndingDates that is before or equal to parameter date. Similarly, let idxNextRentalDate be the index of the first entry in rentalStrtingDates that is on or after parameter date. Then the rental interval is free if \r\t\t(idxPrevRentalDate is an invalid index or rentalEndingDates[idxPrevRentalDate] < date) and\r\t\t(idxNextRentalDate is an invalid index or rentalStartingDates[idxNextRentalDate] > date + numDays - 1) and\r\t\t(idxPrevRentalDate is an invalid index or idxNextRentalDate is an invalid index or (idxNextRentalDate - idxPrevRentalDate == 1))\r\t"\r\tidxPrevRentalDate := rentalEndingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that the conditions hold for the interval to be free."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [((rentalEndingDates at: idxPrevRentalDate ) < date) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalDate ) ifTrue: [((rentalStartingDates at: idxNextRentalDate ) > (date + numDays days - 1 day)) ifFalse: [ ^false ] ].\r\t(boundsCheck value: idxPrevRentalDate) ifTrue: [ (boundsCheck value: idxNextRentalDate) ifTrue: [ (idxNextRentalDate - idxPrevRentalDate == 1) ifFalse: [ ^false ] ] ]. \r\t^true.',			#stamp : 'JN 6/22/2019 16:49',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalStartingDate idxNextRentalStartingDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevRentalStartingDate and j := idxNextRentalStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."\r\tidxPrevRentalStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that there are no conflicts."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevRentalStartingDate) ifTrue: [((rentalEndingDates at: idxPrevRentalStartingDate ) >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalStartingDate ) ifTrue: [((rentalStartingDates at: idxNextRentalStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/22/2019 17:22',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T17:23:48.332668+02:00' ],		#prior : OmReference [ '185' ],		#self : OmReference [ '186' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevRentalStartingDate idxNextRentalStartingDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevRentalStartingDate and j := idxNextRentalStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."\r\tidxPrevRentalStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that there are no conflicts."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevRentalStartingDate) ifTrue: [((rentalEndingDates at: idxPrevRentalStartingDate ) >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalStartingDate ) ifTrue: [((rentalStartingDates at: idxNextRentalStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/22/2019 17:22',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextRentalStartingDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextRentalStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."\r\tidxPrevStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that there are no conflicts."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalStartingDate ) ifTrue: [((rentalStartingDates at: idxNextRentalStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/22/2019 17:23',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T17:24:19.924398+02:00' ],		#prior : OmReference [ '186' ],		#self : OmReference [ '187' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextRentalStartingDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextRentalStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."\r\tidxPrevStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextRentalStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that there are no conflicts."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNextRentalStartingDate ) ifTrue: [((rentalStartingDates at: idxNextRentalStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/22/2019 17:23',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextStartingDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."\r\tidxPrevStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that there are no conflicts."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNextStartingDate ) ifTrue: [((rentalStartingDates at: idxNextStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/22/2019 17:24',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T17:26:38.343176+02:00' ],		#prior : OmReference [ '187' ],		#self : OmReference [ '188' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextStartingDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."\r\tidxPrevStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | prev].\r\tidxNextStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] ifNone: [:prev :next | next].\r\t\r\t"Check that there are no conflicts."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNextStartingDate ) ifTrue: [((rentalStartingDates at: idxNextStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/22/2019 17:24',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextStartingDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."\r\tidxPrevStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [:found | idxPrevStartingDate := found. idxNextStartingDate = found] ifNone: [:prev :next | idxPrevStartingDate := prev. idxNextStartingDate := next ].\r\t\r\t"Check that there are no conflicts."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNextStartingDate ) ifTrue: [((rentalStartingDates at: idxNextStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/22/2019 17:26',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T17:26:49.05357+02:00' ],		#prior : OmReference [ '188' ],		#self : OmReference [ '189' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextStartingDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."\r\tidxPrevStartingDate := rentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [:found | idxPrevStartingDate := found. idxNextStartingDate = found] ifNone: [:prev :next | idxPrevStartingDate := prev. idxNextStartingDate := next ].\r\t\r\t"Check that there are no conflicts."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNextStartingDate ) ifTrue: [((rentalStartingDates at: idxNextStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/22/2019 17:26',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextStartingDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."\r\trentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [:found | idxPrevStartingDate := found. idxNextStartingDate = found] ifNone: [:prev :next | idxPrevStartingDate := prev. idxNextStartingDate := next ].\r\t\r\t"Check that there are no conflicts."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNextStartingDate ) ifTrue: [((rentalStartingDates at: idxNextStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/22/2019 17:26',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T17:27:07.558327+02:00' ],		#prior : OmReference [ '189' ],		#self : OmReference [ '190' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextStartingDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."\r\trentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [:found | idxPrevStartingDate := found. idxNextStartingDate = found] ifNone: [:prev :next | idxPrevStartingDate := prev. idxNextStartingDate := next ].\r\t\r\t"Check that there are no conflicts."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNextStartingDate ) ifTrue: [((rentalStartingDates at: idxNextStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/22/2019 17:26',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextStartingDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."\r\trentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [:found | idxPrevStartingDate := found. idxNextStartingDate := found] ifNone: [:prev :next | idxPrevStartingDate := prev. idxNextStartingDate := next ].\r\t\r\t"Check that there are no conflicts."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNextStartingDate ) ifTrue: [((rentalStartingDates at: idxNextStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/22/2019 17:27',			#package : #LifewareHR		}	}}OmEntry {	#tags : {		#author : 'JN',		#time : DateAndTime [ '2019-06-22T17:28:34.939783+02:00' ],		#prior : OmReference [ '190' ],		#self : OmReference [ '191' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrevStartingDate idxNextStartingDate boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrevStartingDate and j := idxNextStartingDate be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."\r\trentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [:found | idxPrevStartingDate := found. idxNextStartingDate := found] ifNone: [:prev :next | idxPrevStartingDate := prev. idxNextStartingDate := next ].\r\t\r\t"Check that there are no conflicts."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrevStartingDate) ifTrue: [((rentalEndingDates at: idxPrevStartingDate ) >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNextStartingDate ) ifTrue: [((rentalStartingDates at: idxNextStartingDate ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/22/2019 17:27',			#package : #LifewareHR		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CarRental			},			#name : #'carIsAvailable:days:startingOn:',			#protocol : #action,			#sourceCode : 'carIsAvailable: aCar days: numDays startingOn: date\r\t"Returns true if the requested aCar can be rented in the interval of dates [ date, date + numDays - 1 ] and false otherwise."\r\t| rentalStartingDates rentalEndingDates idxPrev idxNext boundsCheck|\r\trentalStartingDates := (dictRentalStartingDates at: aCar ifAbsent: [ ^false ]).\r\trentalEndingDates := (dictRentalEndingDates at: aCar ifAbsent: [ ^false ]).\r\t\r\t"We need to check if the interval of dates [a,b] := [date, date + numDays - 1] is free for rental. We can check this as follows. Let i := idxPrev and j := idxNext be the indices of the closest rentals starting dates as compared to parameter date. Then there is a conflict if rentalEndingDates[i] >= a OR rentalStartingDates[j] <= b."\r\trentalStartingDates findBinaryIndex: [ :arg | (date - arg) asDays ] do: [:found | idxPrev := found. idxNext := found] ifNone: [:prev :next | idxPrev := prev. idxNext := next ].\r\t\r\t"Check that there are no conflicts."\r\tself assert: rentalStartingDates size == rentalEndingDates size.\r\tboundsCheck := [ :idx | (idx > 0) & (idx <= rentalEndingDates size) ].\r\t(boundsCheck value: idxPrev) ifTrue: [((rentalEndingDates at: idxPrev ) >= date) ifTrue: [ ^false ] ].\r\t(boundsCheck value: idxNext ) ifTrue: [((rentalStartingDates at: idxNext ) <= (date + numDays days - 1 day)) ifTrue: [ ^false ] ].\r\t^true.',			#stamp : 'JN 6/22/2019 17:28',			#package : #LifewareHR		}	}}