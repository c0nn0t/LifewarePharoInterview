THERE_BE_DRAGONS_HERE
Instance of LargePositiveInteger did not understand #LargePositiveInteger
19 June 2019 8:45:48.928088 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

LargePositiveInteger(Object)>>doesNotUnderstand: #LargePositiveInteger
	Receiver: 1152921504606846976
	Arguments and temporary variables: 
		aMessage: 	LargePositiveInteger
		exception: 	MessageNotUnderstood: LargePositiveInteger>>LargePositiveInteger
		resumeValue: 	nil
	Receiver's instance variables: 
1152921504606846976

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ (1 class maxVal + 1) LargePositiveInteger
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>printIt
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		printString: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Meta + p do [ :target | target editor printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	17
		each: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#RubSmalltalkEditor) aKMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#RubSmalltalkEditor) a...etc...
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(501949952)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (799@506)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(376212224) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (799@506)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(376212224) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		timeStamp: 	867836
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(278@442)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	112
		charCode: 	112
		scanCode: 	112


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (799@506)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(376212224) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (799@506)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(376212224) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1234@761) corner: (1250@777)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1234@761) corner: (1250@777)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1242@770) mouseOver 865909 nil]
		targetOffset: 	(212@454)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 865909 1232 771 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(1234@761) corner: (1250@777)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1234@761) corner: (1250@777)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1242@770) mouseOver 865909 nil]
		targetOffset: 	(212@454)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 865909 1232 771 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1234@761) corner: (1250@777)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1234@761) corner: (1250@777)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1242@770) mouseOver 865909 nil]
		targetOffset: 	(212@454)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 865909 1232 771 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendKeyboardEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(1234@761) corner: (1250@777)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1234@761) corner: (1250@777)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1242@770) mouseOver 865909 nil]
		targetOffset: 	(212@454)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 865909 1232 771 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>handleEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(1234@761) corner: (1250@777)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1234@761) corner: (1250@777)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1242@770) mouseOver 865909 nil]
		targetOffset: 	(212@454)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 865909 1232 771 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
LargePositiveInteger(Object)>>doesNotUnderstand: #LargePositiveInteger
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>evaluateSelectionAndDo:
RubSmalltalkEditor>>printIt
[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of ProfStef class did not understand #prev
19 June 2019 9:16:46.400301 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

ProfStef class(Object)>>doesNotUnderstand: #prev
	Receiver: ProfStef
	Arguments and temporary variables: 
		aMessage: 	prev
		exception: 	MessageNotUnderstood: ProfStef class>>prev
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Model
		methodDict: 	a MethodDictionary(#close->ProfStef>>#close #first->ProfStef>>#firs...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ProfStef
		classPool: 	a Dictionary(#Instance->a ProfStef )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'ProfStef-Core'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ ProfStef prev
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>evaluateSelection
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>doIt
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>doIt:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
		thirdArg: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	18
		each: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#RubSmalltalkEditor) aKMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#RubSmalltalkEditor) a...etc...
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(501949952)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@468)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(858588928) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@468)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(858588928) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-d>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		timeStamp: 	2725317
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(209@422)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	100


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@468)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(858588928) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@468)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(858588928) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(827@744) corner: (843@760)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(827@744) corner: (843@760)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	a NECMenuMorph(638589696)
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(835@753) mouseOver 2721183 nil]
		targetOffset: 	(209@422)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2721183 835 753 0 0 0 1)
		lastKeyScanCode: 	100
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	[(835@753) mouseOver 2721183 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a NECM...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(827@744) corner: (843@760)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(827@744) corner: (843@760)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	a NECMenuMorph(638589696)
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(835@753) mouseOver 2721183 nil]
		targetOffset: 	(209@422)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2721183 835 753 0 0 0 1)
		lastKeyScanCode: 	100
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(827@744) corner: (843@760)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(827@744) corner: (843@760)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	a NECMenuMorph(638589696)
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(835@753) mouseOver 2721183 nil]
		targetOffset: 	(209@422)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2721183 835 753 0 0 0 1)
		lastKeyScanCode: 	100
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
ProfStef class(Object)>>doesNotUnderstand: #prev
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>evaluateSelectionAndDo:
RubSmalltalkEditor>>evaluateSelection
RubSmalltalkEditor>>doIt
RubSmalltalkEditor>>doIt:
[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Instances of Point are not indexable
19 June 2019 9:18:28.085863 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Point(Object)>>error:
	Receiver: (10@100)
	Arguments and temporary variables: 
		aString: 	'Instances of Point are not indexable'
	Receiver's instance variables: 
		x: 	10
		y: 	100


Point(Object)>>errorNotIndexable
	Receiver: (10@100)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		x: 	10
		y: 	100


Point(Object)>>size
	Receiver: (10@100)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		x: 	10
		y: 	100


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ (10 @ 100) size
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>printIt
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		printString: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Meta + p do [ :target | target editor printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	17
		each: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#RubSmalltalkEditor) aKMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#RubSmalltalkEditor) a...etc...
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(501949952)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@430)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(905646592) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@430)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(905646592) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		timeStamp: 	2827004
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(215@259)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	112
		charCode: 	112
		scanCode: 	112


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@430)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(905646592) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@430)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(905646592) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(833@581) corner: (849@597)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(833@581) corner: (849@597)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	a NECMenuMorph(1007290112)
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(841@590) mouseOver 2817848 nil]
		targetOffset: 	(216@259)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2817848 841 590 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	[(841@590) mouseOver 2817848 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a NECM...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(833@581) corner: (849@597)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(833@581) corner: (849@597)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	a NECMenuMorph(1007290112)
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(841@590) mouseOver 2817848 nil]
		targetOffset: 	(216@259)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2817848 841 590 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(833@581) corner: (849@597)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(833@581) corner: (849@597)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	a NECMenuMorph(1007290112)
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(841@590) mouseOver 2817848 nil]
		targetOffset: 	(216@259)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2817848 841 590 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
Point(Object)>>error:
Point(Object)>>errorNotIndexable
Point(Object)>>size
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>evaluateSelectionAndDo:
RubSmalltalkEditor>>printIt
[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ZeroDivide
19 June 2019 9:50:34.896149 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SmallInteger>>/
	Receiver: 2
	Arguments and temporary variables: 
		aNumber: 	0
	Receiver's instance variables: 
2

PharoSyntaxTutorial>>divideTwoByZero
	Receiver: a Pharo Tutorial (Pharo Syntax Tutorial)
	Arguments and temporary variables: 

	Receiver's instance variables: 
a Pharo Tutorial (Pharo Syntax Tutorial)

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ PharoSyntaxTutorial new divideTwoByZero
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>evaluateSelection
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>doIt
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>doIt:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
		thirdArg: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	18
		each: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#RubSmalltalkEditor) aKMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#RubSmalltalkEditor) a...etc...
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(501949952)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@107)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(99966464) a RubCursor(293329408)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@107)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(99966464) a RubCursor(293329408)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-d>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		timeStamp: 	4753864
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(428.0@299.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	100


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@107)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(99966464) a RubCursor(293329408)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@107)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(99966464) a RubCursor(293329408)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1151@461.0) corner: (1167@477.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1151@461) mouseOver 4735459 nil]
		targetOffset: 	(65.0@299.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4735459 1150 461 0 0 0 1)
		lastKeyScanCode: 	100
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(1151@461.0) corner: (1167@477.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1151@461) mouseOver 4735459 nil]
		targetOffset: 	(65.0@299.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4735459 1150 461 0 0 0 1)
		lastKeyScanCode: 	100
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
SmallInteger>>/
PharoSyntaxTutorial>>divideTwoByZero
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>evaluateSelectionAndDo:
RubSmalltalkEditor>>evaluateSelection
RubSmalltalkEditor>>doIt
RubSmalltalkEditor>>doIt:
[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ZeroDivide
19 June 2019 9:51:17.848921 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SmallInteger>>/
	Receiver: 2
	Arguments and temporary variables: 
		aNumber: 	0
	Receiver's instance variables: 
2

PharoSyntaxTutorial>>divideTwoByZero
	Receiver: a Pharo Tutorial (Pharo Syntax Tutorial)
	Arguments and temporary variables: 

	Receiver's instance variables: 
a Pharo Tutorial (Pharo Syntax Tutorial)

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ PharoSyntaxTutorial new divideTwoByZero
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>evaluateSelection
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>doIt
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>doIt:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
		thirdArg: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	18
		each: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#RubSmalltalkEditor) aKMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#RubSmalltalkEditor) a...etc...
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(501949952)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@107)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(99966464) a RubCursor(293329408)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@107)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(99966464) a RubCursor(293329408)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-d>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		timeStamp: 	4796815
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(255.0@178.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	100


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@107)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(99966464) a RubCursor(293329408)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@107)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(99966464) a RubCursor(293329408)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(978@340.0) corner: (994@356.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(978@340.0) corner: (994@356.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(978@340) mouseOver 4794851 nil]
		targetOffset: 	(235.0@96.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4794851 978 340 0 0 0 1)
		lastKeyScanCode: 	100
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(978@340.0) corner: (994@356.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(978@340.0) corner: (994@356.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(978@340) mouseOver 4794851 nil]
		targetOffset: 	(235.0@96.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4794851 978 340 0 0 0 1)
		lastKeyScanCode: 	100
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
SmallInteger>>/
PharoSyntaxTutorial>>divideTwoByZero
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>evaluateSelectionAndDo:
RubSmalltalkEditor>>evaluateSelection
RubSmalltalkEditor>>doIt
RubSmalltalkEditor>>doIt:
[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ZeroDivide
19 June 2019 9:53:21.814821 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SmallInteger>>/
	Receiver: 2
	Arguments and temporary variables: 
		aNumber: 	0
	Receiver's instance variables: 
2

PharoSyntaxTutorial>>divideTwoByZero
	Receiver: a Pharo Tutorial (Pharo Syntax Tutorial)
	Arguments and temporary variables: 

	Receiver's instance variables: 
a Pharo Tutorial (Pharo Syntax Tutorial)

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ PharoSyntaxTutorial new divideTwoByZero
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>evaluateSelection
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>doIt
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>doIt:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
		thirdArg: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	18
		each: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#RubSmalltalkEditor) aKMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#RubSmalltalkEditor) a...etc...
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(501949952)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@107)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(99966464) a RubCursor(293329408)...etc...
		fullBounds: 	(0@0) corner: (1150@107)
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@107)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(99966464) a RubCursor(293329408)...etc...
		fullBounds: 	(0@0) corner: (1150@107)
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-d>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		timeStamp: 	4920744
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(-70.0@114.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	100


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@107)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(99966464) a RubCursor(293329408)...etc...
		fullBounds: 	(0@0) corner: (1150@107)
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1150@107)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(99966464) a RubCursor(293329408)...etc...
		fullBounds: 	(0@0) corner: (1150@107)
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(653@276.0) corner: (669@292.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(653@276.0) corner: (669@292.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(653@276) mouseOver CTRL 4920738 nil]
		targetOffset: 	(324.0@96.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4920738 634 271 0 2 0 1)
		lastKeyScanCode: 	100
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(653@276.0) corner: (669@292.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(653@276.0) corner: (669@292.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(653@276) mouseOver CTRL 4920738 nil]
		targetOffset: 	(324.0@96.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4920738 634 271 0 2 0 1)
		lastKeyScanCode: 	100
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
SmallInteger>>/
PharoSyntaxTutorial>>divideTwoByZero
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>evaluateSelectionAndDo:
RubSmalltalkEditor>>evaluateSelection
RubSmalltalkEditor>>doIt
RubSmalltalkEditor>>doIt:
[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
KeyNotFound: key nil not found in MethodDictionary
19 June 2019 10:56:14.336074 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

MethodDictionary(Dictionary)>>errorKeyNotFound:
	Receiver: a MethodDictionary(#aaFontsColormapDepth->Color class>>#aaFontsColormapDepth #approvedSele...etc...
	Arguments and temporary variables: 
		aKey: 	nil
	Receiver's instance variables: 
		tally: 	87
		array: 	{nil. Color class>>#hex:. nil. Color class>>#paleMagenta. nil. Color cla...etc...


[ self errorKeyNotFound: key ] in MethodDictionary(Dictionary)>>at:
	Receiver: a MethodDictionary(#aaFontsColormapDepth->Color class>>#aaFontsColormapDepth #approvedSele...etc...
	Arguments and temporary variables: 
		key: 	nil
	Receiver's instance variables: 
		tally: 	87
		array: 	{nil. Color class>>#hex:. nil. Color class>>#paleMagenta. nil. Color cla...etc...


MethodDictionary>>at:ifAbsent:
	Receiver: a MethodDictionary(#aaFontsColormapDepth->Color class>>#aaFontsColormapDepth #approvedSele...etc...
	Arguments and temporary variables: 
		key: 	nil
		aBlock: 	[ self errorKeyNotFound: key ]
		index: 	63
	Receiver's instance variables: 
		tally: 	87
		array: 	{nil. Color class>>#hex:. nil. Color class>>#paleMagenta. nil. Color cla...etc...


MethodDictionary(Dictionary)>>at:
	Receiver: a MethodDictionary(#aaFontsColormapDepth->Color class>>#aaFontsColormapDepth #approvedSele...etc...
	Arguments and temporary variables: 
		key: 	nil
	Receiver's instance variables: 
		tally: 	87
		array: 	{nil. Color class>>#hex:. nil. Color class>>#paleMagenta. nil. Color cla...etc...


Metaclass(Behavior)>>compiledMethodAt:
	Receiver: Color class
	Arguments and temporary variables: 
		selector: 	nil
	Receiver's instance variables: 
		superclass: 	Object class
		methodDict: 	a MethodDictionary(#aaFontsColormapDepth->Color class>>#aaFontsColo...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		thisClass: 	Color


Metaclass(Behavior)>>>>
	Receiver: Color class
	Arguments and temporary variables: 
		selector: 	nil
	Receiver's instance variables: 
		superclass: 	Object class
		methodDict: 	a MethodDictionary(#aaFontsColormapDepth->Color class>>#aaFontsColo...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		thisClass: 	Color


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Color class >> red
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	8693265
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	8693303
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	8693265
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	8693303
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	8693254
		lastStepMessage: 	nil
		lastCycleTime: 	8693303
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	8693254
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	8693303
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	8693254
		lastStepMessage: 	nil
		lastCycleTime: 	8693303
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	8693254
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	8693254
		lastStepMessage: 	nil
		lastCycleTime: 	8693303
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	8693254
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	8693254
		lastStepMessage: 	nil
		lastCycleTime: 	8693303
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	8693254
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	8693254
		lastStepMessage: 	nil
		lastCycleTime: 	8693303
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	8693254
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
MethodDictionary(Dictionary)>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in MethodDictionary(Dictionary)>>at:
MethodDictionary>>at:ifAbsent:
MethodDictionary(Dictionary)>>at:
Metaclass(Behavior)>>compiledMethodAt:
Metaclass(Behavior)>>>>
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
KeyNotFound: key nil not found in MethodDictionary
19 June 2019 10:57:48.637211 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

MethodDictionary(Dictionary)>>errorKeyNotFound:
	Receiver: a MethodDictionary(#aaFontsColormapDepth->Color class>>#aaFontsColormapDepth #approvedSele...etc...
	Arguments and temporary variables: 
		aKey: 	nil
	Receiver's instance variables: 
		tally: 	87
		array: 	{nil. Color class>>#hex:. nil. Color class>>#paleMagenta. nil. Color cla...etc...


[ self errorKeyNotFound: key ] in MethodDictionary(Dictionary)>>at:
	Receiver: a MethodDictionary(#aaFontsColormapDepth->Color class>>#aaFontsColormapDepth #approvedSele...etc...
	Arguments and temporary variables: 
		key: 	nil
	Receiver's instance variables: 
		tally: 	87
		array: 	{nil. Color class>>#hex:. nil. Color class>>#paleMagenta. nil. Color cla...etc...


MethodDictionary>>at:ifAbsent:
	Receiver: a MethodDictionary(#aaFontsColormapDepth->Color class>>#aaFontsColormapDepth #approvedSele...etc...
	Arguments and temporary variables: 
		key: 	nil
		aBlock: 	[ self errorKeyNotFound: key ]
		index: 	63
	Receiver's instance variables: 
		tally: 	87
		array: 	{nil. Color class>>#hex:. nil. Color class>>#paleMagenta. nil. Color cla...etc...


MethodDictionary(Dictionary)>>at:
	Receiver: a MethodDictionary(#aaFontsColormapDepth->Color class>>#aaFontsColormapDepth #approvedSele...etc...
	Arguments and temporary variables: 
		key: 	nil
	Receiver's instance variables: 
		tally: 	87
		array: 	{nil. Color class>>#hex:. nil. Color class>>#paleMagenta. nil. Color cla...etc...


Metaclass(Behavior)>>compiledMethodAt:
	Receiver: Color class
	Arguments and temporary variables: 
		selector: 	nil
	Receiver's instance variables: 
		superclass: 	Object class
		methodDict: 	a MethodDictionary(#aaFontsColormapDepth->Color class>>#aaFontsColo...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		thisClass: 	Color


Metaclass(Behavior)>>>>
	Receiver: Color class
	Arguments and temporary variables: 
		selector: 	nil
	Receiver's instance variables: 
		superclass: 	Object class
		methodDict: 	a MethodDictionary(#aaFontsColormapDepth->Color class>>#aaFontsColo...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		thisClass: 	Color


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Color class >> blue
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(390587648)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (682@126)
		owner: 	a TransformWithLayoutMorph(823636480)
		submorphs: 	an Array(a RubPrimarySelectionMorph(449592832) a RubCursor(874432000...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (388738816) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(180068864)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(874432000)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(889098752))
		getMenuPolicy: 	a RubEditingArea(390587648)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	8787576
		lastStepMessage: 	nil
		lastCycleTime: 	8787603
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	8787576
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	8787576
		lastStepMessage: 	nil
		lastCycleTime: 	8787603
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	8787576
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	8787576
		lastStepMessage: 	nil
		lastCycleTime: 	8787603
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	8787576
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
MethodDictionary(Dictionary)>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in MethodDictionary(Dictionary)>>at:
MethodDictionary>>at:ifAbsent:
MethodDictionary(Dictionary)>>at:
Metaclass(Behavior)>>compiledMethodAt:
Metaclass(Behavior)>>>>
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
KeyNotFound: key nil not found in MethodDictionary
19 June 2019 10:57:51.558571 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

MethodDictionary(Dictionary)>>errorKeyNotFound:
	Receiver: a MethodDictionary(#aaFontsColormapDepth->Color class>>#aaFontsColormapDepth #approvedSele...etc...
	Arguments and temporary variables: 
		aKey: 	nil
	Receiver's instance variables: 
		tally: 	87
		array: 	{nil. Color class>>#hex:. nil. Color class>>#paleMagenta. nil. Color cla...etc...


[ self errorKeyNotFound: key ] in MethodDictionary(Dictionary)>>at:
	Receiver: a MethodDictionary(#aaFontsColormapDepth->Color class>>#aaFontsColormapDepth #approvedSele...etc...
	Arguments and temporary variables: 
		key: 	nil
	Receiver's instance variables: 
		tally: 	87
		array: 	{nil. Color class>>#hex:. nil. Color class>>#paleMagenta. nil. Color cla...etc...


MethodDictionary>>at:ifAbsent:
	Receiver: a MethodDictionary(#aaFontsColormapDepth->Color class>>#aaFontsColormapDepth #approvedSele...etc...
	Arguments and temporary variables: 
		key: 	nil
		aBlock: 	[ self errorKeyNotFound: key ]
		index: 	63
	Receiver's instance variables: 
		tally: 	87
		array: 	{nil. Color class>>#hex:. nil. Color class>>#paleMagenta. nil. Color cla...etc...


MethodDictionary(Dictionary)>>at:
	Receiver: a MethodDictionary(#aaFontsColormapDepth->Color class>>#aaFontsColormapDepth #approvedSele...etc...
	Arguments and temporary variables: 
		key: 	nil
	Receiver's instance variables: 
		tally: 	87
		array: 	{nil. Color class>>#hex:. nil. Color class>>#paleMagenta. nil. Color cla...etc...


Metaclass(Behavior)>>compiledMethodAt:
	Receiver: Color class
	Arguments and temporary variables: 
		selector: 	nil
	Receiver's instance variables: 
		superclass: 	Object class
		methodDict: 	a MethodDictionary(#aaFontsColormapDepth->Color class>>#aaFontsColo...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		thisClass: 	Color


Metaclass(Behavior)>>>>
	Receiver: Color class
	Arguments and temporary variables: 
		selector: 	nil
	Receiver's instance variables: 
		superclass: 	Object class
		methodDict: 	a MethodDictionary(#aaFontsColormapDepth->Color class>>#aaFontsColo...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		thisClass: 	Color


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Color class >> blue
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(390587648)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (682@126)
		owner: 	a TransformWithLayoutMorph(823636480)
		submorphs: 	an Array(a RubPrimarySelectionMorph(449592832) a RubCursor(874432000...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (388738816) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(180068864)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(874432000)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(237077248))
		getMenuPolicy: 	a RubEditingArea(390587648)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	8790479
		lastStepMessage: 	nil
		lastCycleTime: 	8790524
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	8790479
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	8790479
		lastStepMessage: 	nil
		lastCycleTime: 	8790524
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	8790479
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	8790479
		lastStepMessage: 	nil
		lastCycleTime: 	8790524
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	8790479
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
MethodDictionary(Dictionary)>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in MethodDictionary(Dictionary)>>at:
MethodDictionary>>at:ifAbsent:
MethodDictionary(Dictionary)>>at:
Metaclass(Behavior)>>compiledMethodAt:
Metaclass(Behavior)>>>>
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #'+='
19 June 2019 11:32:13.672923 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #'+='
	Receiver: 5
	Arguments and temporary variables: 
		aMessage: 	+= 1
		exception: 	MessageNotUnderstood: SmallInteger>>+=
		resumeValue: 	nil
	Receiver's instance variables: 
5

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ myNum += 1
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(390587648)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (682@202)
		owner: 	a TransformWithLayoutMorph(823636480)
		submorphs: 	an Array(a RubPrimarySelectionMorph(20578048) a RubCursor(874432000)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (388738816) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(180068864)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(874432000)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(787044096))
		getMenuPolicy: 	a RubEditingArea(390587648)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	10852583
		lastStepMessage: 	nil
		lastCycleTime: 	10852640
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	10852583
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	10852583
		lastStepMessage: 	nil
		lastCycleTime: 	10852640
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	10852583
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	10852583
		lastStepMessage: 	nil
		lastCycleTime: 	10852640
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	10852583
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #'+='
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of True did not understand #+
19 June 2019 11:32:47.313965 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

True(Object)>>doesNotUnderstand: #+
	Receiver: true
	Arguments and temporary variables: 
		aMessage: 	+ 1
		exception: 	MessageNotUnderstood: True>>+
		resumeValue: 	nil
	Receiver's instance variables: 
true

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ (myNum = myNum) + 1
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(390587648)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (682@202)
		owner: 	a TransformWithLayoutMorph(823636480)
		submorphs: 	an Array(a RubPrimarySelectionMorph(20578048) a RubCursor(874432000)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (388738816) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(180068864)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(874432000)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(1040270848))
		getMenuPolicy: 	a RubEditingArea(390587648)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	10886227
		lastStepMessage: 	nil
		lastCycleTime: 	10886281
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	10886227
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	10886227
		lastStepMessage: 	nil
		lastCycleTime: 	10886281
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	10886227
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	10886227
		lastStepMessage: 	nil
		lastCycleTime: 	10886281
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	10886227
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
True(Object)>>doesNotUnderstand: #+
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#first was sent to nil
19 June 2019 11:48:45.271975 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #first
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	first
		exception: 	MessageNotUnderstood: receiver of "first" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

ChangeSorterApplication>>createRingMethodForRemovedSelector:inClass:
	Receiver: a ChangeSorterApplication
	Arguments and temporary variables: 
		aSelector: 	#testFixedNumberOfCars
		aClass: 	CarRentalTest
		removalInfo: 	a MethodChangeRecord (#add)
		method: 	CarRentalTest>>#testFixedNumberOfCars
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a FastTablePresenter a FastTablePresenter a Fa...etc...
		owner: 	a DualChangeSorterApplication
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		model: 	a ChangeSorterModel
		prettyPrint: 	false
		showDiff: 	false
		prettyButton: 	a CheckBoxPresenter
		diffButton: 	a CheckBoxPresenter
		changesListPresenter: 	a FastTablePresenter
		methodsListPresenter: 	a FastTablePresenter
		classesListPresenter: 	a FastTablePresenter
		textPresenter: 	a TextPresenter


ChangeSorterApplication>>createRingMethodForSelector:inClass:
	Receiver: a ChangeSorterApplication
	Arguments and temporary variables: 
		aSelector: 	#testFixedNumberOfCars
		aClass: 	CarRentalTest
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a FastTablePresenter a FastTablePresenter a Fa...etc...
		owner: 	a DualChangeSorterApplication
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		model: 	a ChangeSorterModel
		prettyPrint: 	false
		showDiff: 	false
		prettyButton: 	a CheckBoxPresenter
		diffButton: 	a CheckBoxPresenter
		changesListPresenter: 	a FastTablePresenter
		methodsListPresenter: 	a FastTablePresenter
		classesListPresenter: 	a FastTablePresenter
		textPresenter: 	a TextPresenter


ChangeSorterApplication>>browseVersions
	Receiver: a ChangeSorterApplication
	Arguments and temporary variables: 
		class: 	CarRentalTest
		selector: 	#testFixedNumberOfCars
		method: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a FastTablePresenter a FastTablePresenter a Fa...etc...
		owner: 	a DualChangeSorterApplication
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		model: 	a ChangeSorterModel
		prettyPrint: 	false
		showDiff: 	false
		prettyButton: 	a CheckBoxPresenter
		diffButton: 	a CheckBoxPresenter
		changesListPresenter: 	a FastTablePresenter
		methodsListPresenter: 	a FastTablePresenter
		classesListPresenter: 	a FastTablePresenter
		textPresenter: 	a TextPresenter


[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(571458304)'Versions'
	Arguments and temporary variables: 
		evt: 	[(848@633) mouseUp 11844182 nil]
		w: 	a WorldMorph(275485952) [world]
		selArgCount: 	0
	Receiver's instance variables: 
		bounds: 	(775.0@625.0) corner: (1011.0@642.0)
		owner: 	a MenuMorph(314724864)
		submorphs: 	#()
		fullBounds: 	(775.0@625.0) corner: (1011.0@642.0)
		color: 	Color black
		extension: 	a MorphExtension (772519680)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Versions'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a ChangeSorterApplication
		selector: 	#browseVersions
		arguments: 	nil
		icon: 	nil
		keyText: 	'v'
		getStateSelector: 	nil
		enablementSelector: 	nil


BlockClosure>>ensure:
	Receiver: [ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := select...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	230
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |
"show cursor in case item opens a new MVC window"
(se...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(571458304)'Versions'
	Arguments and temporary variables: 
		evt: 	[(848@633) mouseUp 11844182 nil]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(775.0@625.0) corner: (1011.0@642.0)
		owner: 	a MenuMorph(314724864)
		submorphs: 	#()
		fullBounds: 	(775.0@625.0) corner: (1011.0@642.0)
		color: 	Color black
		extension: 	a MorphExtension (772519680)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Versions'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a ChangeSorterApplication
		selector: 	#browseVersions
		arguments: 	nil
		icon: 	nil
		keyText: 	'v'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(571458304)'Versions'
	Arguments and temporary variables: 
		evt: 	[(848@633) mouseUp 11844182 nil]
	Receiver's instance variables: 
		bounds: 	(775.0@625.0) corner: (1011.0@642.0)
		owner: 	a MenuMorph(314724864)
		submorphs: 	#()
		fullBounds: 	(775.0@625.0) corner: (1011.0@642.0)
		color: 	Color black
		extension: 	a MorphExtension (772519680)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Versions'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a ChangeSorterApplication
		selector: 	#browseVersions
		arguments: 	nil
		icon: 	nil
		keyText: 	'v'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(571458304)'Versions'
	Arguments and temporary variables: 
		anEvent: 	[(848@633) mouseUp 11844182 nil]
	Receiver's instance variables: 
		bounds: 	(775.0@625.0) corner: (1011.0@642.0)
		owner: 	a MenuMorph(314724864)
		submorphs: 	#()
		fullBounds: 	(775.0@625.0) corner: (1011.0@642.0)
		color: 	Color black
		extension: 	a MorphExtension (772519680)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Versions'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a ChangeSorterApplication
		selector: 	#browseVersions
		arguments: 	nil
		icon: 	nil
		keyText: 	'v'
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(848@633) mouseUp 11844182 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(571458304)'Versions'
	Receiver's instance variables: 
		timeStamp: 	11844182
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(848@633)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(571458304)'Versions'
	Arguments and temporary variables: 
		anEvent: 	[(848@633) mouseUp 11844182 nil]
	Receiver's instance variables: 
		bounds: 	(775.0@625.0) corner: (1011.0@642.0)
		owner: 	a MenuMorph(314724864)
		submorphs: 	#()
		fullBounds: 	(775.0@625.0) corner: (1011.0@642.0)
		color: 	Color black
		extension: 	a MorphExtension (772519680)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Versions'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a ChangeSorterApplication
		selector: 	#browseVersions
		arguments: 	nil
		icon: 	nil
		keyText: 	'v'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(848@633) mouseUp 11844182 nil]
		aMorph: 	a ToggleMenuItemMorph(571458304)'Versions'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(571458304)'Versions'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(848@633) mouseUp 11844182 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(571458304)'Versions'


MouseButtonEvent>>sentTo:
	Receiver: [(848@633) mouseUp 11844182 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	11844182
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(848@633)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(848@633) mouseUp 11844182 nil]
		aMorph: 	a ToggleMenuItemMorph(571458304)'Versions'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(571458304)'Versions'


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(848@633) mouseUp 11844182 nil]
		aMorph: 	a ToggleMenuItemMorph(571458304)'Versions'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(571458304)'Versions'


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(571458304)'Versions'
	Arguments and temporary variables: 
		anEvent: 	[(848@633) mouseUp 11844182 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(775.0@625.0) corner: (1011.0@642.0)
		owner: 	a MenuMorph(314724864)
		submorphs: 	#()
		fullBounds: 	(775.0@625.0) corner: (1011.0@642.0)
		color: 	Color black
		extension: 	a MorphExtension (772519680)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Versions'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a ChangeSorterApplication
		selector: 	#browseVersions
		arguments: 	nil
		icon: 	nil
		keyText: 	'v'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(848@633) mouseUp 11844182 nil]
		aMorph: 	a MenuMorph(314724864)
		localEvt: 	[(848@633) mouseUp 11844182 nil]
		index: 	10
		child: 	a ToggleMenuItemMorph(571458304)'Versions'
		morphs: 	an Array(a MenuTitleMorph(810124032) a ToggleMenuItemMorph(1024499456)'...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(571458304)'Versions'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(848@633) mouseUp 11844182 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(571458304)'Versions'


MouseButtonEvent>>sentTo:
	Receiver: [(848@633) mouseUp 11844182 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	11844182
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(848@633)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(848@633) mouseUp 11844182 nil]
		aMorph: 	a MenuMorph(314724864)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(571458304)'Versions'


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(848@633) mouseUp 11844182 nil]
		aMorph: 	a MenuMorph(314724864)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(571458304)'Versions'


MenuMorph(Morph)>>processEvent:using:
	Receiver: a MenuMorph(314724864)
	Arguments and temporary variables: 
		anEvent: 	[(848@633) mouseUp 11844182 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(770.0@484.0) corner: (1016.0@683.0)
		owner: 	nil
		submorphs: 	an Array(a MenuTitleMorph(810124032) a ToggleMenuItemMorph(102449945...etc...
		fullBounds: 	(770.0@484.0) corner: (1016.0@683.0)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (709352960) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a FastTablePresenter
		selectedItem: 	a ToggleMenuItemMorph(571458304)'Versions'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	a MenuTitleMorph(810124032)


MenuMorph(Morph)>>processEvent:
	Receiver: a MenuMorph(314724864)
	Arguments and temporary variables: 
		anEvent: 	[(848@633) mouseUp 11844182 nil]
	Receiver's instance variables: 
		bounds: 	(770.0@484.0) corner: (1016.0@683.0)
		owner: 	nil
		submorphs: 	an Array(a MenuTitleMorph(810124032) a ToggleMenuItemMorph(102449945...etc...
		fullBounds: 	(770.0@484.0) corner: (1016.0@683.0)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (709352960) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a FastTablePresenter
		selectedItem: 	a ToggleMenuItemMorph(571458304)'Versions'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	a MenuTitleMorph(810124032)


MenuMorph>>handleFocusEvent:
	Receiver: a MenuMorph(314724864)
	Arguments and temporary variables: 
		evt: 	[(848@633) mouseUp 11844182 nil]
	Receiver's instance variables: 
		bounds: 	(770.0@484.0) corner: (1016.0@683.0)
		owner: 	nil
		submorphs: 	an Array(a MenuTitleMorph(810124032) a ToggleMenuItemMorph(102449945...etc...
		fullBounds: 	(770.0@484.0) corner: (1016.0@683.0)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (709352960) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a FastTablePresenter
		selectedItem: 	a ToggleMenuItemMorph(571458304)'Versions'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	a MenuTitleMorph(810124032)


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(848@633) mouseUp 11844182 nil]
		focusHolder: 	a MenuMorph(314724864)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(848@633.0) corner: (864@649.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(848@633.0) corner: (864@649.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(848@633) mouseUp 11844182 nil]
		targetOffset: 	(73.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11844182 848 633 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	[(848@633) mouseOver red 11844117 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Spec...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(848@633) mouseUp 11844182 nil]
		focusHolder: 	a MenuMorph(314724864)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(848@633.0) corner: (864@649.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(848@633.0) corner: (864@649.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(848@633) mouseUp 11844182 nil]
		targetOffset: 	(73.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11844182 848 633 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(848@633) mouseUp 11844182 nil]
		focusHolder: 	a MenuMorph(314724864)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(848@633.0) corner: (864@649.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(848@633.0) corner: (864@649.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(848@633) mouseUp 11844182 nil]
		targetOffset: 	(73.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11844182 848 633 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(848@633) mouseUp 11844182 nil]
	Receiver's instance variables: 
		bounds: 	(848@633.0) corner: (864@649.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(848@633.0) corner: (864@649.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(848@633) mouseUp 11844182 nil]
		targetOffset: 	(73.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11844182 848 633 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(848@633) mouseUp 11844182 nil]
		evt: 	[(848@633) mouseUp 11844182 nil]
	Receiver's instance variables: 
		bounds: 	(848@633.0) corner: (864@649.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(848@633.0) corner: (864@649.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(848@633) mouseUp 11844182 nil]
		targetOffset: 	(73.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11844182 848 633 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEventsFromQueue:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEventQueue: 	an InputEventSensor
		evt: 	[(848@633) mouseUp 11844182 nil]
		evtBuf: 	#(1 11844182 848 633 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(848@633.0) corner: (864@649.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(848@633.0) corner: (864@649.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(848@633) mouseUp 11844182 nil]
		targetOffset: 	(73.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11844182 848 633 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(848@633.0) corner: (864@649.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(848@633.0) corner: (864@649.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(848@633) mouseUp 11844182 nil]
		targetOffset: 	(73.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11844182 848 633 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		h: 	a HandMorph(810749440)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	11844166
		lastStepMessage: 	nil
		lastCycleTime: 	11844232
		alarms: 	a Heap()
		lastAlarmTime: 	11844166
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(810749440))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(810749440))


--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #first
ChangeSorterApplication>>createRingMethodForRemovedSelector:inClass:
ChangeSorterApplication>>createRingMethodForSelector:inClass:
ChangeSorterApplication>>browseVersions
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#first was sent to nil
19 June 2019 11:49:11.53312 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #first
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	first
		exception: 	MessageNotUnderstood: receiver of "first" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

ChangeSorterApplication>>createRingMethodForRemovedSelector:inClass:
	Receiver: a ChangeSorterApplication
	Arguments and temporary variables: 
		aSelector: 	#testFixedNumberOfCars
		aClass: 	CarRentalTest
		removalInfo: 	a MethodChangeRecord (#add)
		method: 	CarRentalTest>>#testFixedNumberOfCars
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a FastTablePresenter a FastTablePresenter a Fa...etc...
		owner: 	a DualChangeSorterApplication
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		model: 	a ChangeSorterModel
		prettyPrint: 	false
		showDiff: 	false
		prettyButton: 	a CheckBoxPresenter
		diffButton: 	a CheckBoxPresenter
		changesListPresenter: 	a FastTablePresenter
		methodsListPresenter: 	a FastTablePresenter
		classesListPresenter: 	a FastTablePresenter
		textPresenter: 	a TextPresenter


ChangeSorterApplication>>createRingMethodForSelector:inClass:
	Receiver: a ChangeSorterApplication
	Arguments and temporary variables: 
		aSelector: 	#testFixedNumberOfCars
		aClass: 	CarRentalTest
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a FastTablePresenter a FastTablePresenter a Fa...etc...
		owner: 	a DualChangeSorterApplication
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		model: 	a ChangeSorterModel
		prettyPrint: 	false
		showDiff: 	false
		prettyButton: 	a CheckBoxPresenter
		diffButton: 	a CheckBoxPresenter
		changesListPresenter: 	a FastTablePresenter
		methodsListPresenter: 	a FastTablePresenter
		classesListPresenter: 	a FastTablePresenter
		textPresenter: 	a TextPresenter


ChangeSorterApplication>>browseVersions
	Receiver: a ChangeSorterApplication
	Arguments and temporary variables: 
		class: 	CarRentalTest
		selector: 	#testFixedNumberOfCars
		method: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a FastTablePresenter a FastTablePresenter a Fa...etc...
		owner: 	a DualChangeSorterApplication
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		model: 	a ChangeSorterModel
		prettyPrint: 	false
		showDiff: 	false
		prettyButton: 	a CheckBoxPresenter
		diffButton: 	a CheckBoxPresenter
		changesListPresenter: 	a FastTablePresenter
		methodsListPresenter: 	a FastTablePresenter
		classesListPresenter: 	a FastTablePresenter
		textPresenter: 	a TextPresenter


[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(392693248)'Versions'
	Arguments and temporary variables: 
		evt: 	[(408@638) mouseUp 11870500 nil]
		w: 	a WorldMorph(275485952) [world]
		selArgCount: 	0
	Receiver's instance variables: 
		bounds: 	(347.0@624.0) corner: (583.0@641.0)
		owner: 	a MenuMorph(752104960)
		submorphs: 	#()
		fullBounds: 	(347.0@624.0) corner: (583.0@641.0)
		color: 	Color black
		extension: 	a MorphExtension (1055683328)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Versions'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a ChangeSorterApplication
		selector: 	#browseVersions
		arguments: 	nil
		icon: 	nil
		keyText: 	'v'
		getStateSelector: 	nil
		enablementSelector: 	nil


BlockClosure>>ensure:
	Receiver: [ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := select...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	230
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |
"show cursor in case item opens a new MVC window"
(se...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(392693248)'Versions'
	Arguments and temporary variables: 
		evt: 	[(408@638) mouseUp 11870500 nil]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(347.0@624.0) corner: (583.0@641.0)
		owner: 	a MenuMorph(752104960)
		submorphs: 	#()
		fullBounds: 	(347.0@624.0) corner: (583.0@641.0)
		color: 	Color black
		extension: 	a MorphExtension (1055683328)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Versions'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a ChangeSorterApplication
		selector: 	#browseVersions
		arguments: 	nil
		icon: 	nil
		keyText: 	'v'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(392693248)'Versions'
	Arguments and temporary variables: 
		evt: 	[(408@638) mouseUp 11870500 nil]
	Receiver's instance variables: 
		bounds: 	(347.0@624.0) corner: (583.0@641.0)
		owner: 	a MenuMorph(752104960)
		submorphs: 	#()
		fullBounds: 	(347.0@624.0) corner: (583.0@641.0)
		color: 	Color black
		extension: 	a MorphExtension (1055683328)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Versions'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a ChangeSorterApplication
		selector: 	#browseVersions
		arguments: 	nil
		icon: 	nil
		keyText: 	'v'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(392693248)'Versions'
	Arguments and temporary variables: 
		anEvent: 	[(408@638) mouseUp 11870500 nil]
	Receiver's instance variables: 
		bounds: 	(347.0@624.0) corner: (583.0@641.0)
		owner: 	a MenuMorph(752104960)
		submorphs: 	#()
		fullBounds: 	(347.0@624.0) corner: (583.0@641.0)
		color: 	Color black
		extension: 	a MorphExtension (1055683328)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Versions'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a ChangeSorterApplication
		selector: 	#browseVersions
		arguments: 	nil
		icon: 	nil
		keyText: 	'v'
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(408@638) mouseUp 11870500 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(392693248)'Versions'
	Receiver's instance variables: 
		timeStamp: 	11870500
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(408@638)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(392693248)'Versions'
	Arguments and temporary variables: 
		anEvent: 	[(408@638) mouseUp 11870500 nil]
	Receiver's instance variables: 
		bounds: 	(347.0@624.0) corner: (583.0@641.0)
		owner: 	a MenuMorph(752104960)
		submorphs: 	#()
		fullBounds: 	(347.0@624.0) corner: (583.0@641.0)
		color: 	Color black
		extension: 	a MorphExtension (1055683328)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Versions'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a ChangeSorterApplication
		selector: 	#browseVersions
		arguments: 	nil
		icon: 	nil
		keyText: 	'v'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(408@638) mouseUp 11870500 nil]
		aMorph: 	a ToggleMenuItemMorph(392693248)'Versions'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(392693248)'Versions'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(408@638) mouseUp 11870500 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(392693248)'Versions'


MouseButtonEvent>>sentTo:
	Receiver: [(408@638) mouseUp 11870500 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	11870500
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(408@638)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(408@638) mouseUp 11870500 nil]
		aMorph: 	a ToggleMenuItemMorph(392693248)'Versions'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(392693248)'Versions'


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(408@638) mouseUp 11870500 nil]
		aMorph: 	a ToggleMenuItemMorph(392693248)'Versions'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(392693248)'Versions'


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(392693248)'Versions'
	Arguments and temporary variables: 
		anEvent: 	[(408@638) mouseUp 11870500 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(347.0@624.0) corner: (583.0@641.0)
		owner: 	a MenuMorph(752104960)
		submorphs: 	#()
		fullBounds: 	(347.0@624.0) corner: (583.0@641.0)
		color: 	Color black
		extension: 	a MorphExtension (1055683328)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Versions'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a ChangeSorterApplication
		selector: 	#browseVersions
		arguments: 	nil
		icon: 	nil
		keyText: 	'v'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(408@638) mouseUp 11870500 nil]
		aMorph: 	a MenuMorph(752104960)
		localEvt: 	[(408@638) mouseUp 11870500 nil]
		index: 	10
		child: 	a ToggleMenuItemMorph(392693248)'Versions'
		morphs: 	an Array(a MenuTitleMorph(360869376) a ToggleMenuItemMorph(542537472)'D...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(392693248)'Versions'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(408@638) mouseUp 11870500 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(392693248)'Versions'


MouseButtonEvent>>sentTo:
	Receiver: [(408@638) mouseUp 11870500 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	11870500
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(408@638)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(408@638) mouseUp 11870500 nil]
		aMorph: 	a MenuMorph(752104960)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(392693248)'Versions'


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(408@638) mouseUp 11870500 nil]
		aMorph: 	a MenuMorph(752104960)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(392693248)'Versions'


MenuMorph(Morph)>>processEvent:using:
	Receiver: a MenuMorph(752104960)
	Arguments and temporary variables: 
		anEvent: 	[(408@638) mouseUp 11870500 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(342.0@483.0) corner: (588.0@682.0)
		owner: 	nil
		submorphs: 	an Array(a MenuTitleMorph(360869376) a ToggleMenuItemMorph(542537472...etc...
		fullBounds: 	(342.0@483.0) corner: (588.0@682.0)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (641007360) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a FastTablePresenter
		selectedItem: 	a ToggleMenuItemMorph(392693248)'Versions'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	a MenuTitleMorph(360869376)


MenuMorph(Morph)>>processEvent:
	Receiver: a MenuMorph(752104960)
	Arguments and temporary variables: 
		anEvent: 	[(408@638) mouseUp 11870500 nil]
	Receiver's instance variables: 
		bounds: 	(342.0@483.0) corner: (588.0@682.0)
		owner: 	nil
		submorphs: 	an Array(a MenuTitleMorph(360869376) a ToggleMenuItemMorph(542537472...etc...
		fullBounds: 	(342.0@483.0) corner: (588.0@682.0)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (641007360) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a FastTablePresenter
		selectedItem: 	a ToggleMenuItemMorph(392693248)'Versions'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	a MenuTitleMorph(360869376)


MenuMorph>>handleFocusEvent:
	Receiver: a MenuMorph(752104960)
	Arguments and temporary variables: 
		evt: 	[(408@638) mouseUp 11870500 nil]
	Receiver's instance variables: 
		bounds: 	(342.0@483.0) corner: (588.0@682.0)
		owner: 	nil
		submorphs: 	an Array(a MenuTitleMorph(360869376) a ToggleMenuItemMorph(542537472...etc...
		fullBounds: 	(342.0@483.0) corner: (588.0@682.0)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (641007360) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a FastTablePresenter
		selectedItem: 	a ToggleMenuItemMorph(392693248)'Versions'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	a MenuTitleMorph(360869376)


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(408@638) mouseUp 11870500 nil]
		focusHolder: 	a MenuMorph(752104960)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(408@638.0) corner: (424@654.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(408@638.0) corner: (424@654.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(408@638) mouseUp 11870500 nil]
		targetOffset: 	(61.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11870500 408 638 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	[(408@638) mouseOver red 11870412 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Spec...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(408@638) mouseUp 11870500 nil]
		focusHolder: 	a MenuMorph(752104960)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(408@638.0) corner: (424@654.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(408@638.0) corner: (424@654.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(408@638) mouseUp 11870500 nil]
		targetOffset: 	(61.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11870500 408 638 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(408@638) mouseUp 11870500 nil]
		focusHolder: 	a MenuMorph(752104960)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(408@638.0) corner: (424@654.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(408@638.0) corner: (424@654.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(408@638) mouseUp 11870500 nil]
		targetOffset: 	(61.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11870500 408 638 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(408@638) mouseUp 11870500 nil]
	Receiver's instance variables: 
		bounds: 	(408@638.0) corner: (424@654.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(408@638.0) corner: (424@654.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(408@638) mouseUp 11870500 nil]
		targetOffset: 	(61.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11870500 408 638 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(408@638) mouseUp 11870500 nil]
		evt: 	[(408@638) mouseUp 11870500 nil]
	Receiver's instance variables: 
		bounds: 	(408@638.0) corner: (424@654.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(408@638.0) corner: (424@654.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(408@638) mouseUp 11870500 nil]
		targetOffset: 	(61.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11870500 408 638 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEventsFromQueue:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEventQueue: 	an InputEventSensor
		evt: 	[(408@638) mouseUp 11870500 nil]
		evtBuf: 	#(1 11870500 408 638 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(408@638.0) corner: (424@654.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(408@638.0) corner: (424@654.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(408@638) mouseUp 11870500 nil]
		targetOffset: 	(61.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11870500 408 638 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(408@638.0) corner: (424@654.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(408@638.0) corner: (424@654.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(408@638) mouseUp 11870500 nil]
		targetOffset: 	(61.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11870500 408 638 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		h: 	a HandMorph(810749440)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	11870463
		lastStepMessage: 	nil
		lastCycleTime: 	11870500
		alarms: 	a Heap()
		lastAlarmTime: 	11870463
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(810749440))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(810749440))


--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #first
ChangeSorterApplication>>createRingMethodForRemovedSelector:inClass:
ChangeSorterApplication>>createRingMethodForSelector:inClass:
ChangeSorterApplication>>browseVersions
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#first was sent to nil
19 June 2019 11:49:45.740485 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #first
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	first
		exception: 	MessageNotUnderstood: receiver of "first" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

ChangeSorterApplication>>createRingMethodForRemovedSelector:inClass:
	Receiver: a ChangeSorterApplication
	Arguments and temporary variables: 
		aSelector: 	#testFixedNumberOfCars
		aClass: 	CarRentalTest
		removalInfo: 	a MethodChangeRecord (#add)
		method: 	CarRentalTest>>#testFixedNumberOfCars
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a FastTablePresenter a FastTablePresenter a Fa...etc...
		owner: 	a DualChangeSorterApplication
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		model: 	a ChangeSorterModel
		prettyPrint: 	false
		showDiff: 	false
		prettyButton: 	a CheckBoxPresenter
		diffButton: 	a CheckBoxPresenter
		changesListPresenter: 	a FastTablePresenter
		methodsListPresenter: 	a FastTablePresenter
		classesListPresenter: 	a FastTablePresenter
		textPresenter: 	a TextPresenter


ChangeSorterApplication>>createRingMethodForSelector:inClass:
	Receiver: a ChangeSorterApplication
	Arguments and temporary variables: 
		aSelector: 	#testFixedNumberOfCars
		aClass: 	CarRentalTest
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a FastTablePresenter a FastTablePresenter a Fa...etc...
		owner: 	a DualChangeSorterApplication
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		model: 	a ChangeSorterModel
		prettyPrint: 	false
		showDiff: 	false
		prettyButton: 	a CheckBoxPresenter
		diffButton: 	a CheckBoxPresenter
		changesListPresenter: 	a FastTablePresenter
		methodsListPresenter: 	a FastTablePresenter
		classesListPresenter: 	a FastTablePresenter
		textPresenter: 	a TextPresenter


ChangeSorterApplication>>browseVersions
	Receiver: a ChangeSorterApplication
	Arguments and temporary variables: 
		class: 	CarRentalTest
		selector: 	#testFixedNumberOfCars
		method: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a FastTablePresenter a FastTablePresenter a Fa...etc...
		owner: 	a DualChangeSorterApplication
		window: 	a NewValueHolder[ nil ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Untitled window' ]
		model: 	a ChangeSorterModel
		prettyPrint: 	false
		showDiff: 	false
		prettyButton: 	a CheckBoxPresenter
		diffButton: 	a CheckBoxPresenter
		changesListPresenter: 	a FastTablePresenter
		methodsListPresenter: 	a FastTablePresenter
		classesListPresenter: 	a FastTablePresenter
		textPresenter: 	a TextPresenter


[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(720757504)'Versions'
	Arguments and temporary variables: 
		evt: 	[(546@640) mouseUp 11904707 nil]
		w: 	a WorldMorph(275485952) [world]
		selArgCount: 	0
	Receiver's instance variables: 
		bounds: 	(401.0@629.0) corner: (637.0@646.0)
		owner: 	a MenuMorph(860625408)
		submorphs: 	#()
		fullBounds: 	(401.0@629.0) corner: (637.0@646.0)
		color: 	Color black
		extension: 	a MorphExtension (1025784576)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Versions'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a ChangeSorterApplication
		selector: 	#browseVersions
		arguments: 	nil
		icon: 	nil
		keyText: 	'v'
		getStateSelector: 	nil
		enablementSelector: 	nil


BlockClosure>>ensure:
	Receiver: [ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := select...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	230
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |
"show cursor in case item opens a new MVC window"
(se...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(720757504)'Versions'
	Arguments and temporary variables: 
		evt: 	[(546@640) mouseUp 11904707 nil]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(401.0@629.0) corner: (637.0@646.0)
		owner: 	a MenuMorph(860625408)
		submorphs: 	#()
		fullBounds: 	(401.0@629.0) corner: (637.0@646.0)
		color: 	Color black
		extension: 	a MorphExtension (1025784576)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Versions'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a ChangeSorterApplication
		selector: 	#browseVersions
		arguments: 	nil
		icon: 	nil
		keyText: 	'v'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(720757504)'Versions'
	Arguments and temporary variables: 
		evt: 	[(546@640) mouseUp 11904707 nil]
	Receiver's instance variables: 
		bounds: 	(401.0@629.0) corner: (637.0@646.0)
		owner: 	a MenuMorph(860625408)
		submorphs: 	#()
		fullBounds: 	(401.0@629.0) corner: (637.0@646.0)
		color: 	Color black
		extension: 	a MorphExtension (1025784576)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Versions'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a ChangeSorterApplication
		selector: 	#browseVersions
		arguments: 	nil
		icon: 	nil
		keyText: 	'v'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(720757504)'Versions'
	Arguments and temporary variables: 
		anEvent: 	[(546@640) mouseUp 11904707 nil]
	Receiver's instance variables: 
		bounds: 	(401.0@629.0) corner: (637.0@646.0)
		owner: 	a MenuMorph(860625408)
		submorphs: 	#()
		fullBounds: 	(401.0@629.0) corner: (637.0@646.0)
		color: 	Color black
		extension: 	a MorphExtension (1025784576)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Versions'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a ChangeSorterApplication
		selector: 	#browseVersions
		arguments: 	nil
		icon: 	nil
		keyText: 	'v'
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(546@640) mouseUp 11904707 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(720757504)'Versions'
	Receiver's instance variables: 
		timeStamp: 	11904707
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(546@640)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(720757504)'Versions'
	Arguments and temporary variables: 
		anEvent: 	[(546@640) mouseUp 11904707 nil]
	Receiver's instance variables: 
		bounds: 	(401.0@629.0) corner: (637.0@646.0)
		owner: 	a MenuMorph(860625408)
		submorphs: 	#()
		fullBounds: 	(401.0@629.0) corner: (637.0@646.0)
		color: 	Color black
		extension: 	a MorphExtension (1025784576)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Versions'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a ChangeSorterApplication
		selector: 	#browseVersions
		arguments: 	nil
		icon: 	nil
		keyText: 	'v'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(546@640) mouseUp 11904707 nil]
		aMorph: 	a ToggleMenuItemMorph(720757504)'Versions'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(720757504)'Versions'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(546@640) mouseUp 11904707 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(720757504)'Versions'


MouseButtonEvent>>sentTo:
	Receiver: [(546@640) mouseUp 11904707 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	11904707
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(546@640)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(546@640) mouseUp 11904707 nil]
		aMorph: 	a ToggleMenuItemMorph(720757504)'Versions'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(720757504)'Versions'


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(546@640) mouseUp 11904707 nil]
		aMorph: 	a ToggleMenuItemMorph(720757504)'Versions'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(720757504)'Versions'


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(720757504)'Versions'
	Arguments and temporary variables: 
		anEvent: 	[(546@640) mouseUp 11904707 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(401.0@629.0) corner: (637.0@646.0)
		owner: 	a MenuMorph(860625408)
		submorphs: 	#()
		fullBounds: 	(401.0@629.0) corner: (637.0@646.0)
		color: 	Color black
		extension: 	a MorphExtension (1025784576)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Versions'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a ChangeSorterApplication
		selector: 	#browseVersions
		arguments: 	nil
		icon: 	nil
		keyText: 	'v'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(546@640) mouseUp 11904707 nil]
		aMorph: 	a MenuMorph(860625408)
		localEvt: 	[(546@640) mouseUp 11904707 nil]
		index: 	10
		child: 	a ToggleMenuItemMorph(720757504)'Versions'
		morphs: 	an Array(a MenuTitleMorph(363718144) a ToggleMenuItemMorph(158348032)'D...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(720757504)'Versions'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(546@640) mouseUp 11904707 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(720757504)'Versions'


MouseButtonEvent>>sentTo:
	Receiver: [(546@640) mouseUp 11904707 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	11904707
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(546@640)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(546@640) mouseUp 11904707 nil]
		aMorph: 	a MenuMorph(860625408)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(720757504)'Versions'


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(546@640) mouseUp 11904707 nil]
		aMorph: 	a MenuMorph(860625408)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(720757504)'Versions'


MenuMorph(Morph)>>processEvent:using:
	Receiver: a MenuMorph(860625408)
	Arguments and temporary variables: 
		anEvent: 	[(546@640) mouseUp 11904707 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(396.0@488.0) corner: (642.0@687.0)
		owner: 	nil
		submorphs: 	an Array(a MenuTitleMorph(363718144) a ToggleMenuItemMorph(158348032...etc...
		fullBounds: 	(396.0@488.0) corner: (642.0@687.0)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (201869056) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a FastTablePresenter
		selectedItem: 	a ToggleMenuItemMorph(720757504)'Versions'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	a MenuTitleMorph(363718144)


MenuMorph(Morph)>>processEvent:
	Receiver: a MenuMorph(860625408)
	Arguments and temporary variables: 
		anEvent: 	[(546@640) mouseUp 11904707 nil]
	Receiver's instance variables: 
		bounds: 	(396.0@488.0) corner: (642.0@687.0)
		owner: 	nil
		submorphs: 	an Array(a MenuTitleMorph(363718144) a ToggleMenuItemMorph(158348032...etc...
		fullBounds: 	(396.0@488.0) corner: (642.0@687.0)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (201869056) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a FastTablePresenter
		selectedItem: 	a ToggleMenuItemMorph(720757504)'Versions'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	a MenuTitleMorph(363718144)


MenuMorph>>handleFocusEvent:
	Receiver: a MenuMorph(860625408)
	Arguments and temporary variables: 
		evt: 	[(546@640) mouseUp 11904707 nil]
	Receiver's instance variables: 
		bounds: 	(396.0@488.0) corner: (642.0@687.0)
		owner: 	nil
		submorphs: 	an Array(a MenuTitleMorph(363718144) a ToggleMenuItemMorph(158348032...etc...
		fullBounds: 	(396.0@488.0) corner: (642.0@687.0)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (201869056) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	a FastTablePresenter
		selectedItem: 	a ToggleMenuItemMorph(720757504)'Versions'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	a MenuTitleMorph(363718144)


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(546@640) mouseUp 11904707 nil]
		focusHolder: 	a MenuMorph(860625408)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(546@640.0) corner: (562@656.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(546@640.0) corner: (562@656.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(546@640) mouseUp 11904707 nil]
		targetOffset: 	(145.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11904707 546 640 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	[(546@640) mouseOver red 11904615 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Spec...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(546@640) mouseUp 11904707 nil]
		focusHolder: 	a MenuMorph(860625408)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(546@640.0) corner: (562@656.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(546@640.0) corner: (562@656.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(546@640) mouseUp 11904707 nil]
		targetOffset: 	(145.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11904707 546 640 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(546@640) mouseUp 11904707 nil]
		focusHolder: 	a MenuMorph(860625408)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(546@640.0) corner: (562@656.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(546@640.0) corner: (562@656.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(546@640) mouseUp 11904707 nil]
		targetOffset: 	(145.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11904707 546 640 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(546@640) mouseUp 11904707 nil]
	Receiver's instance variables: 
		bounds: 	(546@640.0) corner: (562@656.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(546@640.0) corner: (562@656.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(546@640) mouseUp 11904707 nil]
		targetOffset: 	(145.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11904707 546 640 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(546@640) mouseUp 11904707 nil]
		evt: 	[(546@640) mouseUp 11904707 nil]
	Receiver's instance variables: 
		bounds: 	(546@640.0) corner: (562@656.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(546@640.0) corner: (562@656.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(546@640) mouseUp 11904707 nil]
		targetOffset: 	(145.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11904707 546 640 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEventsFromQueue:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEventQueue: 	an InputEventSensor
		evt: 	[(546@640) mouseUp 11904707 nil]
		evtBuf: 	#(1 11904707 546 640 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(546@640.0) corner: (562@656.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(546@640.0) corner: (562@656.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(546@640) mouseUp 11904707 nil]
		targetOffset: 	(145.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11904707 546 640 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(546@640.0) corner: (562@656.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(546@640.0) corner: (562@656.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(546@640) mouseUp 11904707 nil]
		targetOffset: 	(145.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11904707 546 640 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		h: 	a HandMorph(810749440)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	11904664
		lastStepMessage: 	nil
		lastCycleTime: 	11904707
		alarms: 	a Heap()
		lastAlarmTime: 	11904664
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(810749440))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(810749440))


--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #first
ChangeSorterApplication>>createRingMethodForRemovedSelector:inClass:
ChangeSorterApplication>>createRingMethodForSelector:inClass:
ChangeSorterApplication>>browseVersions
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of FileList did not understand #readStream
19 June 2019 11:51:21.616533 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

FileList(Object)>>doesNotUnderstand: #readStream
	Receiver: a FileList
	Arguments and temporary variables: 
		aMessage: 	readStream
		exception: 	MessageNotUnderstood: FileList>>readStream
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(574322176) named: pharo a SearchMo...etc...
		announcer: 	nil
		reference: 	File @ /home/jerri/Downloads/pharo/Pharo.changes
		volumeList: 	#('[]' ' home' '  jerri' '   Downloads' '    pharo')
		volumeListIndex: 	5
		list: 	an Array(File @ /home/jerri/Downloads/pharo/Pharo.changes File @ /home/je...etc...
		listIndex: 	1
		pattern: 	nil
		brevityState: 	#fullFile
		dirSelectionBlock: 	[ :dirName | true ]
		modalView: 	nil
		ok: 	false
		contents: 	'

----QUIT----2019-03-15T14:54:38.352971+01:00 Pharo7.0-SNAPSHOT-32b...etc...
		optionalButtonSpecs: 	nil
		grid: 	a MorphTreeMorph(295581184)
		fileEncoding: 	nil
		sortBlock: 	[ :x :y | 
| xIsDir |
(xIsDir := x isDirectory) = y isDirectory
	ifT...etc...
		baseLabel: 	''
		configuredServices: 	an OrderedCollection()
		sourceTextModel: 	a RubScrolledTextModel


[ :stream | stream readStream ] in ExternalChangesBrowser class>>serviceBrowseCSOrSTFile
	Receiver: ExternalChangesBrowser
	Arguments and temporary variables: 
		stream: 	a FileList
	Receiver's instance variables: 
		superclass: 	ComposablePresenter
		methodDict: 	a MethodDictionary(#buildMenu:->ExternalChangesBrowser>>#buildMenu:...etc...
		format: 	65557
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ExternalChangesBrowser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Tool-ExternalBrowser-Browsers'


SimpleServiceEntry>>getArgumentsFrom:
	Receiver: SimpleServiceEntry: (ExternalChangesBrowser --- #openOnStream:)
	Arguments and temporary variables: 
		aProvider: 	a FileList
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(360300032) a FileList)
		announcer: 	nil
		provider: 	ExternalChangesBrowser
		label: 	'Changelist browser'
		selector: 	#openOnStream:
		usingLineAfter: 	true
		stateSelector: 	#none
		description: 	'Open a changelist tool on this file'
		argumentGetter: 	[ :stream | stream readStream ]
		buttonLabel: 	'Changes'


SimpleServiceEntry>>performServiceFor:
	Receiver: SimpleServiceEntry: (ExternalChangesBrowser --- #openOnStream:)
	Arguments and temporary variables: 
		anObject: 	a FileList
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a PluggableButtonMorph(360300032) a FileList)
		announcer: 	nil
		provider: 	ExternalChangesBrowser
		label: 	'Changelist browser'
		selector: 	#openOnStream:
		usingLineAfter: 	true
		stateSelector: 	#none
		description: 	'Open a changelist tool on this file'
		argumentGetter: 	[ :stream | stream readStream ]
		buttonLabel: 	'Changes'


PluggableButtonMorph>>performAction:
	Receiver: a PluggableButtonMorph(360300032)
	Arguments and temporary variables: 
		event: 	[(1069@392) mouseUp 12000579 nil]
	Receiver's instance variables: 
		bounds: 	(934.0@372.0) corner: (1308.0@400.0)
		owner: 	an AlignmentMorph(119831296)
		submorphs: 	an Array(an AlignmentMorph(319070976))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (434427392) [balloonText]  [other:  (mouseEntered -...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	SimpleServiceEntry: (ExternalChangesBrowser --- #openOnStream:)
		label: 	'Changes'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	nil
		actionSelector: 	#performServiceFor:
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	true
		triggerOnMouseDown: 	false
		offColor: 	Color white
		onColor: 	Color white
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	an Array(a FileList)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(1053742848)'Changes'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(360300032)
	Arguments and temporary variables: 
		evt: 	[(1069@392) mouseUp 12000579 nil]
		all: 	an Array(a PluggableButtonMorph(360300032))
		m: 	a PluggableButtonMorph(360300032)
	Receiver's instance variables: 
		bounds: 	(934.0@372.0) corner: (1308.0@400.0)
		owner: 	an AlignmentMorph(119831296)
		submorphs: 	an Array(an AlignmentMorph(319070976))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (434427392) [balloonText]  [other:  (mouseEntered -...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	SimpleServiceEntry: (ExternalChangesBrowser --- #openOnStream:)
		label: 	'Changes'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	nil
		actionSelector: 	#performServiceFor:
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	true
		triggerOnMouseDown: 	false
		offColor: 	Color white
		onColor: 	Color white
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	an Array(a FileList)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(1053742848)'Changes'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(360300032))
	Arguments and temporary variables: 
		aBlock: 	[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTr...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(360300032))

PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(360300032)
	Arguments and temporary variables: 
		evt: 	[(1069@392) mouseUp 12000579 nil]
		all: 	an Array(a PluggableButtonMorph(360300032))
	Receiver's instance variables: 
		bounds: 	(934.0@372.0) corner: (1308.0@400.0)
		owner: 	an AlignmentMorph(119831296)
		submorphs: 	an Array(an AlignmentMorph(319070976))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (434427392) [balloonText]  [other:  (mouseEntered -...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	SimpleServiceEntry: (ExternalChangesBrowser --- #openOnStream:)
		label: 	'Changes'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	nil
		actionSelector: 	#performServiceFor:
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	true
		triggerOnMouseDown: 	false
		offColor: 	Color white
		onColor: 	Color white
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	an Array(a FileList)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(1053742848)'Changes'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableButtonMorph(360300032)
	Arguments and temporary variables: 
		anEvent: 	[(1069@392) mouseUp 12000579 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(934.0@372.0) corner: (1308.0@400.0)
		owner: 	an AlignmentMorph(119831296)
		submorphs: 	an Array(an AlignmentMorph(319070976))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (434427392) [balloonText]  [other:  (mouseEntered -...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	SimpleServiceEntry: (ExternalChangesBrowser --- #openOnStream:)
		label: 	'Changes'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	nil
		actionSelector: 	#performServiceFor:
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	true
		triggerOnMouseDown: 	false
		offColor: 	Color white
		onColor: 	Color white
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	an Array(a FileList)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(1053742848)'Changes'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


MouseButtonEvent>>sentTo:
	Receiver: [(1069@392) mouseUp 12000579 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableButtonMorph(360300032)
	Receiver's instance variables: 
		timeStamp: 	12000579
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1069@392)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableButtonMorph(Morph)>>handleEvent:
	Receiver: a PluggableButtonMorph(360300032)
	Arguments and temporary variables: 
		anEvent: 	[(1069@392) mouseUp 12000579 nil]
	Receiver's instance variables: 
		bounds: 	(934.0@372.0) corner: (1308.0@400.0)
		owner: 	an AlignmentMorph(119831296)
		submorphs: 	an Array(an AlignmentMorph(319070976))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (434427392) [balloonText]  [other:  (mouseEntered -...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	SimpleServiceEntry: (ExternalChangesBrowser --- #openOnStream:)
		label: 	'Changes'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	nil
		actionSelector: 	#performServiceFor:
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	true
		triggerOnMouseDown: 	false
		offColor: 	Color white
		onColor: 	Color white
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	an Array(a FileList)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(1053742848)'Changes'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


PluggableButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a PluggableButtonMorph(360300032)
	Arguments and temporary variables: 
		anEvent: 	[(1069@392) mouseUp 12000579 nil]
	Receiver's instance variables: 
		bounds: 	(934.0@372.0) corner: (1308.0@400.0)
		owner: 	an AlignmentMorph(119831296)
		submorphs: 	an Array(an AlignmentMorph(319070976))
		fullBounds: 	nil
		color: 	(Color r: 0.901 g: 0.901 b: 0.901 alpha: 1.0)
		extension: 	a MorphExtension (434427392) [balloonText]  [other:  (mouseEntered -...etc...
		borderWidth: 	1
		borderColor: 	#simple
		model: 	SimpleServiceEntry: (ExternalChangesBrowser --- #openOnStream:)
		label: 	'Changes'
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	nil
		actionSelector: 	#performServiceFor:
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	true
		triggerOnMouseDown: 	false
		offColor: 	Color white
		onColor: 	Color white
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	an Array(a FileList)
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(1053742848)'Changes'
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	false


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(1069@392) mouseUp 12000579 nil]
		focusHolder: 	a PluggableButtonMorph(360300032)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1069@392.0) corner: (1085@408.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1069@392.0) corner: (1085@408.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForFieldView(79988480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1069@392) mouseUp 12000579 nil]
		targetOffset: 	(135.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12000579 1069 392 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	[(1069@392) mouseOver red 12000493 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1069@392) mouseUp 12000579 nil]
		focusHolder: 	a PluggableButtonMorph(360300032)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(1069@392.0) corner: (1085@408.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1069@392.0) corner: (1085@408.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForFieldView(79988480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1069@392) mouseUp 12000579 nil]
		targetOffset: 	(135.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12000579 1069 392 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(1069@392) mouseUp 12000579 nil]
		focusHolder: 	a PluggableButtonMorph(360300032)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1069@392.0) corner: (1085@408.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1069@392.0) corner: (1085@408.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForFieldView(79988480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1069@392) mouseUp 12000579 nil]
		targetOffset: 	(135.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12000579 1069 392 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(1069@392) mouseUp 12000579 nil]
	Receiver's instance variables: 
		bounds: 	(1069@392.0) corner: (1085@408.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1069@392.0) corner: (1085@408.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForFieldView(79988480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1069@392) mouseUp 12000579 nil]
		targetOffset: 	(135.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12000579 1069 392 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(1069@392) mouseUp 12000579 nil]
		evt: 	[(1069@392) mouseUp 12000579 nil]
	Receiver's instance variables: 
		bounds: 	(1069@392.0) corner: (1085@408.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1069@392.0) corner: (1085@408.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForFieldView(79988480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1069@392) mouseUp 12000579 nil]
		targetOffset: 	(135.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12000579 1069 392 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEventsFromQueue:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEventQueue: 	an InputEventSensor
		evt: 	[(1069@392) mouseUp 12000579 nil]
		evtBuf: 	#(1 12000579 1069 392 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1069@392.0) corner: (1085@408.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1069@392.0) corner: (1085@408.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForFieldView(79988480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1069@392) mouseUp 12000579 nil]
		targetOffset: 	(135.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12000579 1069 392 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(1069@392.0) corner: (1085@408.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1069@392.0) corner: (1085@408.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a TextMorphForFieldView(79988480)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1069@392) mouseUp 12000579 nil]
		targetOffset: 	(135.0@20.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12000579 1069 392 0 0 0 1)
		lastKeyScanCode: 	30
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		h: 	a HandMorph(810749440)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(783192576))(a SearchMorp...etc...
		lastStepTime: 	12000544
		lastStepMessage: 	nil
		lastCycleTime: 	12000579
		alarms: 	a Heap()
		lastAlarmTime: 	12000544
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(810749440))
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(810749440))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(783192576))(a SearchMorp...etc...
		lastStepTime: 	12000544
		lastStepMessage: 	nil
		lastCycleTime: 	12000579
		alarms: 	a Heap()
		lastAlarmTime: 	12000544
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(783192576))(a SearchMorp...etc...
		lastStepTime: 	12000544
		lastStepMessage: 	nil
		lastCycleTime: 	12000579
		alarms: 	a Heap()
		lastAlarmTime: 	12000544
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(783192576))(a SearchMorp...etc...
		lastStepTime: 	12000544
		lastStepMessage: 	nil
		lastCycleTime: 	12000579
		alarms: 	a Heap()
		lastAlarmTime: 	12000544
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
FileList(Object)>>doesNotUnderstand: #readStream
[ :stream | stream readStream ] in ExternalChangesBrowser class>>serviceBrowseCSOrSTFile
SimpleServiceEntry>>getArgumentsFrom:
SimpleServiceEntry>>performServiceFor:
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#asSymbol was sent to nil
19 June 2019 11:52:49.714702 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #asSymbol
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	asSymbol
		exception: 	MessageNotUnderstood: receiver of "asSymbol" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Protocol class>>name:
	Receiver: Protocol
	Arguments and temporary variables: 
		nm: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#addAllMethodsFrom:->Protocol>>#addAllMethodsFro...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AllProtocol}
		name: 	#Protocol
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Protocols'


ProtocolOrganizer>>addProtocolNamed:
	Receiver: a ProtocolOrganizer
	Arguments and temporary variables: 
		aName: 	nil
	Receiver's instance variables: 
		allProtocol: 	AllProtocol (-- all --) - 8 selector(s)
		protocols: 	an IdentitySet(Protocol (1.1 examples ) - 1 selector(s) Protocol (1 ...etc...


[ self addProtocolNamed: name ] in ProtocolOrganizer>>classify:inProtocolNamed:
	Receiver: a ProtocolOrganizer
	Arguments and temporary variables: 
		aSymbol: 	#testFixedNumberOfCars
		aProtocolName: 	nil
		name: 	nil
		protocol: 	nil
	Receiver's instance variables: 
		allProtocol: 	AllProtocol (-- all --) - 8 selector(s)
		protocols: 	an IdentitySet(Protocol (1.1 examples ) - 1 selector(s) Protocol (1 ...etc...


IdentitySet(Collection)>>detect:ifFound:ifNone:
	Receiver: an IdentitySet(Protocol (1.1 examples ) - 1 selector(s) Protocol (1 warming up exercise) -...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | e name = aByteString ]
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ self addProtocolNamed: name ]
	Receiver's instance variables: 
		tally: 	6
		array: 	an Array(Protocol (1.1 examples ) - 1 selector(s) nil nil Protocol (1 wa...etc...


IdentitySet(Collection)>>detect:ifNone:
	Receiver: an IdentitySet(Protocol (1.1 examples ) - 1 selector(s) Protocol (1 warming up exercise) -...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :e | e name = aByteString ]
		exceptionBlock: 	[ self addProtocolNamed: name ]
	Receiver's instance variables: 
		tally: 	6
		array: 	an Array(Protocol (1.1 examples ) - 1 selector(s) nil nil Protocol (1 wa...etc...


ProtocolOrganizer>>getProtocolNamed:ifNone:
	Receiver: a ProtocolOrganizer
	Arguments and temporary variables: 
		aByteString: 	nil
		aBlockClosure: 	[ self addProtocolNamed: name ]
	Receiver's instance variables: 
		allProtocol: 	AllProtocol (-- all --) - 8 selector(s)
		protocols: 	an IdentitySet(Protocol (1.1 examples ) - 1 selector(s) Protocol (1 ...etc...


ProtocolOrganizer>>classify:inProtocolNamed:
	Receiver: a ProtocolOrganizer
	Arguments and temporary variables: 
		aSymbol: 	#testFixedNumberOfCars
		aProtocolName: 	nil
		name: 	nil
		protocol: 	nil
	Receiver's instance variables: 
		allProtocol: 	AllProtocol (-- all --) - 8 selector(s)
		protocols: 	an IdentitySet(Protocol (1.1 examples ) - 1 selector(s) Protocol (1 ...etc...


ClassOrganization>>classify:under:suppressIfDefault:
	Receiver: a ClassOrganization
	Arguments and temporary variables: 
		selector: 	#testFixedNumberOfCars
		aProtocolName: 	nil
		aBoolean: 	true
		oldCategory: 	#'as yet unclassified'
		forceNotify: 	true
		oldProtocols: 	#()
	Receiver's instance variables: 
		comment: 	a RemoteString
		commentStamp: 	'VincentBlondeau 3/25/2019 10:13'
		protocolOrganizer: 	a ProtocolOrganizer
		organizedClass: 	CarRentalTest


ClassOrganization>>classify:under:
	Receiver: a ClassOrganization
	Arguments and temporary variables: 
		aSymbol: 	#testFixedNumberOfCars
		aProtocolName: 	nil
	Receiver's instance variables: 
		comment: 	a RemoteString
		commentStamp: 	'VincentBlondeau 3/25/2019 10:13'
		protocolOrganizer: 	a ProtocolOrganizer
		organizedClass: 	CarRentalTest


[ self organization
	classify: selector
	under:
		(category = Protocol unclassified
			ifTrue: [ oldProtocol ]
			ifFalse: [ category ]) ] in CarRentalTest class(ClassDescription)>>addAndClassifySelector:withMethod:inProtocol:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		selector: 	#testFixedNumberOfCars
		compiledMethod: 	CarRentalTest>>#testFixedNumberOfCars
		category: 	nil
		priorMethodOrNil: 	nil
		priorOriginOrNil: 	nil
		oldProtocol: 	#'as yet unclassified'
		newProtocol: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


BlockClosure>>ensure:
	Receiver: [ self organization
	classify: selector
	under:
		(category = Protocol unclassified
			ifT...etc...
	Arguments and temporary variables: 
		aBlock: 	[ suspended := oldSuspended ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest class(ClassDescription)>>addAndClassifySelector:wit...etc...
		startpc: 	222
		numArgs: 	0


SystemAnnouncer>>suspendAllWhile:
	Receiver: a SystemAnnouncer
	Arguments and temporary variables: 
		aBlock: 	[ self organization
	classify: selector
	under:
		(category = Protocol ...etc...
		oldSuspended: 	false
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspended: 	true
		private: 	an Announcer
		storedAnnouncements: 	nil


CarRentalTest class(ClassDescription)>>addAndClassifySelector:withMethod:inProtocol:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		selector: 	#testFixedNumberOfCars
		compiledMethod: 	CarRentalTest>>#testFixedNumberOfCars
		category: 	nil
		priorMethodOrNil: 	nil
		priorOriginOrNil: 	nil
		oldProtocol: 	#'as yet unclassified'
		newProtocol: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


CarRentalTest class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		text: 	a Text for 'testFixedNumberOfCars
	"Our car rental has now a fixed number...etc...
		category: 	nil
		changeStamp: 	'JerriNummenpalo 6/19/2019 23:52'
		requestor: 	a RubScrolledTextMorph(710059520)
		logSource: 	true
		method: 	CarRentalTest>>#testFixedNumberOfCars
		selector: 	#testFixedNumberOfCars
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


CarRentalTest class(ClassDescription)>>compile:classified:withStamp:notifying:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		text: 	a Text for 'testFixedNumberOfCars
	"Our car rental has now a fixed number...etc...
		category: 	nil
		changeStamp: 	'JerriNummenpalo 6/19/2019 23:52'
		requestor: 	a RubScrolledTextMorph(710059520)
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


CarRentalTest class(ClassDescription)>>compile:classified:notifying:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		text: 	a Text for 'testFixedNumberOfCars
	"Our car rental has now a fixed number...etc...
		category: 	nil
		requestor: 	a RubScrolledTextMorph(710059520)
		stamp: 	'JerriNummenpalo 6/19/2019 23:52'
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyMethodCodeEditorToolMorph>>applyChanges
	Receiver: a ClyMethodCodeEditorToolMorph(253204992)
	Arguments and temporary variables: 
		selector: 	nil
		methodClass: 	CarRentalTest
		currentMethod: 	nil
	Receiver's instance variables: 
		bounds: 	(1023.0@701.0) corner: (1838.0@1098.0)
		owner: 	a Morph(916663552)
		submorphs: 	an Array(a PanelMorph(406947584))
		fullBounds: 	(1023@701) corner: (1838@1098)
		color: 	Color transparent
		extension: 	a MorphExtension (160179712) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(997427712)
		context: 	a ClyMethodContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(744191488)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(405464576)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(710059520)
		changesCancelRequested: 	false
		applyingChanges: 	true
		methodTags: 	#()
		extendingPackage: 	nil
		targetClasses: 	{CarRentalTest}
		editingMethod: 	CarRentalTest>>#testFixedNumberOfCars


[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyMethodCodeEditorToolMorph(253204992)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(1023.0@701.0) corner: (1838.0@1098.0)
		owner: 	a Morph(916663552)
		submorphs: 	an Array(a PanelMorph(406947584))
		fullBounds: 	(1023@701) corner: (1838@1098)
		color: 	Color transparent
		extension: 	a MorphExtension (160179712) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(997427712)
		context: 	a ClyMethodContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(744191488)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(405464576)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(710059520)
		changesCancelRequested: 	false
		applyingChanges: 	true
		methodTags: 	#()
		extendingPackage: 	nil
		targetClasses: 	{CarRentalTest}
		editingMethod: 	CarRentalTest>>#testFixedNumberOfCars


BlockClosure>>on:do:
	Receiver: [ self changesAreAboutApply.
applied := self applyChanges ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :err | 
textModel text: self editingText.
textMorph hasUnaccep...etc...
	Receiver's instance variables: 
		outerContext: 	[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply...etc...
		startpc: 	140
		numArgs: 	0


[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyMethodCodeEditorToolMorph(253204992)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(1023.0@701.0) corner: (1838.0@1098.0)
		owner: 	a Morph(916663552)
		submorphs: 	an Array(a PanelMorph(406947584))
		fullBounds: 	(1023@701) corner: (1838@1098)
		color: 	Color transparent
		extension: 	a MorphExtension (160179712) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(997427712)
		context: 	a ClyMethodContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(744191488)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(405464576)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(710059520)
		changesCancelRequested: 	false
		applyingChanges: 	true
		methodTags: 	#()
		extendingPackage: 	nil
		targetClasses: 	{CarRentalTest}
		editingMethod: 	CarRentalTest>>#testFixedNumberOfCars


BlockClosure>>ensure:
	Receiver: [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyCh...etc...
	Arguments and temporary variables: 
		aBlock: 	[ applyingChanges := false ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAcce...etc...
		startpc: 	130
		numArgs: 	0


ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
	Receiver: a ClyMethodCodeEditorToolMorph(253204992)
	Arguments and temporary variables: 
		aBlock: 	[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
appl...etc...
	Receiver's instance variables: 
		bounds: 	(1023.0@701.0) corner: (1838.0@1098.0)
		owner: 	a Morph(916663552)
		submorphs: 	an Array(a PanelMorph(406947584))
		fullBounds: 	(1023@701) corner: (1838@1098)
		color: 	Color transparent
		extension: 	a MorphExtension (160179712) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(997427712)
		context: 	a ClyMethodContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(744191488)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(405464576)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(710059520)
		changesCancelRequested: 	false
		applyingChanges: 	true
		methodTags: 	#()
		extendingPackage: 	nil
		targetClasses: 	{CarRentalTest}
		editingMethod: 	CarRentalTest>>#testFixedNumberOfCars


ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyMethodCodeEditorToolMorph(253204992)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(1023.0@701.0) corner: (1838.0@1098.0)
		owner: 	a Morph(916663552)
		submorphs: 	an Array(a PanelMorph(406947584))
		fullBounds: 	(1023@701) corner: (1838@1098)
		color: 	Color transparent
		extension: 	a MorphExtension (160179712) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(997427712)
		context: 	a ClyMethodContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(744191488)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(405464576)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(710059520)
		changesCancelRequested: 	false
		applyingChanges: 	true
		methodTags: 	#()
		extendingPackage: 	nil
		targetClasses: 	{CarRentalTest}
		editingMethod: 	CarRentalTest>>#testFixedNumberOfCars


MessageSend>>value
	Receiver: MessageSend(#changesAccepted -> a ClyMethodCodeEditorToolMorph(253204992))
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a ClyMethodCodeEditorToolMorph(253204992)
		selector: 	#changesAccepted
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#changesAccepted -> a ClyMethodCodeEditorToolMorph(253204992))
	Arguments and temporary variables: 
		arg: 	a RubTextAccepted
	Receiver's instance variables: 
		receiver: 	a ClyMethodCodeEditorToolMorph(253204992)
		selector: 	#changesAccepted
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#changesAccepted -> a ClyMethodCodeEditorToolMorph(253204992))
	Arguments and temporary variables: 
		arg1: 	a RubTextAccepted
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a ClyMethodCodeEditorToolMorph(253204992)
		selector: 	#changesAccepted
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAccepted
		subscriber: 	a ClyMethodCodeEditorToolMorph(253204992)
		action: 	MessageSend(#changesAccepted -> a ClyMethodCodeEditorToolMorph(25320499...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	83
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	83
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAccepted
		subscriber: 	a ClyMethodCodeEditorToolMorph(253204992)
		action: 	MessageSend(#changesAccepted -> a ClyMethodCodeEditorToolMorph(25320499...etc...


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	82
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		announcement: 	a RubTextAccepted
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubScrolledTextMorph>>acceptContents
	Receiver: a RubScrolledTextMorph(710059520)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(1023.0@701.0) corner: (1838.0@1071.0)
		owner: 	a PanelMorph(406947584)
		submorphs: 	an Array(a RubTextScrollPane(812743424) a RubAdornmentDisplayer(1046...etc...
		fullBounds: 	(1023@701) corner: (1838@1071)
		color: 	Color white
		extension: 	a MorphExtension (1026061056) [other:  (announcer -> an Announcer) (...etc...
		hasEditingConflicts: 	false
		hasUnacceptedEdits: 	true
		alwaysAccept: 	nil
		setTextSelector: 	#setText:from:
		getTextSelector: 	#getText
		getSelectionSelector: 	#primarySelectionInterval
		setSelectionSelector: 	nil
		autoAccept: 	false
		scrollPane: 	a RubTextScrollPane(812743424)
		rulers: 	a SortedCollection(a RubTextSegmentIconDisplayer(715550208) a RubAdornm...etc...
		enabled: 	true
		highlights: 	an OrderedCollection()


RubScrolledTextMorph>>whenTextAcceptRequest:
	Receiver: a RubScrolledTextMorph(710059520)
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAcceptRequest
	Receiver's instance variables: 
		bounds: 	(1023.0@701.0) corner: (1838.0@1071.0)
		owner: 	a PanelMorph(406947584)
		submorphs: 	an Array(a RubTextScrollPane(812743424) a RubAdornmentDisplayer(1046...etc...
		fullBounds: 	(1023@701) corner: (1838@1071)
		color: 	Color white
		extension: 	a MorphExtension (1026061056) [other:  (announcer -> an Announcer) (...etc...
		hasEditingConflicts: 	false
		hasUnacceptedEdits: 	true
		alwaysAccept: 	nil
		setTextSelector: 	#setText:from:
		getTextSelector: 	#getText
		getSelectionSelector: 	#primarySelectionInterval
		setSelectionSelector: 	nil
		autoAccept: 	false
		scrollPane: 	a RubTextScrollPane(812743424)
		rulers: 	a SortedCollection(a RubTextSegmentIconDisplayer(715550208) a RubAdornm...etc...
		enabled: 	true
		highlights: 	an OrderedCollection()



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #asSymbol
Protocol class>>name:
ProtocolOrganizer>>addProtocolNamed:
[ self addProtocolNamed: name ] in ProtocolOrganizer>>classify:inProtocolNamed:
IdentitySet(Collection)>>detect:ifFound:ifNone:
IdentitySet(Collection)>>detect:ifNone:
ProtocolOrganizer>>getProtocolNamed:ifNone:
ProtocolOrganizer>>classify:inProtocolNamed:
ClassOrganization>>classify:under:suppressIfDefault:
ClassOrganization>>classify:under:
[ self organization
	classify: selector
	under:
		(category = Protocol unclassified
			ifTrue: [ oldProtocol ]
			ifFalse: [ category ]) ] in CarRentalTest class(ClassDescription)>>addAndClassifySelector:withMethod:inProtocol:
BlockClosure>>ensure:
SystemAnnouncer>>suspendAllWhile:
CarRentalTest class(ClassDescription)>>addAndClassifySelector:withMethod:inProtocol:
CarRentalTest class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
CarRentalTest class(ClassDescription)>>compile:classified:withStamp:notifying:
CarRentalTest class(ClassDescription)>>compile:classified:notifying:
ClyMethodCodeEditorToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
BlockClosure>>ensure:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubScrolledTextMorph>>acceptContents
RubScrolledTextMorph>>whenTextAcceptRequest:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(RubAbstractTextArea)>>announce:
RubEditingArea(RubAbstractTextArea)>>acceptContents
ClyTextEditor(RubTextEditor)>>accept
[ :target | target editor accept ] in RubTextEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
OrderedCollection>>do:
CmdKMDispatcher(KMDispatcher)>>dispatch:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#name was sent to nil
19 June 2019 11:53:01.721209 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #name
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	name
		exception: 	MessageNotUnderstood: receiver of "name" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

SycMoveMethodsToClassPackageCommand(SycMethodRepackagingCommand)>>moveMethod:toPackage:
	Receiver: a SycMoveMethodsToClassPackageCommand
	Arguments and temporary variables: 
		aMethod: 	CarRentalTest>>#testFixedNumberOfCars
		aPackage: 	a RPackage(LifewareHR)
		existingPackage: 	nil
		wasExtension: 	true
		willBeExtension: 	false
	Receiver's instance variables: 
		methods: 	{CarRentalTest>>#testFixedNumberOfCars}
		targetTagName: 	nil


[ :each | 
classPackage := each origin package.
self moveMethod: each toPackage: classPackage.
each tagWith: targetTagName ] in SycMoveMethodsToClassPackageCommand>>execute
	Receiver: a SycMoveMethodsToClassPackageCommand
	Arguments and temporary variables: 
		classPackage: 	a RPackage(LifewareHR)
		each: 	CarRentalTest>>#testFixedNumberOfCars
	Receiver's instance variables: 
		methods: 	{CarRentalTest>>#testFixedNumberOfCars}
		targetTagName: 	nil


Array(SequenceableCollection)>>do:
	Receiver: {CarRentalTest>>#testFixedNumberOfCars}
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
classPackage := each origin package.
self moveMethod: each t...etc...
		index: 	1
	Receiver's instance variables: 
{CarRentalTest>>#testFixedNumberOfCars}

SycMoveMethodsToClassPackageCommand>>execute
	Receiver: a SycMoveMethodsToClassPackageCommand
	Arguments and temporary variables: 
		classPackage: 	a RPackage(LifewareHR)
	Receiver's instance variables: 
		methods: 	{CarRentalTest>>#testFixedNumberOfCars}
		targetTagName: 	nil


[ (extendingPackage notNil
	and: [ aMethod package ~~ extendingPackage ])
	ifTrue: [ ^ (SycMoveMethodsToPackageCommand
			for: {aMethod}
			to: extendingPackage) execute ].
(extendingPackage isNil and: [ aMethod isExtension ])
	ifTrue:
		[ (SycMoveMethodsToClassPackageCommand for: {aMethod}) execute ] ] in ClyMethodCodeEditorToolMorph(ClyMethodEditorToolMorph)>>packageEditingMethod:
	Receiver: a ClyMethodCodeEditorToolMorph(253204992)
	Arguments and temporary variables: 
		aMethod: 	CarRentalTest>>#testFixedNumberOfCars
	Receiver's instance variables: 
		bounds: 	(980.0@781.0) corner: (1838.0@1098.0)
		owner: 	a Morph(916663552)
		submorphs: 	an Array(a PanelMorph(406947584))
		fullBounds: 	(980@781) corner: (1838@1098)
		color: 	Color transparent
		extension: 	a MorphExtension (160179712) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(997427712)
		context: 	a ClyMethodContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(744191488)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(405464576)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(710059520)
		changesCancelRequested: 	false
		applyingChanges: 	true
		methodTags: 	#()
		extendingPackage: 	nil
		targetClasses: 	{CarRentalTest}
		editingMethod: 	CarRentalTest>>#testFixedNumberOfCars


BlockClosure>>ensure:
	Receiver: [ (extendingPackage notNil
	and: [ aMethod package ~~ extendingPackage ])
	ifTrue: [ ^ (Sy...etc...
	Arguments and temporary variables: 
		aBlock: 	[ applyingChanges := false ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyMethodCodeEditorToolMorph(ClyMethodEditorToolMorph)>>packageEd...etc...
		startpc: 	127
		numArgs: 	0


ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
	Receiver: a ClyMethodCodeEditorToolMorph(253204992)
	Arguments and temporary variables: 
		aBlock: 	[ (extendingPackage notNil
	and: [ aMethod package ~~ extendingPackage ...etc...
	Receiver's instance variables: 
		bounds: 	(980.0@781.0) corner: (1838.0@1098.0)
		owner: 	a Morph(916663552)
		submorphs: 	an Array(a PanelMorph(406947584))
		fullBounds: 	(980@781) corner: (1838@1098)
		color: 	Color transparent
		extension: 	a MorphExtension (160179712) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(997427712)
		context: 	a ClyMethodContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(744191488)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(405464576)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(710059520)
		changesCancelRequested: 	false
		applyingChanges: 	true
		methodTags: 	#()
		extendingPackage: 	nil
		targetClasses: 	{CarRentalTest}
		editingMethod: 	CarRentalTest>>#testFixedNumberOfCars


ClyMethodCodeEditorToolMorph(ClyMethodEditorToolMorph)>>packageEditingMethod:
	Receiver: a ClyMethodCodeEditorToolMorph(253204992)
	Arguments and temporary variables: 
		aMethod: 	CarRentalTest>>#testFixedNumberOfCars
	Receiver's instance variables: 
		bounds: 	(980.0@781.0) corner: (1838.0@1098.0)
		owner: 	a Morph(916663552)
		submorphs: 	an Array(a PanelMorph(406947584))
		fullBounds: 	(980@781) corner: (1838@1098)
		color: 	Color transparent
		extension: 	a MorphExtension (160179712) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(997427712)
		context: 	a ClyMethodContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(744191488)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(405464576)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(710059520)
		changesCancelRequested: 	false
		applyingChanges: 	true
		methodTags: 	#()
		extendingPackage: 	nil
		targetClasses: 	{CarRentalTest}
		editingMethod: 	CarRentalTest>>#testFixedNumberOfCars


ClyMethodCodeEditorToolMorph(ClyMethodEditorToolMorph)>>tagAndPackageEditingMethod:
	Receiver: a ClyMethodCodeEditorToolMorph(253204992)
	Arguments and temporary variables: 
		aMethod: 	CarRentalTest>>#testFixedNumberOfCars
	Receiver's instance variables: 
		bounds: 	(980.0@781.0) corner: (1838.0@1098.0)
		owner: 	a Morph(916663552)
		submorphs: 	an Array(a PanelMorph(406947584))
		fullBounds: 	(980@781) corner: (1838@1098)
		color: 	Color transparent
		extension: 	a MorphExtension (160179712) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(997427712)
		context: 	a ClyMethodContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(744191488)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(405464576)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(710059520)
		changesCancelRequested: 	false
		applyingChanges: 	true
		methodTags: 	#()
		extendingPackage: 	nil
		targetClasses: 	{CarRentalTest}
		editingMethod: 	CarRentalTest>>#testFixedNumberOfCars


ClyMethodCodeEditorToolMorph>>applyChanges
	Receiver: a ClyMethodCodeEditorToolMorph(253204992)
	Arguments and temporary variables: 
		selector: 	#testFixedNumberOfCars
		methodClass: 	CarRentalTest
		currentMethod: 	CarRentalTest>>#testFixedNumberOfCars
	Receiver's instance variables: 
		bounds: 	(980.0@781.0) corner: (1838.0@1098.0)
		owner: 	a Morph(916663552)
		submorphs: 	an Array(a PanelMorph(406947584))
		fullBounds: 	(980@781) corner: (1838@1098)
		color: 	Color transparent
		extension: 	a MorphExtension (160179712) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(997427712)
		context: 	a ClyMethodContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(744191488)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(405464576)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(710059520)
		changesCancelRequested: 	false
		applyingChanges: 	true
		methodTags: 	#()
		extendingPackage: 	nil
		targetClasses: 	{CarRentalTest}
		editingMethod: 	CarRentalTest>>#testFixedNumberOfCars


[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyMethodCodeEditorToolMorph(253204992)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(980.0@781.0) corner: (1838.0@1098.0)
		owner: 	a Morph(916663552)
		submorphs: 	an Array(a PanelMorph(406947584))
		fullBounds: 	(980@781) corner: (1838@1098)
		color: 	Color transparent
		extension: 	a MorphExtension (160179712) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(997427712)
		context: 	a ClyMethodContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(744191488)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(405464576)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(710059520)
		changesCancelRequested: 	false
		applyingChanges: 	true
		methodTags: 	#()
		extendingPackage: 	nil
		targetClasses: 	{CarRentalTest}
		editingMethod: 	CarRentalTest>>#testFixedNumberOfCars


BlockClosure>>on:do:
	Receiver: [ self changesAreAboutApply.
applied := self applyChanges ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :err | 
textModel text: self editingText.
textMorph hasUnaccep...etc...
	Receiver's instance variables: 
		outerContext: 	[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply...etc...
		startpc: 	140
		numArgs: 	0


[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyMethodCodeEditorToolMorph(253204992)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(980.0@781.0) corner: (1838.0@1098.0)
		owner: 	a Morph(916663552)
		submorphs: 	an Array(a PanelMorph(406947584))
		fullBounds: 	(980@781) corner: (1838@1098)
		color: 	Color transparent
		extension: 	a MorphExtension (160179712) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(997427712)
		context: 	a ClyMethodContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(744191488)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(405464576)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(710059520)
		changesCancelRequested: 	false
		applyingChanges: 	true
		methodTags: 	#()
		extendingPackage: 	nil
		targetClasses: 	{CarRentalTest}
		editingMethod: 	CarRentalTest>>#testFixedNumberOfCars


BlockClosure>>ensure:
	Receiver: [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyCh...etc...
	Arguments and temporary variables: 
		aBlock: 	[ applyingChanges := false ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAcce...etc...
		startpc: 	130
		numArgs: 	0


ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
	Receiver: a ClyMethodCodeEditorToolMorph(253204992)
	Arguments and temporary variables: 
		aBlock: 	[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
appl...etc...
	Receiver's instance variables: 
		bounds: 	(980.0@781.0) corner: (1838.0@1098.0)
		owner: 	a Morph(916663552)
		submorphs: 	an Array(a PanelMorph(406947584))
		fullBounds: 	(980@781) corner: (1838@1098)
		color: 	Color transparent
		extension: 	a MorphExtension (160179712) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(997427712)
		context: 	a ClyMethodContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(744191488)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(405464576)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(710059520)
		changesCancelRequested: 	false
		applyingChanges: 	true
		methodTags: 	#()
		extendingPackage: 	nil
		targetClasses: 	{CarRentalTest}
		editingMethod: 	CarRentalTest>>#testFixedNumberOfCars


ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyMethodCodeEditorToolMorph(253204992)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(980.0@781.0) corner: (1838.0@1098.0)
		owner: 	a Morph(916663552)
		submorphs: 	an Array(a PanelMorph(406947584))
		fullBounds: 	(980@781) corner: (1838@1098)
		color: 	Color transparent
		extension: 	a MorphExtension (160179712) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(997427712)
		context: 	a ClyMethodContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(744191488)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(405464576)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(710059520)
		changesCancelRequested: 	false
		applyingChanges: 	true
		methodTags: 	#()
		extendingPackage: 	nil
		targetClasses: 	{CarRentalTest}
		editingMethod: 	CarRentalTest>>#testFixedNumberOfCars


MessageSend>>value
	Receiver: MessageSend(#changesAccepted -> a ClyMethodCodeEditorToolMorph(253204992))
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a ClyMethodCodeEditorToolMorph(253204992)
		selector: 	#changesAccepted
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#changesAccepted -> a ClyMethodCodeEditorToolMorph(253204992))
	Arguments and temporary variables: 
		arg: 	a RubTextAccepted
	Receiver's instance variables: 
		receiver: 	a ClyMethodCodeEditorToolMorph(253204992)
		selector: 	#changesAccepted
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#changesAccepted -> a ClyMethodCodeEditorToolMorph(253204992))
	Arguments and temporary variables: 
		arg1: 	a RubTextAccepted
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a ClyMethodCodeEditorToolMorph(253204992)
		selector: 	#changesAccepted
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAccepted
		subscriber: 	a ClyMethodCodeEditorToolMorph(253204992)
		action: 	MessageSend(#changesAccepted -> a ClyMethodCodeEditorToolMorph(25320499...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	83
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	83
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAccepted
		subscriber: 	a ClyMethodCodeEditorToolMorph(253204992)
		action: 	MessageSend(#changesAccepted -> a ClyMethodCodeEditorToolMorph(25320499...etc...


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	82
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		announcement: 	a RubTextAccepted
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubScrolledTextMorph>>acceptContents
	Receiver: a RubScrolledTextMorph(710059520)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(980.0@781.0) corner: (1838.0@1071.0)
		owner: 	a PanelMorph(406947584)
		submorphs: 	an Array(a RubTextScrollPane(812743424) a RubAdornmentDisplayer(1046...etc...
		fullBounds: 	(980@781) corner: (1838@1071)
		color: 	Color white
		extension: 	a MorphExtension (1026061056) [other:  (announcer -> an Announcer) (...etc...
		hasEditingConflicts: 	false
		hasUnacceptedEdits: 	true
		alwaysAccept: 	nil
		setTextSelector: 	#setText:from:
		getTextSelector: 	#getText
		getSelectionSelector: 	#primarySelectionInterval
		setSelectionSelector: 	nil
		autoAccept: 	false
		scrollPane: 	a RubTextScrollPane(812743424)
		rulers: 	a SortedCollection(a RubTextSegmentIconDisplayer(715550208) a RubAdornm...etc...
		enabled: 	true
		highlights: 	an OrderedCollection()


RubScrolledTextMorph>>whenTextAcceptRequest:
	Receiver: a RubScrolledTextMorph(710059520)
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAcceptRequest
	Receiver's instance variables: 
		bounds: 	(980.0@781.0) corner: (1838.0@1071.0)
		owner: 	a PanelMorph(406947584)
		submorphs: 	an Array(a RubTextScrollPane(812743424) a RubAdornmentDisplayer(1046...etc...
		fullBounds: 	(980@781) corner: (1838@1071)
		color: 	Color white
		extension: 	a MorphExtension (1026061056) [other:  (announcer -> an Announcer) (...etc...
		hasEditingConflicts: 	false
		hasUnacceptedEdits: 	true
		alwaysAccept: 	nil
		setTextSelector: 	#setText:from:
		getTextSelector: 	#getText
		getSelectionSelector: 	#primarySelectionInterval
		setSelectionSelector: 	nil
		autoAccept: 	false
		scrollPane: 	a RubTextScrollPane(812743424)
		rulers: 	a SortedCollection(a RubTextSegmentIconDisplayer(715550208) a RubAdornm...etc...
		enabled: 	true
		highlights: 	an OrderedCollection()


MessageSend>>value:
	Receiver: MessageSend(#whenTextAcceptRequest: -> a RubScrolledTextMorph(710059520))
	Arguments and temporary variables: 
		anObject: 	a RubTextAcceptRequest
	Receiver's instance variables: 
		receiver: 	a RubScrolledTextMorph(710059520)
		selector: 	#whenTextAcceptRequest:
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#whenTextAcceptRequest: -> a RubScrolledTextMorph(710059520))
	Arguments and temporary variables: 
		arg: 	a RubTextAcceptRequest
	Receiver's instance variables: 
		receiver: 	a RubScrolledTextMorph(710059520)
		selector: 	#whenTextAcceptRequest:
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#whenTextAcceptRequest: -> a RubScrolledTextMorph(710059520))
	Arguments and temporary variables: 
		arg1: 	a RubTextAcceptRequest
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a RubScrolledTextMorph(710059520)
		selector: 	#whenTextAcceptRequest:
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAcceptRequest
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAcceptRequest
		subscriber: 	a RubScrolledTextMorph(710059520)
		action: 	MessageSend(#whenTextAcceptRequest: -> a RubScrolledTextMorph(710059520...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	83
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	83
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAcceptRequest
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAcceptRequest
		subscriber: 	a RubScrolledTextMorph(710059520)
		action: 	MessageSend(#whenTextAcceptRequest: -> a RubScrolledTextMorph(710059520...etc...



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #name
SycMoveMethodsToClassPackageCommand(SycMethodRepackagingCommand)>>moveMethod:toPackage:
[ :each | 
classPackage := each origin package.
self moveMethod: each toPackage: classPackage.
each tagWith: targetTagName ] in SycMoveMethodsToClassPackageCommand>>execute
Array(SequenceableCollection)>>do:
SycMoveMethodsToClassPackageCommand>>execute
[ (extendingPackage notNil
	and: [ aMethod package ~~ extendingPackage ])
	ifTrue: [ ^ (SycMoveMethodsToPackageCommand
			for: {aMethod}
			to: extendingPackage) execute ].
(extendingPackage isNil and: [ aMethod isExtension ])
	ifTrue:
		[ (SycMoveMethodsToClassPackageCommand for: {aMethod}) execute ] ] in ClyMethodCodeEditorToolMorph(ClyMethodEditorToolMorph)>>packageEditingMethod:
BlockClosure>>ensure:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyMethodCodeEditorToolMorph(ClyMethodEditorToolMorph)>>packageEditingMethod:
ClyMethodCodeEditorToolMorph(ClyMethodEditorToolMorph)>>tagAndPackageEditingMethod:
ClyMethodCodeEditorToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
BlockClosure>>ensure:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubScrolledTextMorph>>acceptContents
RubScrolledTextMorph>>whenTextAcceptRequest:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(RubAbstractTextArea)>>announce:
RubEditingArea(RubAbstractTextArea)>>acceptContents
ClyTextEditor(RubTextEditor)>>accept
[ :target | target editor accept ] in RubTextEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
OrderedCollection>>do:
CmdKMDispatcher(KMDispatcher)>>dispatch:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#isReturnSpecial was sent to nil
19 June 2019 11:53:44.296055 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #isReturnSpecial
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	isReturnSpecial
		exception: 	MessageNotUnderstood: receiver of "isReturnSpecial" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

ClyTextEditor(RubSmalltalkEditor)>>debug:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		method: 	nil
		receiver: 	CarRentalTest
		context: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(501953280)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>debugSelection
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(501953280)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>debugIt
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(501953280)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubEditingArea(Object)>>perform:orSendTo:
	Receiver: a RubEditingArea(501953280)
	Arguments and temporary variables: 
		selector: 	#debugIt
		otherTarget: 	a ClyTextEditor
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (839@221)
		owner: 	a TransformWithLayoutMorph(1014083072)
		submorphs: 	an Array(a RubCursor(51045888) a RubPrimarySelectionMorph(125987328)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (53371648) [other:  (announcer -> an Announcer) (km...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(193445632)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(51045888)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501953280)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(1028629248)'Debug it'
	Arguments and temporary variables: 
		evt: 	[(1164@880) mouseUp 12143248 nil]
		w: 	a WorldMorph(275485952) [world]
		selArgCount: 	2
	Receiver's instance variables: 
		bounds: 	(1086.0@867.0) corner: (1285.0@885.0)
		owner: 	a MenuMorph(497712896)
		submorphs: 	#()
		fullBounds: 	(1086.0@867.0) corner: (1285.0@885.0)
		color: 	Color black
		extension: 	a MorphExtension (443940352)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a RubEditingArea(501953280)
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#debugIt a ClyTextEditor)
		icon: 	Form(16x16x32)
		keyText: 	'D'
		getStateSelector: 	nil
		enablementSelector: 	nil


BlockClosure>>ensure:
	Receiver: [ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := select...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	230
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |
"show cursor in case item opens a new MVC window"
(se...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(1028629248)'Debug it'
	Arguments and temporary variables: 
		evt: 	[(1164@880) mouseUp 12143248 nil]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(1086.0@867.0) corner: (1285.0@885.0)
		owner: 	a MenuMorph(497712896)
		submorphs: 	#()
		fullBounds: 	(1086.0@867.0) corner: (1285.0@885.0)
		color: 	Color black
		extension: 	a MorphExtension (443940352)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a RubEditingArea(501953280)
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#debugIt a ClyTextEditor)
		icon: 	Form(16x16x32)
		keyText: 	'D'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(1028629248)'Debug it'
	Arguments and temporary variables: 
		evt: 	[(1164@880) mouseUp 12143248 nil]
	Receiver's instance variables: 
		bounds: 	(1086.0@867.0) corner: (1285.0@885.0)
		owner: 	a MenuMorph(497712896)
		submorphs: 	#()
		fullBounds: 	(1086.0@867.0) corner: (1285.0@885.0)
		color: 	Color black
		extension: 	a MorphExtension (443940352)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a RubEditingArea(501953280)
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#debugIt a ClyTextEditor)
		icon: 	Form(16x16x32)
		keyText: 	'D'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(1028629248)'Debug it'
	Arguments and temporary variables: 
		anEvent: 	[(1164@880) mouseUp 12143248 nil]
	Receiver's instance variables: 
		bounds: 	(1086.0@867.0) corner: (1285.0@885.0)
		owner: 	a MenuMorph(497712896)
		submorphs: 	#()
		fullBounds: 	(1086.0@867.0) corner: (1285.0@885.0)
		color: 	Color black
		extension: 	a MorphExtension (443940352)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a RubEditingArea(501953280)
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#debugIt a ClyTextEditor)
		icon: 	Form(16x16x32)
		keyText: 	'D'
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1164@880) mouseUp 12143248 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(1028629248)'Debug it'
	Receiver's instance variables: 
		timeStamp: 	12143248
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1164@880)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(1028629248)'Debug it'
	Arguments and temporary variables: 
		anEvent: 	[(1164@880) mouseUp 12143248 nil]
	Receiver's instance variables: 
		bounds: 	(1086.0@867.0) corner: (1285.0@885.0)
		owner: 	a MenuMorph(497712896)
		submorphs: 	#()
		fullBounds: 	(1086.0@867.0) corner: (1285.0@885.0)
		color: 	Color black
		extension: 	a MorphExtension (443940352)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a RubEditingArea(501953280)
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#debugIt a ClyTextEditor)
		icon: 	Form(16x16x32)
		keyText: 	'D'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1164@880) mouseUp 12143248 nil]
		aMorph: 	a ToggleMenuItemMorph(1028629248)'Debug it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(1028629248)'Debug it'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1164@880) mouseUp 12143248 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(1028629248)'Debug it'


MouseButtonEvent>>sentTo:
	Receiver: [(1164@880) mouseUp 12143248 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	12143248
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1164@880)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1164@880) mouseUp 12143248 nil]
		aMorph: 	a ToggleMenuItemMorph(1028629248)'Debug it'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(1028629248)'Debug it'


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1164@880) mouseUp 12143248 nil]
		aMorph: 	a ToggleMenuItemMorph(1028629248)'Debug it'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(1028629248)'Debug it'


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(1028629248)'Debug it'
	Arguments and temporary variables: 
		anEvent: 	[(1164@880) mouseUp 12143248 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(1086.0@867.0) corner: (1285.0@885.0)
		owner: 	a MenuMorph(497712896)
		submorphs: 	#()
		fullBounds: 	(1086.0@867.0) corner: (1285.0@885.0)
		color: 	Color black
		extension: 	a MorphExtension (443940352)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a RubEditingArea(501953280)
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#debugIt a ClyTextEditor)
		icon: 	Form(16x16x32)
		keyText: 	'D'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1164@880) mouseUp 12143248 nil]
		aMorph: 	a MenuMorph(497712896)
		localEvt: 	[(1164@880) mouseUp 12143248 nil]
		index: 	8
		child: 	a ToggleMenuItemMorph(1028629248)'Debug it'
		morphs: 	an Array(a ToggleMenuItemMorph(950529792)'Source code' a MenuLineMorph(...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(1028629248)'Debug it'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1164@880) mouseUp 12143248 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(1028629248)'Debug it'


MouseButtonEvent>>sentTo:
	Receiver: [(1164@880) mouseUp 12143248 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	12143248
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1164@880)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1164@880) mouseUp 12143248 nil]
		aMorph: 	a MenuMorph(497712896)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(1028629248)'Debug it'


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1164@880) mouseUp 12143248 nil]
		aMorph: 	a MenuMorph(497712896)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(1028629248)'Debug it'


MenuMorph(Morph)>>processEvent:using:
	Receiver: a MenuMorph(497712896)
	Arguments and temporary variables: 
		anEvent: 	[(1164@880) mouseUp 12143248 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(1081.0@747.0) corner: (1290.0@1128.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(950529792)'Source code' a MenuLineMor...etc...
		fullBounds: 	(1081.0@747.0) corner: (1290.0@1128.0)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (567065344) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(1028629248)'Debug it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	nil


MenuMorph(Morph)>>processEvent:
	Receiver: a MenuMorph(497712896)
	Arguments and temporary variables: 
		anEvent: 	[(1164@880) mouseUp 12143248 nil]
	Receiver's instance variables: 
		bounds: 	(1081.0@747.0) corner: (1290.0@1128.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(950529792)'Source code' a MenuLineMor...etc...
		fullBounds: 	(1081.0@747.0) corner: (1290.0@1128.0)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (567065344) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(1028629248)'Debug it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	nil


MenuMorph>>handleFocusEvent:
	Receiver: a MenuMorph(497712896)
	Arguments and temporary variables: 
		evt: 	[(1164@880) mouseUp 12143248 nil]
	Receiver's instance variables: 
		bounds: 	(1081.0@747.0) corner: (1290.0@1128.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(950529792)'Source code' a MenuLineMor...etc...
		fullBounds: 	(1081.0@747.0) corner: (1290.0@1128.0)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (567065344) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(1028629248)'Debug it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	nil


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(1164@880) mouseUp 12143248 nil]
		focusHolder: 	a MenuMorph(497712896)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1164@880.0) corner: (1180@896.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1164@880.0) corner: (1180@896.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1164@880) mouseUp 12143248 nil]
		targetOffset: 	(78.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12143248 1164 880 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	[(1164@880) mouseOver red 12143152 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1164@880) mouseUp 12143248 nil]
		focusHolder: 	a MenuMorph(497712896)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(1164@880.0) corner: (1180@896.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1164@880.0) corner: (1180@896.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1164@880) mouseUp 12143248 nil]
		targetOffset: 	(78.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12143248 1164 880 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(1164@880) mouseUp 12143248 nil]
		focusHolder: 	a MenuMorph(497712896)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1164@880.0) corner: (1180@896.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1164@880.0) corner: (1180@896.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1164@880) mouseUp 12143248 nil]
		targetOffset: 	(78.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12143248 1164 880 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(1164@880) mouseUp 12143248 nil]
	Receiver's instance variables: 
		bounds: 	(1164@880.0) corner: (1180@896.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1164@880.0) corner: (1180@896.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1164@880) mouseUp 12143248 nil]
		targetOffset: 	(78.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12143248 1164 880 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(1164@880) mouseUp 12143248 nil]
		evt: 	[(1164@880) mouseUp 12143248 nil]
	Receiver's instance variables: 
		bounds: 	(1164@880.0) corner: (1180@896.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1164@880.0) corner: (1180@896.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1164@880) mouseUp 12143248 nil]
		targetOffset: 	(78.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12143248 1164 880 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEventsFromQueue:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEventQueue: 	an InputEventSensor
		evt: 	[(1164@880) mouseUp 12143248 nil]
		evtBuf: 	#(1 12143248 1164 880 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1164@880.0) corner: (1180@896.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1164@880.0) corner: (1180@896.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1164@880) mouseUp 12143248 nil]
		targetOffset: 	(78.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12143248 1164 880 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(1164@880.0) corner: (1180@896.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1164@880.0) corner: (1180@896.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1164@880) mouseUp 12143248 nil]
		targetOffset: 	(78.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12143248 1164 880 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		h: 	a HandMorph(810749440)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	12143203
		lastStepMessage: 	nil
		lastCycleTime: 	12143248
		alarms: 	a Heap()
		lastAlarmTime: 	12143203
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #isReturnSpecial
ClyTextEditor(RubSmalltalkEditor)>>debug:
ClyTextEditor(RubSmalltalkEditor)>>debugSelection
ClyTextEditor(RubSmalltalkEditor)>>debugIt
RubEditingArea(Object)>>perform:orSendTo:
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldState>>doOneSubCycleFor:
WorldMorph>>doOneSubCycle
MenuMorph>>invokeModalAt:in:allowKeyboard:
MenuMorph>>invokeModal:
MenuMorph>>invokeModal
RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
RubEditingArea(RubAbstractTextArea)>>mouseDown:
RubEditingArea(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubEditingArea(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubTextScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubScrolledTextMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ClyMethodCodeEditorToolMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TabManagerMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ClyFullBrowser(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SystemWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#isReturnSpecial was sent to nil
19 June 2019 11:53:57.653893 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #isReturnSpecial
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	isReturnSpecial
		exception: 	MessageNotUnderstood: receiver of "isReturnSpecial" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

ClyTextEditor(RubSmalltalkEditor)>>debug:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		method: 	nil
		receiver: 	CarRentalTest
		context: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501953280)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>debugSelection
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501953280)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>debugIt
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501953280)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubEditingArea(Object)>>perform:orSendTo:
	Receiver: a RubEditingArea(501953280)
	Arguments and temporary variables: 
		selector: 	#debugIt
		otherTarget: 	a ClyTextEditor
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (839@221)
		owner: 	a TransformWithLayoutMorph(1014083072)
		submorphs: 	an Array(a RubCursor(51045888) a RubPrimarySelectionMorph(125987328)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (53371648) [other:  (announcer -> an Announcer) (km...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(193445632)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(51045888)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501953280)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(72986112)'Debug it'
	Arguments and temporary variables: 
		evt: 	[(1132@873) mouseUp 12156610 nil]
		w: 	a WorldMorph(275485952) [world]
		selArgCount: 	2
	Receiver's instance variables: 
		bounds: 	(1070.0@867.0) corner: (1269.0@885.0)
		owner: 	a MenuMorph(722197248)
		submorphs: 	#()
		fullBounds: 	(1070.0@867.0) corner: (1269.0@885.0)
		color: 	Color black
		extension: 	a MorphExtension (109634304)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a RubEditingArea(501953280)
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#debugIt a ClyTextEditor)
		icon: 	Form(16x16x32)
		keyText: 	'D'
		getStateSelector: 	nil
		enablementSelector: 	nil


BlockClosure>>ensure:
	Receiver: [ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := select...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	230
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |
"show cursor in case item opens a new MVC window"
(se...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(72986112)'Debug it'
	Arguments and temporary variables: 
		evt: 	[(1132@873) mouseUp 12156610 nil]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(1070.0@867.0) corner: (1269.0@885.0)
		owner: 	a MenuMorph(722197248)
		submorphs: 	#()
		fullBounds: 	(1070.0@867.0) corner: (1269.0@885.0)
		color: 	Color black
		extension: 	a MorphExtension (109634304)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a RubEditingArea(501953280)
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#debugIt a ClyTextEditor)
		icon: 	Form(16x16x32)
		keyText: 	'D'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(72986112)'Debug it'
	Arguments and temporary variables: 
		evt: 	[(1132@873) mouseUp 12156610 nil]
	Receiver's instance variables: 
		bounds: 	(1070.0@867.0) corner: (1269.0@885.0)
		owner: 	a MenuMorph(722197248)
		submorphs: 	#()
		fullBounds: 	(1070.0@867.0) corner: (1269.0@885.0)
		color: 	Color black
		extension: 	a MorphExtension (109634304)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a RubEditingArea(501953280)
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#debugIt a ClyTextEditor)
		icon: 	Form(16x16x32)
		keyText: 	'D'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(72986112)'Debug it'
	Arguments and temporary variables: 
		anEvent: 	[(1132@873) mouseUp 12156610 nil]
	Receiver's instance variables: 
		bounds: 	(1070.0@867.0) corner: (1269.0@885.0)
		owner: 	a MenuMorph(722197248)
		submorphs: 	#()
		fullBounds: 	(1070.0@867.0) corner: (1269.0@885.0)
		color: 	Color black
		extension: 	a MorphExtension (109634304)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a RubEditingArea(501953280)
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#debugIt a ClyTextEditor)
		icon: 	Form(16x16x32)
		keyText: 	'D'
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1132@873) mouseUp 12156610 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(72986112)'Debug it'
	Receiver's instance variables: 
		timeStamp: 	12156610
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1132@873)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(72986112)'Debug it'
	Arguments and temporary variables: 
		anEvent: 	[(1132@873) mouseUp 12156610 nil]
	Receiver's instance variables: 
		bounds: 	(1070.0@867.0) corner: (1269.0@885.0)
		owner: 	a MenuMorph(722197248)
		submorphs: 	#()
		fullBounds: 	(1070.0@867.0) corner: (1269.0@885.0)
		color: 	Color black
		extension: 	a MorphExtension (109634304)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a RubEditingArea(501953280)
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#debugIt a ClyTextEditor)
		icon: 	Form(16x16x32)
		keyText: 	'D'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1132@873) mouseUp 12156610 nil]
		aMorph: 	a ToggleMenuItemMorph(72986112)'Debug it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(72986112)'Debug it'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1132@873) mouseUp 12156610 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(72986112)'Debug it'


MouseButtonEvent>>sentTo:
	Receiver: [(1132@873) mouseUp 12156610 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	12156610
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1132@873)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1132@873) mouseUp 12156610 nil]
		aMorph: 	a ToggleMenuItemMorph(72986112)'Debug it'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(72986112)'Debug it'


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1132@873) mouseUp 12156610 nil]
		aMorph: 	a ToggleMenuItemMorph(72986112)'Debug it'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(72986112)'Debug it'


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(72986112)'Debug it'
	Arguments and temporary variables: 
		anEvent: 	[(1132@873) mouseUp 12156610 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(1070.0@867.0) corner: (1269.0@885.0)
		owner: 	a MenuMorph(722197248)
		submorphs: 	#()
		fullBounds: 	(1070.0@867.0) corner: (1269.0@885.0)
		color: 	Color black
		extension: 	a MorphExtension (109634304)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a RubEditingArea(501953280)
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#debugIt a ClyTextEditor)
		icon: 	Form(16x16x32)
		keyText: 	'D'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1132@873) mouseUp 12156610 nil]
		aMorph: 	a MenuMorph(722197248)
		localEvt: 	[(1132@873) mouseUp 12156610 nil]
		index: 	8
		child: 	a ToggleMenuItemMorph(72986112)'Debug it'
		morphs: 	an Array(a ToggleMenuItemMorph(83852800)'Source code' a MenuLineMorph(5...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(72986112)'Debug it'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1132@873) mouseUp 12156610 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(72986112)'Debug it'


MouseButtonEvent>>sentTo:
	Receiver: [(1132@873) mouseUp 12156610 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	12156610
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1132@873)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1132@873) mouseUp 12156610 nil]
		aMorph: 	a MenuMorph(722197248)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(72986112)'Debug it'


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1132@873) mouseUp 12156610 nil]
		aMorph: 	a MenuMorph(722197248)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(72986112)'Debug it'


MenuMorph(Morph)>>processEvent:using:
	Receiver: a MenuMorph(722197248)
	Arguments and temporary variables: 
		anEvent: 	[(1132@873) mouseUp 12156610 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(1065.0@747.0) corner: (1274.0@1128.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(83852800)'Source code' a MenuLineMorp...etc...
		fullBounds: 	(1065.0@747.0) corner: (1274.0@1128.0)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (196989440) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(72986112)'Debug it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	nil


MenuMorph(Morph)>>processEvent:
	Receiver: a MenuMorph(722197248)
	Arguments and temporary variables: 
		anEvent: 	[(1132@873) mouseUp 12156610 nil]
	Receiver's instance variables: 
		bounds: 	(1065.0@747.0) corner: (1274.0@1128.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(83852800)'Source code' a MenuLineMorp...etc...
		fullBounds: 	(1065.0@747.0) corner: (1274.0@1128.0)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (196989440) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(72986112)'Debug it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	nil


MenuMorph>>handleFocusEvent:
	Receiver: a MenuMorph(722197248)
	Arguments and temporary variables: 
		evt: 	[(1132@873) mouseUp 12156610 nil]
	Receiver's instance variables: 
		bounds: 	(1065.0@747.0) corner: (1274.0@1128.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(83852800)'Source code' a MenuLineMorp...etc...
		fullBounds: 	(1065.0@747.0) corner: (1274.0@1128.0)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (196989440) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(72986112)'Debug it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	nil


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(1132@873) mouseUp 12156610 nil]
		focusHolder: 	a MenuMorph(722197248)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1132@873.0) corner: (1148@889.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1132@873.0) corner: (1148@889.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1132@873) mouseUp 12156610 nil]
		targetOffset: 	(62.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12156610 1132 873 0 0 0 1)
		lastKeyScanCode: 	8
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	[(1132@873) mouseOver red 12156532 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(1132@873) mouseUp 12156610 nil]
		focusHolder: 	a MenuMorph(722197248)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(1132@873.0) corner: (1148@889.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1132@873.0) corner: (1148@889.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1132@873) mouseUp 12156610 nil]
		targetOffset: 	(62.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12156610 1132 873 0 0 0 1)
		lastKeyScanCode: 	8
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(1132@873) mouseUp 12156610 nil]
		focusHolder: 	a MenuMorph(722197248)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1132@873.0) corner: (1148@889.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1132@873.0) corner: (1148@889.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1132@873) mouseUp 12156610 nil]
		targetOffset: 	(62.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12156610 1132 873 0 0 0 1)
		lastKeyScanCode: 	8
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(1132@873) mouseUp 12156610 nil]
	Receiver's instance variables: 
		bounds: 	(1132@873.0) corner: (1148@889.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1132@873.0) corner: (1148@889.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1132@873) mouseUp 12156610 nil]
		targetOffset: 	(62.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12156610 1132 873 0 0 0 1)
		lastKeyScanCode: 	8
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(1132@873) mouseUp 12156610 nil]
		evt: 	[(1132@873) mouseUp 12156610 nil]
	Receiver's instance variables: 
		bounds: 	(1132@873.0) corner: (1148@889.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1132@873.0) corner: (1148@889.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1132@873) mouseUp 12156610 nil]
		targetOffset: 	(62.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12156610 1132 873 0 0 0 1)
		lastKeyScanCode: 	8
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEventsFromQueue:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEventQueue: 	an InputEventSensor
		evt: 	[(1132@873) mouseUp 12156610 nil]
		evtBuf: 	#(1 12156610 1132 873 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(1132@873.0) corner: (1148@889.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1132@873.0) corner: (1148@889.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1132@873) mouseUp 12156610 nil]
		targetOffset: 	(62.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12156610 1132 873 0 0 0 1)
		lastKeyScanCode: 	8
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(1132@873.0) corner: (1148@889.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1132@873.0) corner: (1148@889.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1132@873) mouseUp 12156610 nil]
		targetOffset: 	(62.0@6.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 12156610 1132 873 0 0 0 1)
		lastKeyScanCode: 	8
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		h: 	a HandMorph(810749440)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	12156581
		lastStepMessage: 	nil
		lastCycleTime: 	12156610
		alarms: 	a Heap()
		lastAlarmTime: 	12156581
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #isReturnSpecial
ClyTextEditor(RubSmalltalkEditor)>>debug:
ClyTextEditor(RubSmalltalkEditor)>>debugSelection
ClyTextEditor(RubSmalltalkEditor)>>debugIt
RubEditingArea(Object)>>perform:orSendTo:
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldState>>doOneSubCycleFor:
WorldMorph>>doOneSubCycle
MenuMorph>>invokeModalAt:in:allowKeyboard:
MenuMorph>>invokeModal:
MenuMorph>>invokeModal
RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
RubEditingArea(RubAbstractTextArea)>>mouseDown:
RubEditingArea(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubEditingArea(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubTextScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubScrolledTextMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ClyMethodCodeEditorToolMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TabManagerMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ClyFullBrowser(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SystemWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Instances of SmallInteger are not indexable
19 June 2019 11:56:38.248699 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SmallInteger(Object)>>error:
	Receiver: 1
	Arguments and temporary variables: 
		aString: 	'Instances of SmallInteger are not indexable'
	Receiver's instance variables: 
1

SmallInteger(Object)>>errorNotIndexable
	Receiver: 1
	Arguments and temporary variables: 

	Receiver's instance variables: 
1

SmallInteger(Object)>>size
	Receiver: 1
	Arguments and temporary variables: 

	Receiver's instance variables: 
1

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ OrderedCollection add: 1 size
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	12317178
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	12317217
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	12317178
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	12317217
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	12317167
		lastStepMessage: 	nil
		lastCycleTime: 	12317217
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	12317167
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	12317217
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	12317167
		lastStepMessage: 	nil
		lastCycleTime: 	12317217
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	12317167
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	12317167
		lastStepMessage: 	nil
		lastCycleTime: 	12317217
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	12317167
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	12317167
		lastStepMessage: 	nil
		lastCycleTime: 	12317217
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	12317167
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	12317167
		lastStepMessage: 	nil
		lastCycleTime: 	12317217
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	12317167
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Instances of SmallInteger are not indexable
19 June 2019 11:56:48.653793 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SmallInteger(Object)>>error:
	Receiver: 1
	Arguments and temporary variables: 
		aString: 	'Instances of SmallInteger are not indexable'
	Receiver's instance variables: 
1

SmallInteger(Object)>>errorNotIndexable
	Receiver: 1
	Arguments and temporary variables: 

	Receiver's instance variables: 
1

SmallInteger(Object)>>size
	Receiver: 1
	Arguments and temporary variables: 

	Receiver's instance variables: 
1

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ OrderedCollection new add: 1 size
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	12327622
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	12327624
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	12327622
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	12327624
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	12327574
		lastStepMessage: 	nil
		lastCycleTime: 	12327624
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	12327574
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	12327624
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	12327574
		lastStepMessage: 	nil
		lastCycleTime: 	12327624
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	12327574
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	12327574
		lastStepMessage: 	nil
		lastCycleTime: 	12327624
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	12327574
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	12327574
		lastStepMessage: 	nil
		lastCycleTime: 	12327624
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	12327574
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	12327574
		lastStepMessage: 	nil
		lastCycleTime: 	12327624
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	12327574
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of OrderedCollection class did not understand #add:
19 June 2019 11:57:17.151026 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

OrderedCollection class(Object)>>doesNotUnderstand: #add:
	Receiver: OrderedCollection
	Arguments and temporary variables: 
		aMessage: 	add: 1
		exception: 	MessageNotUnderstood: OrderedCollection class>>add:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	SequenceableCollection
		methodDict: 	a MethodDictionary(#add:->OrderedCollection>>#add: #add:after:->Ord...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ObjectFinalizerCollection. SortedCollection. WeakOrderedCollection...etc...
		name: 	#OrderedCollection
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Collections-Sequenceable-Ordered'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ OrderedCollection
		new;
		add: 1;
		size
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	12356119
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	12356121
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	12356119
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	12356121
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	12356069
		lastStepMessage: 	nil
		lastCycleTime: 	12356121
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	12356069
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	12356121
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	12356069
		lastStepMessage: 	nil
		lastCycleTime: 	12356121
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	12356069
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	12356069
		lastStepMessage: 	nil
		lastCycleTime: 	12356121
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	12356069
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	12356069
		lastStepMessage: 	nil
		lastCycleTime: 	12356121
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	12356069
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	12356069
		lastStepMessage: 	nil
		lastCycleTime: 	12356121
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	12356069
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
OrderedCollection class(Object)>>doesNotUnderstand: #add:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Car class did not understand #type:
20 June 2019 12:07:42.87109 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Car class(Object)>>doesNotUnderstand: #type:
	Receiver: Car
	Arguments and temporary variables: 
		aMessage: 	type: 'golf'
		exception: 	MessageNotUnderstood: Car class>>type:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#price->Car>>#price #price:->Car>>#price: #setPr...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	#()
		name: 	#Car
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Core'


Car class>>golf
	Receiver: Car
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#price->Car>>#price #price:->Car>>#price: #setPr...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	#()
		name: 	#Car
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Core'


CarRentalTest class>>DoIt
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		carRental: 	a CarRental
		myGolf: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testDiscountedPrice #testRen...etc...


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| carRental myGolf |
	carRental := CarRental new.
	^ myGolf := Car g...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	CarRentalTest
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	CarRentalTest
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(185116928)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(185116928)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>evaluateSelection
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(185116928)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>doIt
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(185116928)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>doIt:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(185116928)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(185116928)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(185116928)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(185116928)
		secondArg: 	a RubEditingArea(185116928)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(185116928)
		secondArg: 	a RubEditingArea(185116928)
		thirdArg: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(185116928)
		category: 	a KMCategory
		morph: 	a RubEditingArea(185116928)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	18
		each: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aListener: 	a CmdKMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(185116928)
		category: 	a KMCategory
		morph: 	a RubEditingArea(185116928)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a RubEditingArea(185116928)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(547465216)


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	4
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	4


CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a RubEditingArea(185116928)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(547465216)


CmdKMDispatcher>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		executed: 	false
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		context: 	a ClySourceCodeContext
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a RubEditingArea(185116928)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(547465216)


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(185116928)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a RubEditingArea(185116928)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(547465216)


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(185116928)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (839@183)
		owner: 	a TransformWithLayoutMorph(633640448)
		submorphs: 	an Array(a RubCursor(895038208) a RubPrimarySelectionMorph(860907264...etc...
		fullBounds: 	(0@0) corner: (839@183)
		color: 	Color transparent
		extension: 	a MorphExtension (600803328) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(226556928)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(895038208)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(185116928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (839@183)
		owner: 	a TransformWithLayoutMorph(633640448)
		submorphs: 	an Array(a RubCursor(895038208) a RubPrimarySelectionMorph(860907264...etc...
		fullBounds: 	(0@0) corner: (839@183)
		color: 	Color transparent
		extension: 	a MorphExtension (600803328) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(226556928)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(895038208)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-d>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(185116928)
	Receiver's instance variables: 
		timeStamp: 	1836801
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(186@150.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	100


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(185116928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (839@183)
		owner: 	a TransformWithLayoutMorph(633640448)
		submorphs: 	an Array(a RubCursor(895038208) a RubPrimarySelectionMorph(860907264...etc...
		fullBounds: 	(0@0) corner: (839@183)
		color: 	Color transparent
		extension: 	a MorphExtension (600803328) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(226556928)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(895038208)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(185116928)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (839@183)
		owner: 	a TransformWithLayoutMorph(633640448)
		submorphs: 	an Array(a RubCursor(895038208) a RubPrimarySelectionMorph(860907264...etc...
		fullBounds: 	(0@0) corner: (839@183)
		color: 	Color transparent
		extension: 	a MorphExtension (600803328) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(226556928)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(895038208)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a RubEditingArea(185116928)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1177@885.0) corner: (1193@901.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1177@885.0) corner: (1193@901.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(185116928)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1185@894) mouseOver 1836514 nil]
		targetOffset: 	(30@107)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1836514 1185 894 0 0 0 1)
		lastKeyScanCode: 	100
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil



--- The full stack ---
Car class(Object)>>doesNotUnderstand: #type:
Car class>>golf
CarRentalTest class>>DoIt
OpalCompiler>>evaluate
ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
ClyTextEditor(RubSmalltalkEditor)>>evaluateSelection
ClyTextEditor(RubSmalltalkEditor)>>doIt
ClyTextEditor(RubSmalltalkEditor)>>doIt:
[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
OrderedCollection>>do:
CmdKMDispatcher(KMDispatcher)>>dispatch:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
InvalidGlobalName: NameOfSubclass: Class name is not a valid global name. It must start with uppercase letter and continue with alphanumeric characters or underscore. Default names used in class or trait templates are not allowed.
20 June 2019 12:18:37.967805 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

ShiftClassBuilder>>validateClassName
	Receiver: a ShiftClassBuilder
	Arguments and temporary variables: 

	Receiver's instance variables: 
		buildEnvironment: 	a ShSmalltalkGlobalsEnvironment
		superclassName: 	#Object
		name: 	#NameOfSubclass
		layoutDefinition: 	a ShLayoutDefinition
		comment: 	nil
		commentStamp: 	nil
		superclass: 	Object
		category: 	nil
		newMetaclass: 	nil
		newClass: 	nil
		oldClass: 	nil
		oldMetaclass: 	nil
		builderEnhancer: 	nil
		metaclassClass: 	nil
		extensibleProperties: 	a Dictionary()
		changeComparers: 	an OrderedCollection()
		changes: 	a Set()
		metaSuperclass: 	nil


ShiftClassBuilder>>name:
	Receiver: a ShiftClassBuilder
	Arguments and temporary variables: 
		anObject: 	#NameOfSubclass
	Receiver's instance variables: 
		buildEnvironment: 	a ShSmalltalkGlobalsEnvironment
		superclassName: 	#Object
		name: 	#NameOfSubclass
		layoutDefinition: 	a ShLayoutDefinition
		comment: 	nil
		commentStamp: 	nil
		superclass: 	Object
		category: 	nil
		newMetaclass: 	nil
		newClass: 	nil
		oldClass: 	nil
		oldMetaclass: 	nil
		builderEnhancer: 	nil
		metaclassClass: 	nil
		extensibleProperties: 	a Dictionary()
		changeComparers: 	an OrderedCollection()
		changes: 	a Set()
		metaSuperclass: 	nil


[ :builder | 
builder
	superclass: self;
	name: t;
	layoutClass: self classLayout class;
	slots: f asSlotCollection;
	sharedVariablesFromString: d;
	sharedPools: s;
	category: cat;
	environment: self environment;
	copyClassSlotsFromExistingClass ] in Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
	Receiver: Object
	Arguments and temporary variables: 
		t: 	#NameOfSubclass
		f: 	'numTotalCars'
		d: 	''
		s: 	''
		cat: 	'LifewareHR'
		builder: 	a ShiftClassBuilder
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 429)
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{Exception. Path. Stream. AbstractDelayTicker. AbstractLayout. Abst...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'


ShiftClassInstaller>>make:
	Receiver: a ShiftClassInstaller
	Arguments and temporary variables: 
		newClass: 	nil
		aBlock: 	[ :builder | 
builder
	superclass: self;
	name: t;
	layoutClass: self c...etc...
	Receiver's instance variables: 
		oldClass: 	nil
		builder: 	a ShiftClassBuilder
		installingEnvironment: 	nil


ShiftClassInstaller class>>make:
	Receiver: ShiftClassInstaller
	Arguments and temporary variables: 
		aBlock: 	[ :builder | 
builder
	superclass: self;
	name: t;
	layoutClass: self c...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#builder->ShiftClassInstaller>>#builder #comment...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ShiftAnonymousClassInstaller}
		name: 	#ShiftClassInstaller
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Shift-ClassInstaller-Base'


Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
	Receiver: Object
	Arguments and temporary variables: 
		t: 	#NameOfSubclass
		f: 	'numTotalCars'
		d: 	''
		s: 	''
		cat: 	'LifewareHR'
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 429)
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{Exception. Path. Stream. AbstractDelayTicker. AbstractLayout. Abst...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'


Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
	Receiver: Object
	Arguments and temporary variables: 
		aSubclassSymbol: 	#NameOfSubclass
		instVarNames: 	'numTotalCars'
		classVarNames: 	''
		aPackageSymbol: 	'LifewareHR'
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 429)
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{Exception. Path. Stream. AbstractDelayTicker. AbstractLayout. Abst...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Object
		subclass: #NameOfSubclass
		instanceVariableNames: 'numTo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a ClySystemEnvironment(current image)
	Arguments and temporary variables: 
		aString: 	'Object subclass: #NameOfSubclass
	instanceVariableNames: ''numTotalCa...etc...
		aController: 	a RubScrolledTextMorph(669513472)
		aClass: 	nil
		oldClass: 	nil
		class: 	nil
		newClassName: 	'NameOfSubclass'
		defTokens: 	an OrderedCollection('Object' 'subclass:' '#NameOfSubclass' 'instanc...etc...
		keywdIx: 	2
		classCompiler: 	an OpalCompiler
	Receiver's instance variables: 
		name: 	'current image'
		globals: 	a SystemDictionary(lots of globals)
		changesAnnouncer: 	a SystemAnnouncer
		packageOrganizer: 	a RPackageOrganizer
		projectManager: 	a ClyProjectManagerRegistry


ClyFullBrowser>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a ClyFullBrowser(998430464)
	Arguments and temporary variables: 
		aString: 	'Object subclass: #NameOfSubclass
	instanceVariableNames: ''numTotalCa...etc...
		aController: 	a RubScrolledTextMorph(669513472)
		aClass: 	nil
	Receiver's instance variables: 
		bounds: 	(19.0@401.0) corner: (958.0@1121.0)
		owner: 	a SystemWindow(357000448) named: LifewareHR
		submorphs: 	an Array(a ProportionalSplitterMorph(794882560) a PanelMorph(1828843...etc...
		fullBounds: 	(19@401) corner: (958@1121)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (363340288) [sticky]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		navigationPanel: 	a PanelMorph(182884352)
		navigationViews: 	an OrderedCollection(a ClyQueryViewMorph(572690176) a ClyQuery...etc...
		toolPanel: 	a PanelMorph(1060573952)
		toolbar: 	a ClyToolbarMorph(337959168)
		tabManager: 	a ClyTabManager
		navigationHistory: 	a ClyNavigationHistory
		navigationStarted: 	false
		plugins: 	a SortedCollection(a ClyStandardBrowserPlugin a ClyMonticelloBrowserPl...etc...
		navigationEnvironment: 	a ClyNavigationEnvironment
		systemScope: 	a ClySystemEnvironmentScope(current image)
		packageView: 	a ClyQueryViewMorph(572690176)
		classView: 	a ClyQueryViewMorph(706305280)
		methodGroupView: 	a ClyQueryViewMorph(416983040)
		methodView: 	a ClyQueryViewMorph(519578368)
		metaLevelScope: 	ClyInstanceSideScope
		methodGroupQuery: 	a ClyUnionQuery(all variables) from empty scope


ClyClassCreationToolMorph>>applyChanges
	Receiver: a ClyClassCreationToolMorph(124086784)
	Arguments and temporary variables: 
		newClass: 	nil
	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1120.0)
		owner: 	a Morph(64442624)
		submorphs: 	an Array(a PanelMorph(775845888))
		fullBounds: 	(21@649) corner: (957@1120)
		color: 	Color transparent
		extension: 	a MorphExtension (712369664) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(998430464)
		context: 	a ClyPackageContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(176785664)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(579100928)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(669513472)
		changesCancelRequested: 	false
		applyingChanges: 	true
		package: 	a RPackage(LifewareHR)
		classTag: 	nil


[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyClassCreationToolMorph(124086784)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1120.0)
		owner: 	a Morph(64442624)
		submorphs: 	an Array(a PanelMorph(775845888))
		fullBounds: 	(21@649) corner: (957@1120)
		color: 	Color transparent
		extension: 	a MorphExtension (712369664) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(998430464)
		context: 	a ClyPackageContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(176785664)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(579100928)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(669513472)
		changesCancelRequested: 	false
		applyingChanges: 	true
		package: 	a RPackage(LifewareHR)
		classTag: 	nil


BlockClosure>>on:do:
	Receiver: [ self changesAreAboutApply.
applied := self applyChanges ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :err | 
textModel text: self editingText.
textMorph hasUnaccep...etc...
	Receiver's instance variables: 
		outerContext: 	[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply...etc...
		startpc: 	140
		numArgs: 	0


[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyClassCreationToolMorph(124086784)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1120.0)
		owner: 	a Morph(64442624)
		submorphs: 	an Array(a PanelMorph(775845888))
		fullBounds: 	(21@649) corner: (957@1120)
		color: 	Color transparent
		extension: 	a MorphExtension (712369664) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(998430464)
		context: 	a ClyPackageContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(176785664)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(579100928)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(669513472)
		changesCancelRequested: 	false
		applyingChanges: 	true
		package: 	a RPackage(LifewareHR)
		classTag: 	nil


BlockClosure>>ensure:
	Receiver: [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyCh...etc...
	Arguments and temporary variables: 
		aBlock: 	[ applyingChanges := false ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepte...etc...
		startpc: 	130
		numArgs: 	0


ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
	Receiver: a ClyClassCreationToolMorph(124086784)
	Arguments and temporary variables: 
		aBlock: 	[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
appl...etc...
	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1120.0)
		owner: 	a Morph(64442624)
		submorphs: 	an Array(a PanelMorph(775845888))
		fullBounds: 	(21@649) corner: (957@1120)
		color: 	Color transparent
		extension: 	a MorphExtension (712369664) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(998430464)
		context: 	a ClyPackageContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(176785664)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(579100928)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(669513472)
		changesCancelRequested: 	false
		applyingChanges: 	true
		package: 	a RPackage(LifewareHR)
		classTag: 	nil


ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyClassCreationToolMorph(124086784)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1120.0)
		owner: 	a Morph(64442624)
		submorphs: 	an Array(a PanelMorph(775845888))
		fullBounds: 	(21@649) corner: (957@1120)
		color: 	Color transparent
		extension: 	a MorphExtension (712369664) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(998430464)
		context: 	a ClyPackageContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(176785664)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(579100928)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(669513472)
		changesCancelRequested: 	false
		applyingChanges: 	true
		package: 	a RPackage(LifewareHR)
		classTag: 	nil


MessageSend>>value
	Receiver: MessageSend(#changesAccepted -> a ClyClassCreationToolMorph(124086784))
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a ClyClassCreationToolMorph(124086784)
		selector: 	#changesAccepted
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#changesAccepted -> a ClyClassCreationToolMorph(124086784))
	Arguments and temporary variables: 
		arg: 	a RubTextAccepted
	Receiver's instance variables: 
		receiver: 	a ClyClassCreationToolMorph(124086784)
		selector: 	#changesAccepted
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#changesAccepted -> a ClyClassCreationToolMorph(124086784))
	Arguments and temporary variables: 
		arg1: 	a RubTextAccepted
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a ClyClassCreationToolMorph(124086784)
		selector: 	#changesAccepted
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAccepted
		subscriber: 	a ClyClassCreationToolMorph(124086784)
		action: 	MessageSend(#changesAccepted -> a ClyClassCreationToolMorph(124086784))...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	83
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	83
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAccepted
		subscriber: 	a ClyClassCreationToolMorph(124086784)
		action: 	MessageSend(#changesAccepted -> a ClyClassCreationToolMorph(124086784))...etc...


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	82
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		announcement: 	a RubTextAccepted
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubScrolledTextMorph>>acceptContents
	Receiver: a RubScrolledTextMorph(669513472)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1095.0)
		owner: 	a PanelMorph(775845888)
		submorphs: 	an Array(a RubTextScrollPane(425140992) a RubAdornmentDisplayer(1909...etc...
		fullBounds: 	(21@649) corner: (957@1095)
		color: 	Color white
		extension: 	a MorphExtension (880246528) [other:  (announcer -> an Announcer) (k...etc...
		hasEditingConflicts: 	false
		hasUnacceptedEdits: 	true
		alwaysAccept: 	nil
		setTextSelector: 	#setText:from:
		getTextSelector: 	#getText
		getSelectionSelector: 	#primarySelectionInterval
		setSelectionSelector: 	nil
		autoAccept: 	false
		scrollPane: 	a RubTextScrollPane(425140992)
		rulers: 	a SortedCollection(a RubTextSegmentIconDisplayer(291502848) a RubAdornm...etc...
		enabled: 	true
		highlights: 	an OrderedCollection()


RubScrolledTextMorph>>whenTextAcceptRequest:
	Receiver: a RubScrolledTextMorph(669513472)
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAcceptRequest
	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1095.0)
		owner: 	a PanelMorph(775845888)
		submorphs: 	an Array(a RubTextScrollPane(425140992) a RubAdornmentDisplayer(1909...etc...
		fullBounds: 	(21@649) corner: (957@1095)
		color: 	Color white
		extension: 	a MorphExtension (880246528) [other:  (announcer -> an Announcer) (k...etc...
		hasEditingConflicts: 	false
		hasUnacceptedEdits: 	true
		alwaysAccept: 	nil
		setTextSelector: 	#setText:from:
		getTextSelector: 	#getText
		getSelectionSelector: 	#primarySelectionInterval
		setSelectionSelector: 	nil
		autoAccept: 	false
		scrollPane: 	a RubTextScrollPane(425140992)
		rulers: 	a SortedCollection(a RubTextSegmentIconDisplayer(291502848) a RubAdornm...etc...
		enabled: 	true
		highlights: 	an OrderedCollection()


MessageSend>>value:
	Receiver: MessageSend(#whenTextAcceptRequest: -> a RubScrolledTextMorph(669513472))
	Arguments and temporary variables: 
		anObject: 	a RubTextAcceptRequest
	Receiver's instance variables: 
		receiver: 	a RubScrolledTextMorph(669513472)
		selector: 	#whenTextAcceptRequest:
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#whenTextAcceptRequest: -> a RubScrolledTextMorph(669513472))
	Arguments and temporary variables: 
		arg: 	a RubTextAcceptRequest
	Receiver's instance variables: 
		receiver: 	a RubScrolledTextMorph(669513472)
		selector: 	#whenTextAcceptRequest:
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#whenTextAcceptRequest: -> a RubScrolledTextMorph(669513472))
	Arguments and temporary variables: 
		arg1: 	a RubTextAcceptRequest
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a RubScrolledTextMorph(669513472)
		selector: 	#whenTextAcceptRequest:
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAcceptRequest
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAcceptRequest
		subscriber: 	a RubScrolledTextMorph(669513472)
		action: 	MessageSend(#whenTextAcceptRequest: -> a RubScrolledTextMorph(669513472...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	83
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	83
		numArgs: 	0



--- The full stack ---
ShiftClassBuilder>>validateClassName
ShiftClassBuilder>>name:
[ :builder | 
builder
	superclass: self;
	name: t;
	layoutClass: self classLayout class;
	slots: f asSlotCollection;
	sharedVariablesFromString: d;
	sharedPools: s;
	category: cat;
	environment: self environment;
	copyClassSlotsFromExistingClass ] in Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowser>>compileANewClassFrom:notifying:startingFrom:
ClyClassCreationToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
BlockClosure>>ensure:
ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubScrolledTextMorph>>acceptContents
RubScrolledTextMorph>>whenTextAcceptRequest:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(RubAbstractTextArea)>>announce:
RubEditingArea(RubAbstractTextArea)>>acceptContents
ClyTextEditor(RubTextEditor)>>accept
[ :target | target editor accept ] in RubTextEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
OrderedCollection>>do:
CmdKMDispatcher(KMDispatcher)>>dispatch:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
InvalidGlobalName: NameOfSubclass: Class name is not a valid global name. It must start with uppercase letter and continue with alphanumeric characters or underscore. Default names used in class or trait templates are not allowed.
20 June 2019 12:19:00.657921 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

ShiftClassBuilder>>validateClassName
	Receiver: a ShiftClassBuilder
	Arguments and temporary variables: 

	Receiver's instance variables: 
		buildEnvironment: 	a ShSmalltalkGlobalsEnvironment
		superclassName: 	#Object
		name: 	#NameOfSubclass
		layoutDefinition: 	a ShLayoutDefinition
		comment: 	nil
		commentStamp: 	nil
		superclass: 	Object
		category: 	nil
		newMetaclass: 	nil
		newClass: 	nil
		oldClass: 	nil
		oldMetaclass: 	nil
		builderEnhancer: 	nil
		metaclassClass: 	nil
		extensibleProperties: 	a Dictionary()
		changeComparers: 	an OrderedCollection()
		changes: 	a Set()
		metaSuperclass: 	nil


ShiftClassBuilder>>name:
	Receiver: a ShiftClassBuilder
	Arguments and temporary variables: 
		anObject: 	#NameOfSubclass
	Receiver's instance variables: 
		buildEnvironment: 	a ShSmalltalkGlobalsEnvironment
		superclassName: 	#Object
		name: 	#NameOfSubclass
		layoutDefinition: 	a ShLayoutDefinition
		comment: 	nil
		commentStamp: 	nil
		superclass: 	Object
		category: 	nil
		newMetaclass: 	nil
		newClass: 	nil
		oldClass: 	nil
		oldMetaclass: 	nil
		builderEnhancer: 	nil
		metaclassClass: 	nil
		extensibleProperties: 	a Dictionary()
		changeComparers: 	an OrderedCollection()
		changes: 	a Set()
		metaSuperclass: 	nil


[ :builder | 
builder
	superclass: self;
	name: t;
	layoutClass: self classLayout class;
	slots: f asSlotCollection;
	sharedVariablesFromString: d;
	sharedPools: s;
	category: cat;
	environment: self environment;
	copyClassSlotsFromExistingClass ] in Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
	Receiver: Object
	Arguments and temporary variables: 
		t: 	#NameOfSubclass
		f: 	'NumTotalCars'
		d: 	''
		s: 	''
		cat: 	'LifewareHR'
		builder: 	a ShiftClassBuilder
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 429)
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{Exception. Path. Stream. AbstractDelayTicker. AbstractLayout. Abst...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'


ShiftClassInstaller>>make:
	Receiver: a ShiftClassInstaller
	Arguments and temporary variables: 
		newClass: 	nil
		aBlock: 	[ :builder | 
builder
	superclass: self;
	name: t;
	layoutClass: self c...etc...
	Receiver's instance variables: 
		oldClass: 	nil
		builder: 	a ShiftClassBuilder
		installingEnvironment: 	nil


ShiftClassInstaller class>>make:
	Receiver: ShiftClassInstaller
	Arguments and temporary variables: 
		aBlock: 	[ :builder | 
builder
	superclass: self;
	name: t;
	layoutClass: self c...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#builder->ShiftClassInstaller>>#builder #comment...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ShiftAnonymousClassInstaller}
		name: 	#ShiftClassInstaller
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Shift-ClassInstaller-Base'


Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
	Receiver: Object
	Arguments and temporary variables: 
		t: 	#NameOfSubclass
		f: 	'NumTotalCars'
		d: 	''
		s: 	''
		cat: 	'LifewareHR'
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 429)
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{Exception. Path. Stream. AbstractDelayTicker. AbstractLayout. Abst...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'


Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
	Receiver: Object
	Arguments and temporary variables: 
		aSubclassSymbol: 	#NameOfSubclass
		instVarNames: 	'NumTotalCars'
		classVarNames: 	''
		aPackageSymbol: 	'LifewareHR'
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 429)
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{Exception. Path. Stream. AbstractDelayTicker. AbstractLayout. Abst...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Object
		subclass: #NameOfSubclass
		instanceVariableNames: 'NumTo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a ClySystemEnvironment(current image)
	Arguments and temporary variables: 
		aString: 	'Object subclass: #NameOfSubclass
	instanceVariableNames: ''NumTotalCa...etc...
		aController: 	a RubScrolledTextMorph(669513472)
		aClass: 	nil
		oldClass: 	nil
		class: 	nil
		newClassName: 	'NameOfSubclass'
		defTokens: 	an OrderedCollection('Object' 'subclass:' '#NameOfSubclass' 'instanc...etc...
		keywdIx: 	2
		classCompiler: 	an OpalCompiler
	Receiver's instance variables: 
		name: 	'current image'
		globals: 	a SystemDictionary(lots of globals)
		changesAnnouncer: 	a SystemAnnouncer
		packageOrganizer: 	a RPackageOrganizer
		projectManager: 	a ClyProjectManagerRegistry


ClyFullBrowser>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a ClyFullBrowser(998430464)
	Arguments and temporary variables: 
		aString: 	'Object subclass: #NameOfSubclass
	instanceVariableNames: ''NumTotalCa...etc...
		aController: 	a RubScrolledTextMorph(669513472)
		aClass: 	nil
	Receiver's instance variables: 
		bounds: 	(19.0@401.0) corner: (958.0@1121.0)
		owner: 	a SystemWindow(357000448) named: LifewareHR
		submorphs: 	an Array(a ProportionalSplitterMorph(794882560) a PanelMorph(1828843...etc...
		fullBounds: 	(19@401) corner: (958@1121)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (363340288) [sticky]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		navigationPanel: 	a PanelMorph(182884352)
		navigationViews: 	an OrderedCollection(a ClyQueryViewMorph(572690176) a ClyQuery...etc...
		toolPanel: 	a PanelMorph(1060573952)
		toolbar: 	a ClyToolbarMorph(337959168)
		tabManager: 	a ClyTabManager
		navigationHistory: 	a ClyNavigationHistory
		navigationStarted: 	false
		plugins: 	a SortedCollection(a ClyStandardBrowserPlugin a ClyMonticelloBrowserPl...etc...
		navigationEnvironment: 	a ClyNavigationEnvironment
		systemScope: 	a ClySystemEnvironmentScope(current image)
		packageView: 	a ClyQueryViewMorph(572690176)
		classView: 	a ClyQueryViewMorph(706305280)
		methodGroupView: 	a ClyQueryViewMorph(416983040)
		methodView: 	a ClyQueryViewMorph(519578368)
		metaLevelScope: 	ClyInstanceSideScope
		methodGroupQuery: 	a ClyUnionQuery(all variables) from empty scope


ClyClassCreationToolMorph>>applyChanges
	Receiver: a ClyClassCreationToolMorph(124086784)
	Arguments and temporary variables: 
		newClass: 	nil
	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1120.0)
		owner: 	a Morph(64442624)
		submorphs: 	an Array(a PanelMorph(775845888))
		fullBounds: 	(21@649) corner: (957@1120)
		color: 	Color transparent
		extension: 	a MorphExtension (712369664) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(998430464)
		context: 	a ClyPackageContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(176785664)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(579100928)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(669513472)
		changesCancelRequested: 	false
		applyingChanges: 	true
		package: 	a RPackage(LifewareHR)
		classTag: 	nil


[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyClassCreationToolMorph(124086784)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1120.0)
		owner: 	a Morph(64442624)
		submorphs: 	an Array(a PanelMorph(775845888))
		fullBounds: 	(21@649) corner: (957@1120)
		color: 	Color transparent
		extension: 	a MorphExtension (712369664) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(998430464)
		context: 	a ClyPackageContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(176785664)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(579100928)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(669513472)
		changesCancelRequested: 	false
		applyingChanges: 	true
		package: 	a RPackage(LifewareHR)
		classTag: 	nil


BlockClosure>>on:do:
	Receiver: [ self changesAreAboutApply.
applied := self applyChanges ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :err | 
textModel text: self editingText.
textMorph hasUnaccep...etc...
	Receiver's instance variables: 
		outerContext: 	[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply...etc...
		startpc: 	140
		numArgs: 	0


[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyClassCreationToolMorph(124086784)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1120.0)
		owner: 	a Morph(64442624)
		submorphs: 	an Array(a PanelMorph(775845888))
		fullBounds: 	(21@649) corner: (957@1120)
		color: 	Color transparent
		extension: 	a MorphExtension (712369664) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(998430464)
		context: 	a ClyPackageContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(176785664)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(579100928)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(669513472)
		changesCancelRequested: 	false
		applyingChanges: 	true
		package: 	a RPackage(LifewareHR)
		classTag: 	nil


BlockClosure>>ensure:
	Receiver: [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyCh...etc...
	Arguments and temporary variables: 
		aBlock: 	[ applyingChanges := false ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepte...etc...
		startpc: 	130
		numArgs: 	0


ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
	Receiver: a ClyClassCreationToolMorph(124086784)
	Arguments and temporary variables: 
		aBlock: 	[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
appl...etc...
	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1120.0)
		owner: 	a Morph(64442624)
		submorphs: 	an Array(a PanelMorph(775845888))
		fullBounds: 	(21@649) corner: (957@1120)
		color: 	Color transparent
		extension: 	a MorphExtension (712369664) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(998430464)
		context: 	a ClyPackageContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(176785664)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(579100928)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(669513472)
		changesCancelRequested: 	false
		applyingChanges: 	true
		package: 	a RPackage(LifewareHR)
		classTag: 	nil


ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyClassCreationToolMorph(124086784)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1120.0)
		owner: 	a Morph(64442624)
		submorphs: 	an Array(a PanelMorph(775845888))
		fullBounds: 	(21@649) corner: (957@1120)
		color: 	Color transparent
		extension: 	a MorphExtension (712369664) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(998430464)
		context: 	a ClyPackageContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(176785664)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(579100928)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(669513472)
		changesCancelRequested: 	false
		applyingChanges: 	true
		package: 	a RPackage(LifewareHR)
		classTag: 	nil


MessageSend>>value
	Receiver: MessageSend(#changesAccepted -> a ClyClassCreationToolMorph(124086784))
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a ClyClassCreationToolMorph(124086784)
		selector: 	#changesAccepted
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#changesAccepted -> a ClyClassCreationToolMorph(124086784))
	Arguments and temporary variables: 
		arg: 	a RubTextAccepted
	Receiver's instance variables: 
		receiver: 	a ClyClassCreationToolMorph(124086784)
		selector: 	#changesAccepted
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#changesAccepted -> a ClyClassCreationToolMorph(124086784))
	Arguments and temporary variables: 
		arg1: 	a RubTextAccepted
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a ClyClassCreationToolMorph(124086784)
		selector: 	#changesAccepted
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAccepted
		subscriber: 	a ClyClassCreationToolMorph(124086784)
		action: 	MessageSend(#changesAccepted -> a ClyClassCreationToolMorph(124086784))...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	83
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	83
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAccepted
		subscriber: 	a ClyClassCreationToolMorph(124086784)
		action: 	MessageSend(#changesAccepted -> a ClyClassCreationToolMorph(124086784))...etc...


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	82
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		announcement: 	a RubTextAccepted
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubScrolledTextMorph>>acceptContents
	Receiver: a RubScrolledTextMorph(669513472)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1095.0)
		owner: 	a PanelMorph(775845888)
		submorphs: 	an Array(a RubTextScrollPane(425140992) a RubAdornmentDisplayer(1909...etc...
		fullBounds: 	(21@649) corner: (957@1095)
		color: 	Color white
		extension: 	a MorphExtension (880246528) [other:  (announcer -> an Announcer) (k...etc...
		hasEditingConflicts: 	false
		hasUnacceptedEdits: 	true
		alwaysAccept: 	nil
		setTextSelector: 	#setText:from:
		getTextSelector: 	#getText
		getSelectionSelector: 	#primarySelectionInterval
		setSelectionSelector: 	nil
		autoAccept: 	false
		scrollPane: 	a RubTextScrollPane(425140992)
		rulers: 	a SortedCollection(a RubTextSegmentIconDisplayer(291502848) a RubAdornm...etc...
		enabled: 	true
		highlights: 	an OrderedCollection()


RubScrolledTextMorph>>whenTextAcceptRequest:
	Receiver: a RubScrolledTextMorph(669513472)
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAcceptRequest
	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1095.0)
		owner: 	a PanelMorph(775845888)
		submorphs: 	an Array(a RubTextScrollPane(425140992) a RubAdornmentDisplayer(1909...etc...
		fullBounds: 	(21@649) corner: (957@1095)
		color: 	Color white
		extension: 	a MorphExtension (880246528) [other:  (announcer -> an Announcer) (k...etc...
		hasEditingConflicts: 	false
		hasUnacceptedEdits: 	true
		alwaysAccept: 	nil
		setTextSelector: 	#setText:from:
		getTextSelector: 	#getText
		getSelectionSelector: 	#primarySelectionInterval
		setSelectionSelector: 	nil
		autoAccept: 	false
		scrollPane: 	a RubTextScrollPane(425140992)
		rulers: 	a SortedCollection(a RubTextSegmentIconDisplayer(291502848) a RubAdornm...etc...
		enabled: 	true
		highlights: 	an OrderedCollection()


MessageSend>>value:
	Receiver: MessageSend(#whenTextAcceptRequest: -> a RubScrolledTextMorph(669513472))
	Arguments and temporary variables: 
		anObject: 	a RubTextAcceptRequest
	Receiver's instance variables: 
		receiver: 	a RubScrolledTextMorph(669513472)
		selector: 	#whenTextAcceptRequest:
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#whenTextAcceptRequest: -> a RubScrolledTextMorph(669513472))
	Arguments and temporary variables: 
		arg: 	a RubTextAcceptRequest
	Receiver's instance variables: 
		receiver: 	a RubScrolledTextMorph(669513472)
		selector: 	#whenTextAcceptRequest:
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#whenTextAcceptRequest: -> a RubScrolledTextMorph(669513472))
	Arguments and temporary variables: 
		arg1: 	a RubTextAcceptRequest
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a RubScrolledTextMorph(669513472)
		selector: 	#whenTextAcceptRequest:
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAcceptRequest
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAcceptRequest
		subscriber: 	a RubScrolledTextMorph(669513472)
		action: 	MessageSend(#whenTextAcceptRequest: -> a RubScrolledTextMorph(669513472...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	83
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	83
		numArgs: 	0



--- The full stack ---
ShiftClassBuilder>>validateClassName
ShiftClassBuilder>>name:
[ :builder | 
builder
	superclass: self;
	name: t;
	layoutClass: self classLayout class;
	slots: f asSlotCollection;
	sharedVariablesFromString: d;
	sharedPools: s;
	category: cat;
	environment: self environment;
	copyClassSlotsFromExistingClass ] in Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowser>>compileANewClassFrom:notifying:startingFrom:
ClyClassCreationToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
BlockClosure>>ensure:
ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubScrolledTextMorph>>acceptContents
RubScrolledTextMorph>>whenTextAcceptRequest:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(RubAbstractTextArea)>>announce:
RubEditingArea(RubAbstractTextArea)>>acceptContents
ClyTextEditor(RubTextEditor)>>accept
[ :target | target editor accept ] in RubTextEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
OrderedCollection>>do:
CmdKMDispatcher(KMDispatcher)>>dispatch:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
InvalidGlobalName: NameOfSubclass: Class name is not a valid global name. It must start with uppercase letter and continue with alphanumeric characters or underscore. Default names used in class or trait templates are not allowed.
20 June 2019 12:19:11.562789 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

ShiftClassBuilder>>validateClassName
	Receiver: a ShiftClassBuilder
	Arguments and temporary variables: 

	Receiver's instance variables: 
		buildEnvironment: 	a ShSmalltalkGlobalsEnvironment
		superclassName: 	#Object
		name: 	#NameOfSubclass
		layoutDefinition: 	a ShLayoutDefinition
		comment: 	nil
		commentStamp: 	nil
		superclass: 	Object
		category: 	nil
		newMetaclass: 	nil
		newClass: 	nil
		oldClass: 	nil
		oldMetaclass: 	nil
		builderEnhancer: 	nil
		metaclassClass: 	nil
		extensibleProperties: 	a Dictionary()
		changeComparers: 	an OrderedCollection()
		changes: 	a Set()
		metaSuperclass: 	nil


ShiftClassBuilder>>name:
	Receiver: a ShiftClassBuilder
	Arguments and temporary variables: 
		anObject: 	#NameOfSubclass
	Receiver's instance variables: 
		buildEnvironment: 	a ShSmalltalkGlobalsEnvironment
		superclassName: 	#Object
		name: 	#NameOfSubclass
		layoutDefinition: 	a ShLayoutDefinition
		comment: 	nil
		commentStamp: 	nil
		superclass: 	Object
		category: 	nil
		newMetaclass: 	nil
		newClass: 	nil
		oldClass: 	nil
		oldMetaclass: 	nil
		builderEnhancer: 	nil
		metaclassClass: 	nil
		extensibleProperties: 	a Dictionary()
		changeComparers: 	an OrderedCollection()
		changes: 	a Set()
		metaSuperclass: 	nil


[ :builder | 
builder
	superclass: self;
	name: t;
	layoutClass: self classLayout class;
	slots: f asSlotCollection;
	sharedVariablesFromString: d;
	sharedPools: s;
	category: cat;
	environment: self environment;
	copyClassSlotsFromExistingClass ] in Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
	Receiver: Object
	Arguments and temporary variables: 
		t: 	#NameOfSubclass
		f: 	'NumTotalCar'
		d: 	''
		s: 	''
		cat: 	'LifewareHR'
		builder: 	a ShiftClassBuilder
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 429)
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{Exception. Path. Stream. AbstractDelayTicker. AbstractLayout. Abst...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'


ShiftClassInstaller>>make:
	Receiver: a ShiftClassInstaller
	Arguments and temporary variables: 
		newClass: 	nil
		aBlock: 	[ :builder | 
builder
	superclass: self;
	name: t;
	layoutClass: self c...etc...
	Receiver's instance variables: 
		oldClass: 	nil
		builder: 	a ShiftClassBuilder
		installingEnvironment: 	nil


ShiftClassInstaller class>>make:
	Receiver: ShiftClassInstaller
	Arguments and temporary variables: 
		aBlock: 	[ :builder | 
builder
	superclass: self;
	name: t;
	layoutClass: self c...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#builder->ShiftClassInstaller>>#builder #comment...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ShiftAnonymousClassInstaller}
		name: 	#ShiftClassInstaller
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Shift-ClassInstaller-Base'


Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
	Receiver: Object
	Arguments and temporary variables: 
		t: 	#NameOfSubclass
		f: 	'NumTotalCar'
		d: 	''
		s: 	''
		cat: 	'LifewareHR'
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 429)
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{Exception. Path. Stream. AbstractDelayTicker. AbstractLayout. Abst...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'


Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
	Receiver: Object
	Arguments and temporary variables: 
		aSubclassSymbol: 	#NameOfSubclass
		instVarNames: 	'NumTotalCar'
		classVarNames: 	''
		aPackageSymbol: 	'LifewareHR'
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 429)
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{Exception. Path. Stream. AbstractDelayTicker. AbstractLayout. Abst...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Object
		subclass: #NameOfSubclass
		instanceVariableNames: 'NumTo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a ClySystemEnvironment(current image)
	Arguments and temporary variables: 
		aString: 	'Object subclass: #NameOfSubclass
	instanceVariableNames: ''NumTotalCa...etc...
		aController: 	a RubScrolledTextMorph(669513472)
		aClass: 	nil
		oldClass: 	nil
		class: 	nil
		newClassName: 	'NameOfSubclass'
		defTokens: 	an OrderedCollection('Object' 'subclass:' '#NameOfSubclass' 'instanc...etc...
		keywdIx: 	2
		classCompiler: 	an OpalCompiler
	Receiver's instance variables: 
		name: 	'current image'
		globals: 	a SystemDictionary(lots of globals)
		changesAnnouncer: 	a SystemAnnouncer
		packageOrganizer: 	a RPackageOrganizer
		projectManager: 	a ClyProjectManagerRegistry


ClyFullBrowser>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a ClyFullBrowser(998430464)
	Arguments and temporary variables: 
		aString: 	'Object subclass: #NameOfSubclass
	instanceVariableNames: ''NumTotalCa...etc...
		aController: 	a RubScrolledTextMorph(669513472)
		aClass: 	nil
	Receiver's instance variables: 
		bounds: 	(19.0@401.0) corner: (958.0@1121.0)
		owner: 	a SystemWindow(357000448) named: LifewareHR
		submorphs: 	an Array(a ProportionalSplitterMorph(794882560) a PanelMorph(1828843...etc...
		fullBounds: 	(19@401) corner: (958@1121)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (363340288) [sticky]  [other:  (announcer -> an Ann...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000...etc...
		navigationPanel: 	a PanelMorph(182884352)
		navigationViews: 	an OrderedCollection(a ClyQueryViewMorph(572690176) a ClyQuery...etc...
		toolPanel: 	a PanelMorph(1060573952)
		toolbar: 	a ClyToolbarMorph(337959168)
		tabManager: 	a ClyTabManager
		navigationHistory: 	a ClyNavigationHistory
		navigationStarted: 	false
		plugins: 	a SortedCollection(a ClyStandardBrowserPlugin a ClyMonticelloBrowserPl...etc...
		navigationEnvironment: 	a ClyNavigationEnvironment
		systemScope: 	a ClySystemEnvironmentScope(current image)
		packageView: 	a ClyQueryViewMorph(572690176)
		classView: 	a ClyQueryViewMorph(706305280)
		methodGroupView: 	a ClyQueryViewMorph(416983040)
		methodView: 	a ClyQueryViewMorph(519578368)
		metaLevelScope: 	ClyInstanceSideScope
		methodGroupQuery: 	a ClyUnionQuery(all variables) from empty scope


ClyClassCreationToolMorph>>applyChanges
	Receiver: a ClyClassCreationToolMorph(124086784)
	Arguments and temporary variables: 
		newClass: 	nil
	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1120.0)
		owner: 	a Morph(64442624)
		submorphs: 	an Array(a PanelMorph(775845888))
		fullBounds: 	(21@649) corner: (957@1120)
		color: 	Color transparent
		extension: 	a MorphExtension (712369664) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(998430464)
		context: 	a ClyPackageContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(176785664)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(579100928)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(669513472)
		changesCancelRequested: 	false
		applyingChanges: 	true
		package: 	a RPackage(LifewareHR)
		classTag: 	nil


[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyClassCreationToolMorph(124086784)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1120.0)
		owner: 	a Morph(64442624)
		submorphs: 	an Array(a PanelMorph(775845888))
		fullBounds: 	(21@649) corner: (957@1120)
		color: 	Color transparent
		extension: 	a MorphExtension (712369664) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(998430464)
		context: 	a ClyPackageContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(176785664)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(579100928)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(669513472)
		changesCancelRequested: 	false
		applyingChanges: 	true
		package: 	a RPackage(LifewareHR)
		classTag: 	nil


BlockClosure>>on:do:
	Receiver: [ self changesAreAboutApply.
applied := self applyChanges ]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :err | 
textModel text: self editingText.
textMorph hasUnaccep...etc...
	Receiver's instance variables: 
		outerContext: 	[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply...etc...
		startpc: 	140
		numArgs: 	0


[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyClassCreationToolMorph(124086784)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1120.0)
		owner: 	a Morph(64442624)
		submorphs: 	an Array(a PanelMorph(775845888))
		fullBounds: 	(21@649) corner: (957@1120)
		color: 	Color transparent
		extension: 	a MorphExtension (712369664) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(998430464)
		context: 	a ClyPackageContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(176785664)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(579100928)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(669513472)
		changesCancelRequested: 	false
		applyingChanges: 	true
		package: 	a RPackage(LifewareHR)
		classTag: 	nil


BlockClosure>>ensure:
	Receiver: [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyCh...etc...
	Arguments and temporary variables: 
		aBlock: 	[ applyingChanges := false ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepte...etc...
		startpc: 	130
		numArgs: 	0


ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
	Receiver: a ClyClassCreationToolMorph(124086784)
	Arguments and temporary variables: 
		aBlock: 	[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
appl...etc...
	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1120.0)
		owner: 	a Morph(64442624)
		submorphs: 	an Array(a PanelMorph(775845888))
		fullBounds: 	(21@649) corner: (957@1120)
		color: 	Color transparent
		extension: 	a MorphExtension (712369664) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(998430464)
		context: 	a ClyPackageContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(176785664)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(579100928)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(669513472)
		changesCancelRequested: 	false
		applyingChanges: 	true
		package: 	a RPackage(LifewareHR)
		classTag: 	nil


ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
	Receiver: a ClyClassCreationToolMorph(124086784)
	Arguments and temporary variables: 
		applied: 	nil
	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1120.0)
		owner: 	a Morph(64442624)
		submorphs: 	an Array(a PanelMorph(775845888))
		fullBounds: 	(21@649) corner: (957@1120)
		color: 	Color transparent
		extension: 	a MorphExtension (712369664) [other:  (kmDispatcher -> a CmdKMDispat...etc...
		borderWidth: 	0
		borderColor: 	Color black
		browser: 	a ClyFullBrowser(998430464)
		context: 	a ClyPackageContextOfFullBrowser
		decorators: 	an OrderedCollection(a ClyCriticDecorator)
		containerTab: 	a TabMorph(176785664)
		isDirty: 	true
		isManagedByUser: 	false
		statusBar: 	a ClyStatusBarMorph(579100928)
		textModel: 	a RubScrolledTextModel
		textMorph: 	a RubScrolledTextMorph(669513472)
		changesCancelRequested: 	false
		applyingChanges: 	true
		package: 	a RPackage(LifewareHR)
		classTag: 	nil


MessageSend>>value
	Receiver: MessageSend(#changesAccepted -> a ClyClassCreationToolMorph(124086784))
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a ClyClassCreationToolMorph(124086784)
		selector: 	#changesAccepted
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#changesAccepted -> a ClyClassCreationToolMorph(124086784))
	Arguments and temporary variables: 
		arg: 	a RubTextAccepted
	Receiver's instance variables: 
		receiver: 	a ClyClassCreationToolMorph(124086784)
		selector: 	#changesAccepted
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#changesAccepted -> a ClyClassCreationToolMorph(124086784))
	Arguments and temporary variables: 
		arg1: 	a RubTextAccepted
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a ClyClassCreationToolMorph(124086784)
		selector: 	#changesAccepted
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAccepted
		subscriber: 	a ClyClassCreationToolMorph(124086784)
		action: 	MessageSend(#changesAccepted -> a ClyClassCreationToolMorph(124086784))...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	83
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	83
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAccepted
		subscriber: 	a ClyClassCreationToolMorph(124086784)
		action: 	MessageSend(#changesAccepted -> a ClyClassCreationToolMorph(124086784))...etc...


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	82
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		subs: 	an Array(an AnnouncementSubscription)
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		subs: 	an Array(an AnnouncementSubscription)
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription)
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
		announcement: 	a RubTextAccepted
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubScrolledTextMorph>>acceptContents
	Receiver: a RubScrolledTextMorph(669513472)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1095.0)
		owner: 	a PanelMorph(775845888)
		submorphs: 	an Array(a RubTextScrollPane(425140992) a RubAdornmentDisplayer(1909...etc...
		fullBounds: 	(21@649) corner: (957@1095)
		color: 	Color white
		extension: 	a MorphExtension (880246528) [other:  (announcer -> an Announcer) (k...etc...
		hasEditingConflicts: 	false
		hasUnacceptedEdits: 	true
		alwaysAccept: 	nil
		setTextSelector: 	#setText:from:
		getTextSelector: 	#getText
		getSelectionSelector: 	#primarySelectionInterval
		setSelectionSelector: 	nil
		autoAccept: 	false
		scrollPane: 	a RubTextScrollPane(425140992)
		rulers: 	a SortedCollection(a RubTextSegmentIconDisplayer(291502848) a RubAdornm...etc...
		enabled: 	true
		highlights: 	an OrderedCollection()


RubScrolledTextMorph>>whenTextAcceptRequest:
	Receiver: a RubScrolledTextMorph(669513472)
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAcceptRequest
	Receiver's instance variables: 
		bounds: 	(21.0@649.0) corner: (957.0@1095.0)
		owner: 	a PanelMorph(775845888)
		submorphs: 	an Array(a RubTextScrollPane(425140992) a RubAdornmentDisplayer(1909...etc...
		fullBounds: 	(21@649) corner: (957@1095)
		color: 	Color white
		extension: 	a MorphExtension (880246528) [other:  (announcer -> an Announcer) (k...etc...
		hasEditingConflicts: 	false
		hasUnacceptedEdits: 	true
		alwaysAccept: 	nil
		setTextSelector: 	#setText:from:
		getTextSelector: 	#getText
		getSelectionSelector: 	#primarySelectionInterval
		setSelectionSelector: 	nil
		autoAccept: 	false
		scrollPane: 	a RubTextScrollPane(425140992)
		rulers: 	a SortedCollection(a RubTextSegmentIconDisplayer(291502848) a RubAdornm...etc...
		enabled: 	true
		highlights: 	an OrderedCollection()


MessageSend>>value:
	Receiver: MessageSend(#whenTextAcceptRequest: -> a RubScrolledTextMorph(669513472))
	Arguments and temporary variables: 
		anObject: 	a RubTextAcceptRequest
	Receiver's instance variables: 
		receiver: 	a RubScrolledTextMorph(669513472)
		selector: 	#whenTextAcceptRequest:
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#whenTextAcceptRequest: -> a RubScrolledTextMorph(669513472))
	Arguments and temporary variables: 
		arg: 	a RubTextAcceptRequest
	Receiver's instance variables: 
		receiver: 	a RubScrolledTextMorph(669513472)
		selector: 	#whenTextAcceptRequest:
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#whenTextAcceptRequest: -> a RubScrolledTextMorph(669513472))
	Arguments and temporary variables: 
		arg1: 	a RubTextAcceptRequest
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a RubScrolledTextMorph(669513472)
		selector: 	#whenTextAcceptRequest:
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAcceptRequest
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	RubTextAcceptRequest
		subscriber: 	a RubScrolledTextMorph(669513472)
		action: 	MessageSend(#whenTextAcceptRequest: -> a RubScrolledTextMorph(669513472...etc...


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	83
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	83
		numArgs: 	0



--- The full stack ---
ShiftClassBuilder>>validateClassName
ShiftClassBuilder>>name:
[ :builder | 
builder
	superclass: self;
	name: t;
	layoutClass: self classLayout class;
	slots: f asSlotCollection;
	sharedVariablesFromString: d;
	sharedPools: s;
	category: cat;
	environment: self environment;
	copyClassSlotsFromExistingClass ] in Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowser>>compileANewClassFrom:notifying:startingFrom:
ClyClassCreationToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
BlockClosure>>ensure:
ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyClassCreationToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubScrolledTextMorph>>acceptContents
RubScrolledTextMorph>>whenTextAcceptRequest:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(RubAbstractTextArea)>>announce:
RubEditingArea(RubAbstractTextArea)>>acceptContents
ClyTextEditor(RubTextEditor)>>accept
[ :target | target editor accept ] in RubTextEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
OrderedCollection>>do:
CmdKMDispatcher(KMDispatcher)>>dispatch:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of False did not understand #+
22 June 2019 10:20:29.2495 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

False(Object)>>doesNotUnderstand: #+
	Receiver: false
	Arguments and temporary variables: 
		aMessage: 	+ 5
		exception: 	MessageNotUnderstood: False>>+
		resumeValue: 	nil
	Receiver's instance variables: 
false

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ (Date today < Date today) + 5
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>printIt
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		printString: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Meta + p do [ :target | target editor printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
THERE_BE_DRAGONS_HERE
Instance of False did not understand #+
22 June 2019 10:20:48.989422 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

False(Object)>>doesNotUnderstand: #+
	Receiver: false
	Arguments and temporary variables: 
		aMessage: 	+ 5
		exception: 	MessageNotUnderstood: False>>+
		resumeValue: 	nil
	Receiver's instance variables: 
false

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ (Date today < Date today) + 5
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>printIt
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		printString: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Meta + p do [ :target | target editor printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	17
		each: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#RubSmalltalkEditor) aKMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#RubSmalltalkEditor) a...etc...
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(501949952)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (943@392)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(445479680) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (943@392)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(445479680) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		timeStamp: 	309247
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(281.0@297.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	112
		charCode: 	112
		scanCode: 	112


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (943@392)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(445479680) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (943@392)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(445479680) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(313@368.0) corner: (329@384.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(313@368.0) corner: (329@384.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(321@377) mouseOver 298266 nil]
		targetOffset: 	(217.0@261.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 298266 313 375 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(313@368.0) corner: (329@384.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(313@368.0) corner: (329@384.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(321@377) mouseOver 298266 nil]
		targetOffset: 	(217.0@261.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 298266 313 375 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(313@368.0) corner: (329@384.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(313@368.0) corner: (329@384.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(321@377) mouseOver 298266 nil]
		targetOffset: 	(217.0@261.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 298266 313 375 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendKeyboardEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(313@368.0) corner: (329@384.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(313@368.0) corner: (329@384.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(321@377) mouseOver 298266 nil]
		targetOffset: 	(217.0@261.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 298266 313 375 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>handleEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(313@368.0) corner: (329@384.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(313@368.0) corner: (329@384.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(321@377) mouseOver 298266 nil]
		targetOffset: 	(217.0@261.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 298266 313 375 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
False(Object)>>doesNotUnderstand: #+
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>evaluateSelectionAndDo:
RubSmalltalkEditor>>printIt
[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of ThreadSafeTranscript did not understand #show
22 June 2019 10:24:58.769243 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

ThreadSafeTranscript(Object)>>doesNotUnderstand: #show
	Receiver: Transcript
	Arguments and temporary variables: 
		aMessage: 	show
		exception: 	MessageNotUnderstood: ThreadSafeTranscript>>show
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray()
		announcer: 	an Announcer
		stream: 	a WriteStream
		accessSemaphore: 	a Mutex
		deferredClear: 	false
		deferredEndEntry: 	false
		stepContents: 	'11
38
3
-2
10
'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Transcript show
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result printString ]
	on: Error
	do: [ '<...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>printIt
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		printString: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Meta + p do [ :target | target editor printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	17
		each: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#RubSmalltalkEditor) aKMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#RubSmalltalkEditor) a...etc...
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(501949952)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (930@525)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(403858432) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (930@525)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(403858432) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		timeStamp: 	559077
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(17@279.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	112
		charCode: 	112
		scanCode: 	112


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (930@525)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(403858432) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (930@525)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(403858432) a RubCursor(293329408...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(49@350.0) corner: (65@366.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(41@341) mouseOver 313569 nil]
		targetOffset: 	(275.0@267.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 313569 41 341 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(49@350.0) corner: (65@366.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(41@341) mouseOver 313569 nil]
		targetOffset: 	(275.0@267.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 313569 41 341 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(49@350.0) corner: (65@366.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(41@341) mouseOver 313569 nil]
		targetOffset: 	(275.0@267.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 313569 41 341 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendKeyboardEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(49@350.0) corner: (65@366.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(41@341) mouseOver 313569 nil]
		targetOffset: 	(275.0@267.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 313569 41 341 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>handleEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(49@350.0) corner: (65@366.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(41@341) mouseOver 313569 nil]
		targetOffset: 	(275.0@267.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 313569 41 341 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
ThreadSafeTranscript(Object)>>doesNotUnderstand: #show
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>evaluateSelectionAndDo:
RubSmalltalkEditor>>printIt
[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of ThreadSafeTranscript did not understand #show
22 June 2019 10:25:01.648185 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

ThreadSafeTranscript(Object)>>doesNotUnderstand: #show
	Receiver: Transcript
	Arguments and temporary variables: 
		aMessage: 	show
		exception: 	MessageNotUnderstood: ThreadSafeTranscript>>show
		resumeValue: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray()
		announcer: 	an Announcer
		stream: 	a WriteStream
		accessSemaphore: 	a Mutex
		deferredClear: 	false
		deferredEndEntry: 	false
		stepContents: 	'11
38
3
-2
10
'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Transcript show
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>evaluateSelectionAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>evaluateSelection
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>doIt
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>doIt:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(501949952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(501949952)
		secondArg: 	a RubEditingArea(501949952)
		thirdArg: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	18
		each: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a KMDispatcher)...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(501949952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(501949952)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#RubSmalltalkEditor) aKMCate...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#RubSmalltalkEditor) a...etc...
		firstIndex: 	1
		lastIndex: 	4


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(501949952)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubSmalltalkEditor) aKMCategoryTarget(#RubTex...etc...
		morph: 	a RubEditingArea(501949952)
		directKeymaps: 	a KMCategory


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (930@525)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(403858432) a RubCursor(293329408...etc...
		fullBounds: 	(0@0) corner: (930@525)
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (930@525)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(403858432) a RubCursor(293329408...etc...
		fullBounds: 	(0@0) corner: (930@525)
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-d>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(501949952)
	Receiver's instance variables: 
		timeStamp: 	561929
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(228@156.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	100


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (930@525)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(403858432) a RubCursor(293329408...etc...
		fullBounds: 	(0@0) corner: (930@525)
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(501949952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (930@525)
		owner: 	a TransformWithLayoutMorph(960300800)
		submorphs: 	an Array(a RubPrimarySelectionMorph(403858432) a RubCursor(293329408...etc...
		fullBounds: 	(0@0) corner: (930@525)
		color: 	Color transparent
		extension: 	a MorphExtension (568825600) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(363264512)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(293329408)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(501949952)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(260@227.0) corner: (276@243.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(260@227.0) corner: (276@243.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(268@236) mouseOver CTRL 561918 nil]
		targetOffset: 	(10.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 561918 268 236 0 2 0 1)
		lastKeyScanCode: 	100
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(260@227.0) corner: (276@243.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(260@227.0) corner: (276@243.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(268@236) mouseOver CTRL 561918 nil]
		targetOffset: 	(10.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 561918 268 236 0 2 0 1)
		lastKeyScanCode: 	100
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a RubEditingArea(501949952)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(260@227.0) corner: (276@243.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(260@227.0) corner: (276@243.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(501949952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(268@236) mouseOver CTRL 561918 nil]
		targetOffset: 	(10.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 561918 268 236 0 2 0 1)
		lastKeyScanCode: 	100
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
ThreadSafeTranscript(Object)>>doesNotUnderstand: #show
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>evaluateSelectionAndDo:
RubSmalltalkEditor>>evaluateSelection
RubSmalltalkEditor>>doIt
RubSmalltalkEditor>>doIt:
[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #type
22 June 2019 10:55:07.404626 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #type
	Receiver: 1
	Arguments and temporary variables: 
		aMessage: 	type
		exception: 	MessageNotUnderstood: SmallInteger>>type
		resumeValue: 	nil
	Receiver's instance variables: 
1

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ test at: 1 type
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	2367716
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	2367717
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	2367716
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	2367717
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	2367666
		lastStepMessage: 	nil
		lastCycleTime: 	2367717
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	2367666
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	2367717
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	2367666
		lastStepMessage: 	nil
		lastCycleTime: 	2367717
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	2367666
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	2367666
		lastStepMessage: 	nil
		lastCycleTime: 	2367717
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	2367666
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	2367666
		lastStepMessage: 	nil
		lastCycleTime: 	2367717
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	2367666
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	2367666
		lastStepMessage: 	nil
		lastCycleTime: 	2367717
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	2367666
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #type
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Car did not understand #'<='
22 June 2019 11:05:30.641955 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Car(Object)>>doesNotUnderstand: #'<='
	Receiver: a Car
	Arguments and temporary variables: 
		aMessage: 	<= a Car
		exception: 	MessageNotUnderstood: Car>><=
		resumeValue: 	nil
	Receiver's instance variables: 
		price: 	50
		type: 	#panda


SortedCollection>>indexForInserting:
	Receiver: a SortedCollection(a Car)
	Arguments and temporary variables: 
		newObject: 	a Car
		index: 	10
		low: 	10
		high: 	10
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil a Car)
		firstIndex: 	10
		lastIndex: 	10
		sortBlock: 	nil


SortedCollection>>add:
	Receiver: a SortedCollection(a Car)
	Arguments and temporary variables: 
		newObject: 	a Car
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil a Car)
		firstIndex: 	10
		lastIndex: 	10
		sortBlock: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	test := SortedCollection new.
	^ test
		add: Car panda;
		add: Car p...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(390587648)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (682@449)
		owner: 	a TransformWithLayoutMorph(823636480)
		submorphs: 	an Array(a RubPrimarySelectionMorph(59525120) a RubCursor(874432000)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (388738816) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(180068864)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(874432000)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(533949184))
		getMenuPolicy: 	a RubEditingArea(390587648)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	2990883
		lastStepMessage: 	nil
		lastCycleTime: 	2990943
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	2990883
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	2990883
		lastStepMessage: 	nil
		lastCycleTime: 	2990943
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	2990883
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	2990883
		lastStepMessage: 	nil
		lastCycleTime: 	2990943
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	2990883
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
Car(Object)>>doesNotUnderstand: #'<='
SortedCollection>>indexForInserting:
SortedCollection>>add:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #x
22 June 2019 11:26:27.844804 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #x
	Receiver: 3
	Arguments and temporary variables: 
		aMessage: 	x
		exception: 	MessageNotUnderstood: SmallInteger>>x
		resumeValue: 	nil
	Receiver's instance variables: 
3

Point>><
	Receiver: (1@2)
	Arguments and temporary variables: 
		aPoint: 	3
	Receiver's instance variables: 
		x: 	1
		y: 	2


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ (1 @ 2 < 3) @ 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	4248156
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	4248157
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	4248156
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	4248157
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	4248106
		lastStepMessage: 	nil
		lastCycleTime: 	4248157
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	4248106
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	4248157
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	4248106
		lastStepMessage: 	nil
		lastCycleTime: 	4248157
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	4248106
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	4248106
		lastStepMessage: 	nil
		lastCycleTime: 	4248157
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	4248106
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	4248106
		lastStepMessage: 	nil
		lastCycleTime: 	4248157
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	4248106
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	4248106
		lastStepMessage: 	nil
		lastCycleTime: 	4248157
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	4248106
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #x
Point>><
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #first
22 June 2019 11:28:40.211655 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #first
	Receiver: 1
	Arguments and temporary variables: 
		aMessage: 	first
		exception: 	MessageNotUnderstood: SmallInteger>>first
		resumeValue: 	nil
	Receiver's instance variables: 
1

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ points at: 1 first
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(390587648)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (669@791)
		owner: 	a TransformWithLayoutMorph(823636480)
		submorphs: 	an Array(a RubPrimarySelectionMorph(795230720) a RubCursor(874432000...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (388738816) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(180068864)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(874432000)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(400364544))
		getMenuPolicy: 	a RubEditingArea(390587648)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	4380467
		lastStepMessage: 	nil
		lastCycleTime: 	4380521
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	4380467
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	4380467
		lastStepMessage: 	nil
		lastCycleTime: 	4380521
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	4380467
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	4380467
		lastStepMessage: 	nil
		lastCycleTime: 	4380521
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	4380467
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #first
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #x
22 June 2019 11:28:51.511122 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #x
	Receiver: 1
	Arguments and temporary variables: 
		aMessage: 	x
		exception: 	MessageNotUnderstood: SmallInteger>>x
		resumeValue: 	nil
	Receiver's instance variables: 
1

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ points at: 1 x
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(390587648)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (669@791)
		owner: 	a TransformWithLayoutMorph(823636480)
		submorphs: 	an Array(a RubPrimarySelectionMorph(795230720) a RubCursor(874432000...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (388738816) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(180068864)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(874432000)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(597545728))
		getMenuPolicy: 	a RubEditingArea(390587648)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	4391795
		lastStepMessage: 	nil
		lastCycleTime: 	4391822
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	4391795
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	4391795
		lastStepMessage: 	nil
		lastCycleTime: 	4391822
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	4391795
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	4391795
		lastStepMessage: 	nil
		lastCycleTime: 	4391822
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	4391795
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #x
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Point did not understand #@
22 June 2019 11:29:59.249916 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Point(Object)>>doesNotUnderstand: #@
	Receiver: (1@4)
	Arguments and temporary variables: 
		aMessage: 	@ 5
		exception: 	MessageNotUnderstood: Point>>@
		resumeValue: 	nil
	Receiver's instance variables: 
		x: 	1
		y: 	4


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	points := SortedCollection new.
	^ points
		add: 1 @ 2;
		add: 3 @ 4...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(390587648)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (669@810)
		owner: 	a TransformWithLayoutMorph(823636480)
		submorphs: 	an Array(a RubPrimarySelectionMorph(795230720) a RubCursor(874432000...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (388738816) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(180068864)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(874432000)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(505049344))
		getMenuPolicy: 	a RubEditingArea(390587648)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	4459503
		lastStepMessage: 	nil
		lastCycleTime: 	4459559
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	4459503
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	4459503
		lastStepMessage: 	nil
		lastCycleTime: 	4459559
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	4459503
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	4459503
		lastStepMessage: 	nil
		lastCycleTime: 	4459559
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	4459503
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
Point(Object)>>doesNotUnderstand: #@
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: only integers should be used as indices
22 June 2019 11:41:13.823627 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

UndefinedObject(Object)>>error:
	Receiver: nil
	Arguments and temporary variables: 
		aString: 	'only integers should be used as indices'
	Receiver's instance variables: 
nil

UndefinedObject(Object)>>errorNonIntegerIndex
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

UndefinedObject(Object)>>at:put:
	Receiver: nil
	Arguments and temporary variables: 
		index: 	#panda
		value: 	3
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	dict = Dictionary new.
	dict at: #panda put: 3.
	^ dict
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	5134110
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	5134136
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	5134110
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	5134136
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	5134101
		lastStepMessage: 	nil
		lastCycleTime: 	5134136
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5134101
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	5134136
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	5134101
		lastStepMessage: 	nil
		lastCycleTime: 	5134136
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5134101
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	5134101
		lastStepMessage: 	nil
		lastCycleTime: 	5134136
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5134101
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	5134101
		lastStepMessage: 	nil
		lastCycleTime: 	5134136
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5134101
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	5134101
		lastStepMessage: 	nil
		lastCycleTime: 	5134136
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5134101
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>error:
UndefinedObject(Object)>>errorNonIntegerIndex
UndefinedObject(Object)>>at:put:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: only integers should be used as indices
22 June 2019 11:41:17.981741 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

UndefinedObject(Object)>>error:
	Receiver: nil
	Arguments and temporary variables: 
		aString: 	'only integers should be used as indices'
	Receiver's instance variables: 
nil

UndefinedObject(Object)>>errorNonIntegerIndex
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

UndefinedObject(Object)>>at:put:
	Receiver: nil
	Arguments and temporary variables: 
		index: 	#panda
		value: 	3
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	dict = Dictionary new.
	^ dict at: #panda put: 3
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(390587648)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (682@563)
		owner: 	a TransformWithLayoutMorph(823636480)
		submorphs: 	an Array(a RubPrimarySelectionMorph(685038336) a RubCursor(874432000...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (388738816) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(180068864)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(874432000)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(101111808))
		getMenuPolicy: 	a RubEditingArea(390587648)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	5138249
		lastStepMessage: 	nil
		lastCycleTime: 	5138288
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5138249
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	5138249
		lastStepMessage: 	nil
		lastCycleTime: 	5138288
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5138249
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	5138249
		lastStepMessage: 	nil
		lastCycleTime: 	5138288
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5138249
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>error:
UndefinedObject(Object)>>errorNonIntegerIndex
UndefinedObject(Object)>>at:put:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: only integers should be used as indices
22 June 2019 11:41:40.038022 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

UndefinedObject(Object)>>error:
	Receiver: nil
	Arguments and temporary variables: 
		aString: 	'only integers should be used as indices'
	Receiver's instance variables: 
nil

UndefinedObject(Object)>>errorNonIntegerIndex
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

UndefinedObject(Object)>>at:put:
	Receiver: nil
	Arguments and temporary variables: 
		index: 	'panda'
		value: 	3
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	dict = Dictionary new.
	^ dict at: 'panda' put: 3
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(390587648)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (682@563)
		owner: 	a TransformWithLayoutMorph(823636480)
		submorphs: 	an Array(a RubPrimarySelectionMorph(685038336) a RubCursor(874432000...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (388738816) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(180068864)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(874432000)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(1054025984))
		getMenuPolicy: 	a RubEditingArea(390587648)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	5160295
		lastStepMessage: 	nil
		lastCycleTime: 	5160349
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5160295
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	5160295
		lastStepMessage: 	nil
		lastCycleTime: 	5160349
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5160295
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	5160295
		lastStepMessage: 	nil
		lastCycleTime: 	5160349
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5160295
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>error:
UndefinedObject(Object)>>errorNonIntegerIndex
UndefinedObject(Object)>>at:put:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: only integers should be used as indices
22 June 2019 11:41:53.760291 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

UndefinedObject(Object)>>error:
	Receiver: nil
	Arguments and temporary variables: 
		aString: 	'only integers should be used as indices'
	Receiver's instance variables: 
nil

UndefinedObject(Object)>>errorNonIntegerIndex
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

UndefinedObject(Object)>>at:put:
	Receiver: nil
	Arguments and temporary variables: 
		index: 	#panda
		value: 	3
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	dict = Dictionary new.
	^ dict at: #panda put: 3
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(390587648)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (682@544)
		owner: 	a TransformWithLayoutMorph(823636480)
		submorphs: 	an Array(a RubPrimarySelectionMorph(685038336) a RubCursor(874432000...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (388738816) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(180068864)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(874432000)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(748258816))
		getMenuPolicy: 	a RubEditingArea(390587648)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	5174044
		lastStepMessage: 	nil
		lastCycleTime: 	5174071
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5174044
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	5174044
		lastStepMessage: 	nil
		lastCycleTime: 	5174071
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5174044
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	5174044
		lastStepMessage: 	nil
		lastCycleTime: 	5174071
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5174044
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>error:
UndefinedObject(Object)>>errorNonIntegerIndex
UndefinedObject(Object)>>at:put:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Instances of UndefinedObject are not indexable
22 June 2019 11:42:47.101224 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

UndefinedObject(Object)>>error:
	Receiver: nil
	Arguments and temporary variables: 
		aString: 	'Instances of UndefinedObject are not indexable'
	Receiver's instance variables: 
nil

UndefinedObject(Object)>>errorNotIndexable
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

UndefinedObject(Object)>>at:put:
	Receiver: nil
	Arguments and temporary variables: 
		index: 	4
		value: 	3
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	dict = Dictionary new.
	^ dict at: 4 put: 3
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(390587648)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (682@544)
		owner: 	a TransformWithLayoutMorph(823636480)
		submorphs: 	an Array(a RubPrimarySelectionMorph(685038336) a RubCursor(874432000...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (388738816) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(180068864)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(874432000)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(680743168))
		getMenuPolicy: 	a RubEditingArea(390587648)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	5227388
		lastStepMessage: 	nil
		lastCycleTime: 	5227410
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5227388
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	5227388
		lastStepMessage: 	nil
		lastCycleTime: 	5227410
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5227388
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	5227388
		lastStepMessage: 	nil
		lastCycleTime: 	5227410
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5227388
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>error:
UndefinedObject(Object)>>errorNotIndexable
UndefinedObject(Object)>>at:put:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
KeyNotFound: key a Car not found in Dictionary
22 June 2019 11:51:05.000926 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Dictionary>>errorKeyNotFound:
	Receiver: a Dictionary(a Car->a SortedCollection() )
	Arguments and temporary variables: 
		aKey: 	a Car
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil nil nil a Car->a SortedCollection())


[ self errorKeyNotFound: key ] in Dictionary>>at:
	Receiver: a Dictionary(a Car->a SortedCollection() )
	Arguments and temporary variables: 
		key: 	a Car
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil nil nil a Car->a SortedCollection())


Dictionary>>at:ifAbsent:
	Receiver: a Dictionary(a Car->a SortedCollection() )
	Arguments and temporary variables: 
		key: 	a Car
		aBlock: 	[ self errorKeyNotFound: key ]
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil nil nil a Car->a SortedCollection())


Dictionary>>at:
	Receiver: a Dictionary(a Car->a SortedCollection() )
	Arguments and temporary variables: 
		key: 	a Car
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil nil nil a Car->a SortedCollection())


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ dict at: myCar2
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	5725266
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	5725311
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	5725266
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	5725311
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	5725241
		lastStepMessage: 	nil
		lastCycleTime: 	5725311
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5725241
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	5725311
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	5725241
		lastStepMessage: 	nil
		lastCycleTime: 	5725311
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5725241
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	5725241
		lastStepMessage: 	nil
		lastCycleTime: 	5725311
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5725241
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	5725241
		lastStepMessage: 	nil
		lastCycleTime: 	5725311
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5725241
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	5725241
		lastStepMessage: 	nil
		lastCycleTime: 	5725311
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5725241
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
Dictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at:
Dictionary>>at:ifAbsent:
Dictionary>>at:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Car did not understand #value:
22 June 2019 11:51:19.923424 am

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Car(Object)>>doesNotUnderstand: #value:
	Receiver: a Car
	Arguments and temporary variables: 
		aMessage: 	value: a SortedCollection()
		exception: 	MessageNotUnderstood: Car>>value:
		resumeValue: 	nil
	Receiver's instance variables: 
		price: 	400
		type: 	#tesla


[ :each | 
(aBlock value: each)
	ifTrue: [ ^ true ] ] in Dictionary(Collection)>>anySatisfy:
	Receiver: a Dictionary(a Car->a SortedCollection() )
	Arguments and temporary variables: 
		aBlock: 	a Car
		each: 	a SortedCollection()
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil nil nil a Car->a SortedCollection())


Dictionary>>valuesDo:
	Receiver: a Dictionary(a Car->a SortedCollection() )
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
(aBlock value: each)
	ifTrue: [ ^ true ] ]
		eachIndex: 	5
		eachAssociation: 	a Car->a SortedCollection()
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil nil nil a Car->a SortedCollection())


Dictionary>>do:
	Receiver: a Dictionary(a Car->a SortedCollection() )
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
(aBlock value: each)
	ifTrue: [ ^ true ] ]
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil nil nil a Car->a SortedCollection())


Dictionary(Collection)>>anySatisfy:
	Receiver: a Dictionary(a Car->a SortedCollection() )
	Arguments and temporary variables: 
		aBlock: 	a Car
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil nil nil a Car->a SortedCollection())


Dictionary(Collection)>>contains:
	Receiver: a Dictionary(a Car->a SortedCollection() )
	Arguments and temporary variables: 
		aBlock: 	a Car
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil nil nil a Car->a SortedCollection())


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ dict contains: myCar2
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	5740189
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	5740234
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	5740189
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	5740234
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	5740184
		lastStepMessage: 	nil
		lastCycleTime: 	5740234
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5740184
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	5740234
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	5740184
		lastStepMessage: 	nil
		lastCycleTime: 	5740234
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5740184
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	5740184
		lastStepMessage: 	nil
		lastCycleTime: 	5740234
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5740184
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	5740184
		lastStepMessage: 	nil
		lastCycleTime: 	5740234
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5740184
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	5740184
		lastStepMessage: 	nil
		lastCycleTime: 	5740234
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	5740184
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
Car(Object)>>doesNotUnderstand: #value:
[ :each | 
(aBlock value: each)
	ifTrue: [ ^ true ] ] in Dictionary(Collection)>>anySatisfy:
Dictionary>>valuesDo:
Dictionary>>do:
Dictionary(Collection)>>anySatisfy:
Dictionary(Collection)>>contains:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Date did not understand #asNumber
22 June 2019 12:28:12.10584 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Date(Object)>>doesNotUnderstand: #asNumber
	Receiver: 23 June 2019
	Arguments and temporary variables: 
		aMessage: 	asNumber
		exception: 	MessageNotUnderstood: Date>>asNumber
		resumeValue: 	nil
	Receiver's instance variables: 
		start: 	2019-06-23T00:00:00+02:00
		duration: 	1:00:00:00


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Date today - Date tomorrow asNumber
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	7952417
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	7952418
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	7952417
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	7952418
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	7952367
		lastStepMessage: 	nil
		lastCycleTime: 	7952418
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	7952367
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	7952418
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	7952367
		lastStepMessage: 	nil
		lastCycleTime: 	7952418
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	7952367
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	7952367
		lastStepMessage: 	nil
		lastCycleTime: 	7952418
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	7952367
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	7952367
		lastStepMessage: 	nil
		lastCycleTime: 	7952418
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	7952367
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	7952367
		lastStepMessage: 	nil
		lastCycleTime: 	7952418
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	7952367
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
Date(Object)>>doesNotUnderstand: #asNumber
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Date did not understand #asDays
22 June 2019 12:28:39.983482 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Date(Object)>>doesNotUnderstand: #asDays
	Receiver: 23 June 2019
	Arguments and temporary variables: 
		aMessage: 	asDays
		exception: 	MessageNotUnderstood: Date>>asDays
		resumeValue: 	nil
	Receiver's instance variables: 
		start: 	2019-06-23T00:00:00+02:00
		duration: 	1:00:00:00


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Date today - Date tomorrow asDays
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	7980263
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	7980296
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	7980263
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	7980296
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(979902464) named: In...etc...
		lastStepTime: 	7980263
		lastStepMessage: 	nil
		lastCycleTime: 	7980296
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	7980263
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	7980296
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(979902464) named: In...etc...
		lastStepTime: 	7980263
		lastStepMessage: 	nil
		lastCycleTime: 	7980296
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	7980263
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(979902464) named: In...etc...
		lastStepTime: 	7980263
		lastStepMessage: 	nil
		lastCycleTime: 	7980296
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	7980263
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(979902464) named: In...etc...
		lastStepTime: 	7980263
		lastStepMessage: 	nil
		lastCycleTime: 	7980296
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	7980263
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(979902464) named: In...etc...
		lastStepTime: 	7980263
		lastStepMessage: 	nil
		lastCycleTime: 	7980296
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	7980263
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
Date(Object)>>doesNotUnderstand: #asDays
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Duration did not understand #asNumber
22 June 2019 12:29:08.691458 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Duration(Object)>>doesNotUnderstand: #asNumber
	Receiver: -1:00:00:00
	Arguments and temporary variables: 
		aMessage: 	asNumber
		exception: 	MessageNotUnderstood: Duration>>asNumber
		resumeValue: 	nil
	Receiver's instance variables: 
		nanos: 	0
		seconds: 	-86400


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ (Date today - Date tomorrow) asNumber
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	8009003
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	8009004
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	8009003
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	8009004
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(979902464) named: In...etc...
		lastStepTime: 	8008953
		lastStepMessage: 	nil
		lastCycleTime: 	8009004
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	8008953
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	8009004
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(979902464) named: In...etc...
		lastStepTime: 	8008953
		lastStepMessage: 	nil
		lastCycleTime: 	8009004
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	8008953
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(979902464) named: In...etc...
		lastStepTime: 	8008953
		lastStepMessage: 	nil
		lastCycleTime: 	8009004
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	8008953
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(979902464) named: In...etc...
		lastStepTime: 	8008953
		lastStepMessage: 	nil
		lastCycleTime: 	8009004
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	8008953
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(979902464) named: In...etc...
		lastStepTime: 	8008953
		lastStepMessage: 	nil
		lastCycleTime: 	8009004
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	8008953
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
Duration(Object)>>doesNotUnderstand: #asNumber
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 1:01:14.869789 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:01:14.842691+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:01:14.842691+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))


--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#y was sent to nil
22 June 2019 1:01:34.827302 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #y
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	y
		exception: 	MessageNotUnderstood: receiver of "y" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[ :previousRental :nextRental | 
previousRental notNil & (previousRental y >= date)
	ifTrue: [ ^ false ].
nextRental notNil & (nextRental x < (date + numDays))
	ifTrue: [ ^ false ] ] in CarRental>>isAvailable:startingOn:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		date: 	22 June 2019
		numDays: 	1
		rentalDates: 	a SortedCollection()
		previousRental: 	nil
		nextRental: 	nil
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		carRentalDates: 	a Dictionary(a Car->a SortedCollection() a Car->a SortedCollect...etc...


BlockClosure>>cull:cull:
	Receiver: [ :previousRental :nextRental | 
previousRental notNil & (previousRental y >= date)
	ifTru...etc...
	Arguments and temporary variables: 
		firstArg: 	nil
		secondArg: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRental>>isAvailable:startingOn:days:
		startpc: 	105
		numArgs: 	2


[ :prevIndex :nextIndex | 
exceptionBlock
	cull:
		(prevIndex > 0
			ifTrue: [ self at: prevIndex ])
	cull:
		(nextIndex <= self size
			ifTrue: [ self at: nextIndex ]) ] in SortedCollection(SequenceableCollection)>>findBinary:do:ifNone:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :arg | (arg x - date) asDays ]
		actionBlock: 	[ ^ false ]
		exceptionBlock: 	[ :previousRental :nextRental | 
previousRental notNil & (previ...etc...
		prevIndex: 	0
		nextIndex: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	nil


BlockClosure>>cull:cull:
	Receiver: [ :prevIndex :nextIndex | 
exceptionBlock
	cull:
		(prevIndex > 0
			ifTrue: [ self at: pr...etc...
	Arguments and temporary variables: 
		firstArg: 	0
		secondArg: 	1
	Receiver's instance variables: 
		outerContext: 	SortedCollection(SequenceableCollection)>>findBinary:do:ifNone:
		startpc: 	67
		numArgs: 	2


SortedCollection(SequenceableCollection)>>findBinaryIndex:do:ifNone:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :arg | (arg x - date) asDays ]
		actionBlock: 	[ :foundIndex | actionBlock value: (self at: foundIndex) ]
		exceptionBlock: 	[ :prevIndex :nextIndex | 
exceptionBlock
	cull:
		(prevIndex >...etc...
		index: 	0
		low: 	1
		high: 	0
		test: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	nil


SortedCollection(SequenceableCollection)>>findBinary:do:ifNone:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		aBlock: 	[ :arg | (arg x - date) asDays ]
		actionBlock: 	[ ^ false ]
		exceptionBlock: 	[ :previousRental :nextRental | 
previousRental notNil & (previ...etc...
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	nil


CarRental>>isAvailable:startingOn:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		date: 	22 June 2019
		numDays: 	1
		rentalDates: 	a SortedCollection()
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		carRentalDates: 	a Dictionary(a Car->a SortedCollection() a Car->a SortedCollect...etc...


[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
		aCar: 	a Car
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		carRentalDates: 	a Dictionary(a Car->a SortedCollection() a Car->a SortedCollect...etc...


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Car a Car a Car)
	Arguments and temporary variables: 
		selectBlock: 	[ :aCar | self isAvailable: aCar startingOn: date days: numDays ]
		newCollection: 	an OrderedCollection()
		element: 	a Car
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Car a Car a Car nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		carRentalDates: 	a Dictionary(a Car->a SortedCollection() a Car->a SortedCollect...etc...


CarRental>>availableCars
	Receiver: a CarRental
	Arguments and temporary variables: 

	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		carRentalDates: 	a Dictionary(a Car->a SortedCollection() a Car->a SortedCollect...etc...


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:01:14.842691+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:01:14.842691+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #y
[ :previousRental :nextRental | 
previousRental notNil & (previousRental y >= date)
	ifTrue: [ ^ false ].
nextRental notNil & (nextRental x < (date + numDays))
	ifTrue: [ ^ false ] ] in CarRental>>isAvailable:startingOn:days:
BlockClosure>>cull:cull:
[ :prevIndex :nextIndex | 
exceptionBlock
	cull:
		(prevIndex > 0
			ifTrue: [ self at: prevIndex ])
	cull:
		(nextIndex <= self size
			ifTrue: [ self at: nextIndex ]) ] in SortedCollection(SequenceableCollection)>>findBinary:do:ifNone:
BlockClosure>>cull:cull:
SortedCollection(SequenceableCollection)>>findBinaryIndex:do:ifNone:
SortedCollection(SequenceableCollection)>>findBinary:do:ifNone:
CarRental>>isAvailable:startingOn:days:
[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
OrderedCollection>>select:
CarRental>>availableCars:days:
CarRental>>availableCars
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 1:09:02.750671 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:09:02.739838+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:09:02.739838+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))


--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Date did not understand #@
22 June 2019 1:09:26.087156 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Date(Object)>>doesNotUnderstand: #@
	Receiver: 22 June 2019
	Arguments and temporary variables: 
		aMessage: 	@ 22 June 2019
		exception: 	MessageNotUnderstood: Date>>@
		resumeValue: 	nil
	Receiver's instance variables: 
		start: 	2019-06-22T00:00:00+02:00
		duration: 	1:00:00:00


CarRental>>rent:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		numDays: 	5
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		carRentalDates: 	a Dictionary(a Car->a SortedCollection() a Car->a SortedCollect...etc...


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:09:02.739838+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:09:02.739838+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
Date(Object)>>doesNotUnderstand: #@
CarRental>>rent:days:
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 1:10:42.257363 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:
	Receiver: 6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:10:42.239902+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest...etc...
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | ex sunitAnnounce: aTestCase toResult: self ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCase:
		startpc: 	134
		numArgs: 	0


TestResult>>runCase:
	Receiver: 6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:10:42.239902+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest...etc...
		skipped: 	an OrderedCollection()


CarRentalTest(TestCase)>>run:
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		aResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ :each | 
each run: aResult.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
		each: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>>#testDiscountedPr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each run: aResult.
self announceTest: each.
self changed: ea...etc...
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(CarRentalTest>>#testBooleanCondition CarRentalTest>>#testDiscou...etc...
		firstIndex: 	1
		lastIndex: 	9


[ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self change...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>runUnmanaged:
		startpc: 	89
		numArgs: 	0


TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


[ self runUnmanaged: aResult ] in TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ self runUnmanaged: aResult ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ self runUnmanaged: aResult ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestsBy:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestsBy:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


ClyRunTestsFromClassesCommand(ClyRunTestsFromSelectedItemsCommand)>>runTestCase:results:
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		testCase: 	CarRentalTest
		testResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 erro...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


ClyRunTestsFromClassesCommand>>runTestCase:
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		testCase: 	CarRentalTest
		testResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 erro...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


[ :each | self runTestCase: each actualObject ] in ClyRunTestsFromClassesCommand>>execute
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(CarRentalTest)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(CarRentalTest))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestCase: each actualObject ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(CarRentalTest))

ClyRunTestsFromClassesCommand>>execute
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))



--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:
BlockClosure>>on:do:
TestResult>>runCase:
CarRentalTest(TestCase)>>run:
[ :each | 
each run: aResult.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
BlockClosure>>ensure:
TestSuite>>runUnmanaged:
[ self runUnmanaged: aResult ] in TestSuite>>run:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestsBy:
CurrentExecutionEnvironment class>>runTestsBy:
TestSuite>>run:
ClyRunTestsFromClassesCommand(ClyRunTestsFromSelectedItemsCommand)>>runTestCase:results:
ClyRunTestsFromClassesCommand>>runTestCase:
[ :each | self runTestCase: each actualObject ] in ClyRunTestsFromClassesCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromClassesCommand>>execute
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyClassContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 1:11:05.906195 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:
	Receiver: 6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:11:05.895431+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest...etc...
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | ex sunitAnnounce: aTestCase toResult: self ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCase:
		startpc: 	134
		numArgs: 	0


TestResult>>runCase:
	Receiver: 6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:11:05.895431+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest...etc...
		skipped: 	an OrderedCollection()


CarRentalTest(TestCase)>>run:
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		aResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ :each | 
each run: aResult.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
		each: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>>#testDiscountedPr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each run: aResult.
self announceTest: each.
self changed: ea...etc...
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(CarRentalTest>>#testBooleanCondition CarRentalTest>>#testDiscou...etc...
		firstIndex: 	1
		lastIndex: 	9


[ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self change...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>runUnmanaged:
		startpc: 	89
		numArgs: 	0


TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


[ self runUnmanaged: aResult ] in TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ self runUnmanaged: aResult ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ self runUnmanaged: aResult ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestsBy:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestsBy:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


ClyRunTestsFromClassesCommand(ClyRunTestsFromSelectedItemsCommand)>>runTestCase:results:
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		testCase: 	CarRentalTest
		testResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 erro...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


ClyRunTestsFromClassesCommand>>runTestCase:
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		testCase: 	CarRentalTest
		testResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 erro...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


[ :each | self runTestCase: each actualObject ] in ClyRunTestsFromClassesCommand>>execute
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(CarRentalTest)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(CarRentalTest))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestCase: each actualObject ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(CarRentalTest))

ClyRunTestsFromClassesCommand>>execute
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))



--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:
BlockClosure>>on:do:
TestResult>>runCase:
CarRentalTest(TestCase)>>run:
[ :each | 
each run: aResult.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
BlockClosure>>ensure:
TestSuite>>runUnmanaged:
[ self runUnmanaged: aResult ] in TestSuite>>run:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestsBy:
CurrentExecutionEnvironment class>>runTestsBy:
TestSuite>>run:
ClyRunTestsFromClassesCommand(ClyRunTestsFromSelectedItemsCommand)>>runTestCase:results:
ClyRunTestsFromClassesCommand>>runTestCase:
[ :each | self runTestCase: each actualObject ] in ClyRunTestsFromClassesCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromClassesCommand>>execute
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyClassContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 1:11:52.632486 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:11:52.622173+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:11:52.622173+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))


--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 1:13:14.091344 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:
	Receiver: 6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:13:14.078937+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest...etc...
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | ex sunitAnnounce: aTestCase toResult: self ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCase:
		startpc: 	134
		numArgs: 	0


TestResult>>runCase:
	Receiver: 6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:13:14.078937+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest...etc...
		skipped: 	an OrderedCollection()


CarRentalTest(TestCase)>>run:
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		aResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ :each | 
each run: aResult.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
		each: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>>#testDiscountedPr...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each run: aResult.
self announceTest: each.
self changed: ea...etc...
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(CarRentalTest>>#testBooleanCondition CarRentalTest>>#testDiscou...etc...
		firstIndex: 	1
		lastIndex: 	9


[ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self change...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>runUnmanaged:
		startpc: 	89
		numArgs: 	0


TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


[ self runUnmanaged: aResult ] in TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ self runUnmanaged: aResult ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ self runUnmanaged: aResult ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestsBy:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestsBy:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


ClyRunTestsFromClassesCommand(ClyRunTestsFromSelectedItemsCommand)>>runTestCase:results:
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		testCase: 	CarRentalTest
		testResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 erro...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


ClyRunTestsFromClassesCommand>>runTestCase:
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		testCase: 	CarRentalTest
		testResult: 	6 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 0 erro...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


[ :each | self runTestCase: each actualObject ] in ClyRunTestsFromClassesCommand>>execute
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(CarRentalTest)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(CarRentalTest))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestCase: each actualObject ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(CarRentalTest))

ClyRunTestsFromClassesCommand>>execute
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))



--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:
BlockClosure>>on:do:
TestResult>>runCase:
CarRentalTest(TestCase)>>run:
[ :each | 
each run: aResult.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
BlockClosure>>ensure:
TestSuite>>runUnmanaged:
[ self runUnmanaged: aResult ] in TestSuite>>run:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestsBy:
CurrentExecutionEnvironment class>>runTestsBy:
TestSuite>>run:
ClyRunTestsFromClassesCommand(ClyRunTestsFromSelectedItemsCommand)>>runTestCase:results:
ClyRunTestsFromClassesCommand>>runTestCase:
[ :each | self runTestCase: each actualObject ] in ClyRunTestsFromClassesCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromClassesCommand>>execute
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyClassContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of CarRentalTest class did not understand #assert:equals:
22 June 2019 1:13:56.7402 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest class(Object)>>doesNotUnderstand: #assert:equals:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aMessage: 	assert: 3 equals: 3
		exception: 	MessageNotUnderstood: CarRentalTest class>>assert:equals:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


CarRentalTest class>>DoIt
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| carRental redPanda yellowPanda blackTesla |
	carRental := CarRenta...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	CarRentalTest
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	CarRentalTest
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(202735616)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(202735616)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>evaluateSelection
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(202735616)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>doIt
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(202735616)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>doIt:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(202735616)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(202735616)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(202735616)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(202735616)
		secondArg: 	a RubEditingArea(202735616)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(202735616)
		secondArg: 	a RubEditingArea(202735616)
		thirdArg: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(202735616)
		category: 	a KMCategory
		morph: 	a RubEditingArea(202735616)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	18
		each: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aListener: 	a CmdKMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(202735616)
		category: 	a KMCategory
		morph: 	a RubEditingArea(202735616)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a RubEditingArea(202735616)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(644946432)


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	4


CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a RubEditingArea(202735616)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(644946432)


CmdKMDispatcher>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		executed: 	false
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		context: 	a ClySourceCodeContext
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a RubEditingArea(202735616)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(644946432)


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(202735616)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a RubEditingArea(202735616)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(644946432)


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(202735616)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@335)
		owner: 	a TransformWithLayoutMorph(398186240)
		submorphs: 	an Array(a RubCursor(36839936) a RubPrimarySelectionMorph(157947904)...etc...
		fullBounds: 	(0@0) corner: (922@335)
		color: 	Color transparent
		extension: 	a MorphExtension (696471552) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(760046336)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(36839936)
		segments: 	an OrderedCollection(a RubTextSegmentMorph(741246720))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(202735616)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@335)
		owner: 	a TransformWithLayoutMorph(398186240)
		submorphs: 	an Array(a RubCursor(36839936) a RubPrimarySelectionMorph(157947904)...etc...
		fullBounds: 	(0@0) corner: (922@335)
		color: 	Color transparent
		extension: 	a MorphExtension (696471552) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(760046336)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(36839936)
		segments: 	an OrderedCollection(a RubTextSegmentMorph(741246720))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-d>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(202735616)
	Receiver's instance variables: 
		timeStamp: 	10696993
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(385@167.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	100


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(202735616)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@335)
		owner: 	a TransformWithLayoutMorph(398186240)
		submorphs: 	an Array(a RubCursor(36839936) a RubPrimarySelectionMorph(157947904)...etc...
		fullBounds: 	(0@0) corner: (922@335)
		color: 	Color transparent
		extension: 	a MorphExtension (696471552) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(760046336)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(36839936)
		segments: 	an OrderedCollection(a RubTextSegmentMorph(741246720))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(202735616)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@335)
		owner: 	a TransformWithLayoutMorph(398186240)
		submorphs: 	an Array(a RubCursor(36839936) a RubPrimarySelectionMorph(157947904)...etc...
		fullBounds: 	(0@0) corner: (922@335)
		color: 	Color transparent
		extension: 	a MorphExtension (696471552) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(760046336)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(36839936)
		segments: 	an OrderedCollection(a RubTextSegmentMorph(741246720))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a RubEditingArea(202735616)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(460@781.0) corner: (476@797.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(460@781.0) corner: (476@797.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(202735616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(468@790) mouseOver CTRL 10696751 nil]
		targetOffset: 	(447@318)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 10696751 465 787 0 2 0 1)
		lastKeyScanCode: 	100
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a RubEditingArea(202735616)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(460@781.0) corner: (476@797.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(460@781.0) corner: (476@797.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(202735616)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(468@790) mouseOver CTRL 10696751 nil]
		targetOffset: 	(447@318)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 10696751 465 787 0 2 0 1)
		lastKeyScanCode: 	100
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
CarRentalTest class(Object)>>doesNotUnderstand: #assert:equals:
CarRentalTest class>>DoIt
OpalCompiler>>evaluate
ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
ClyTextEditor(RubSmalltalkEditor)>>evaluateSelection
ClyTextEditor(RubSmalltalkEditor)>>doIt
ClyTextEditor(RubSmalltalkEditor)>>doIt:
[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
OrderedCollection>>do:
CmdKMDispatcher(KMDispatcher)>>dispatch:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
KeyNotFound: key #DoIt not found in MethodDictionary
22 June 2019 1:15:05.109127 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

MethodDictionary(Dictionary)>>errorKeyNotFound:
	Receiver: a MethodDictionary()
	Arguments and temporary variables: 
		aKey: 	#DoIt
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...


[ self errorKeyNotFound: key ] in MethodDictionary(Dictionary)>>at:
	Receiver: a MethodDictionary()
	Arguments and temporary variables: 
		key: 	#DoIt
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...


MethodDictionary>>at:ifAbsent:
	Receiver: a MethodDictionary()
	Arguments and temporary variables: 
		key: 	#DoIt
		aBlock: 	[ self errorKeyNotFound: key ]
		index: 	19
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...


MethodDictionary(Dictionary)>>at:
	Receiver: a MethodDictionary()
	Arguments and temporary variables: 
		key: 	#DoIt
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil ni...etc...


Metaclass(Behavior)>>compiledMethodAt:
	Receiver: CarRentalTest class
	Arguments and temporary variables: 
		selector: 	#DoIt
	Receiver's instance variables: 
		superclass: 	TestCase class
		methodDict: 	a MethodDictionary()
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		thisClass: 	CarRentalTest


Metaclass(Behavior)>>>>
	Receiver: CarRentalTest class
	Arguments and temporary variables: 
		selector: 	#DoIt
	Receiver's instance variables: 
		superclass: 	TestCase class
		methodDict: 	a MethodDictionary()
		format: 	65548
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		thisClass: 	CarRentalTest


RGMethodDefinition class>>realClass:selector:
	Receiver: RGMethodDefinition
	Arguments and temporary variables: 
		aClass: 	CarRentalTest class
		aString: 	#DoIt
	Receiver's instance variables: 
		superclass: 	RGElementDefinition
		methodDict: 	a MethodDictionary(#'<='->RGMethodDefinition>>#'<=' #=->RGMethodDef...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RGMethodDefinition
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Ring-Deprecated-Core-Kernel-Base'


SystemNavigation>>createMethodNamed:realParent:
	Receiver: a SystemNavigation
	Arguments and temporary variables: 
		aSelector: 	#DoIt
		class: 	CarRentalTest class
	Receiver's instance variables: 
		environment: 	a SystemDictionary(lots of globals)


SystemNavigation>>methodHierarchyBrowserForClass:selector:
	Receiver: a SystemNavigation
	Arguments and temporary variables: 
		aClass: 	CarRentalTest class
		sel: 	#DoIt
		list: 	an OrderedCollection()
	Receiver's instance variables: 
		environment: 	a SystemDictionary(lots of globals)


GTGenericStackDebugger(GTMoldableDebugger)>>methodHierarchy
	Receiver: a GTGenericStackDebugger(id=401658368 title='Instance of CarRentalTest class did not under...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(900980480 root)
		title: 	'Instance of CarRentalTest class did not understand #assert:equals:'
		titleIcon: 	nil
		transformation: 	nil
		actions: 	an OrderedCollection()
		condition: 	nil
		implicitNotNil: 	nil
		dynamicActionsBlock: 	[ :presentation | 
self
	actionsForPragmas: (aSymbolsColle...etc...
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	nil
		acceptsSelection: 	nil
		parentPrototype: 	nil
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	an OrderedCollection()
		selectionDynamicActionsBlock: 	[ :presentation | 
self
	actionsForPragmas:
		(aS...etc...
		implicitAllNil: 	nil
		rawSelectionTransmissions: 	an IdentitySet(GLMTransmission (origins=an OrderedCo...etc...
		statusPane: 	nil
		sourceLink: 	nil
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		stepCondition: 	nil
		wantsAutomaticRefresh: 	nil
		presentations: 	an OrderedCollection(a GLMTabulator(id=186598400 title=nil pane=...etc...
		arrangement: 	a GLMTabbedArrangement
		cache: 	a Dictionary()


GTGenericStackDebugger(Object)>>perform:withEnoughArguments:
	Receiver: a GTGenericStackDebugger(id=401658368 title='Instance of CarRentalTest class did not under...etc...
	Arguments and temporary variables: 
		selector: 	#methodHierarchy
		anArray: 	#()
		numArgs: 	0
		args: 	nil
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	false
		suspendedAnnouncemets: 	an OrderedCollection()
		logger: 	a GLMNullLogger
		pane: 	a GLMPane(900980480 root)
		title: 	'Instance of CarRentalTest class did not understand #assert:equals:'
		titleIcon: 	nil
		transformation: 	nil
		actions: 	an OrderedCollection()
		condition: 	nil
		implicitNotNil: 	nil
		dynamicActionsBlock: 	[ :presentation | 
self
	actionsForPragmas: (aSymbolsColle...etc...
		color: 	nil
		customValidation: 	nil
		shouldValidate: 	nil
		acceptsSelection: 	nil
		parentPrototype: 	nil
		registeredAnnouncers: 	nil
		updateActions: 	an OrderedCollection()
		selectionActions: 	an OrderedCollection()
		selectionDynamicActionsBlock: 	[ :presentation | 
self
	actionsForPragmas:
		(aS...etc...
		implicitAllNil: 	nil
		rawSelectionTransmissions: 	an IdentitySet(GLMTransmission (origins=an OrderedCo...etc...
		statusPane: 	nil
		sourceLink: 	nil
		initializationBlock: 	nil
		cachedDisplayedValue: 	nil
		labelActionBlock: 	nil
		portChangeActions: 	an OrderedCollection()
		wantsSteps: 	nil
		stepTime: 	nil
		stepCondition: 	nil
		wantsAutomaticRefresh: 	nil
		presentations: 	an OrderedCollection(a GLMTabulator(id=186598400 title=nil pane=...etc...
		arrangement: 	a GLMTabbedArrangement
		cache: 	a Dictionary()


GTBrowseDebugAction(MessageSendDebugAction)>>executeAction
	Receiver: a GTBrowseDebugAction
	Arguments and temporary variables: 

	Receiver's instance variables: 
		label: 	'Inheritance'
		order: 	70
		icon: 	nil
		keymap: 	Meta + i
		category: 	nil
		debugger: 	a GTGenericStackDebugger(id=401658368 title='Instance of CarRentalTes...etc...
		needsValidation: 	false
		needsUpdate: 	false
		needsSeparatorAfter: 	nil
		actionSelector: 	nil
		id: 	#methodHierarchy
		selector: 	nil
		help: 	'Browser a hierarchy of the implementors of the current mnethod.'


GTBrowseDebugAction(DebugAction)>>execute
	Receiver: a GTBrowseDebugAction
	Arguments and temporary variables: 

	Receiver's instance variables: 
		label: 	'Inheritance'
		order: 	70
		icon: 	nil
		keymap: 	Meta + i
		category: 	nil
		debugger: 	a GTGenericStackDebugger(id=401658368 title='Instance of CarRentalTes...etc...
		needsValidation: 	false
		needsUpdate: 	false
		needsSeparatorAfter: 	nil
		actionSelector: 	nil
		id: 	#methodHierarchy
		selector: 	nil
		help: 	'Browser a hierarchy of the implementors of the current mnethod.'


[ self execute ] in GTBrowseDebugAction(DebugAction)>>asGlamourAction
	Receiver: a GTBrowseDebugAction
	Arguments and temporary variables: 

	Receiver's instance variables: 
		label: 	'Inheritance'
		order: 	70
		icon: 	nil
		keymap: 	Meta + i
		category: 	nil
		debugger: 	a GTGenericStackDebugger(id=401658368 title='Instance of CarRentalTes...etc...
		needsValidation: 	false
		needsUpdate: 	false
		needsSeparatorAfter: 	nil
		actionSelector: 	nil
		id: 	#methodHierarchy
		selector: 	nil
		help: 	'Browser a hierarchy of the implementors of the current mnethod.'


BlockClosure>>glamourValueWithArgs:
	Receiver: [ self execute ]
	Arguments and temporary variables: 
		anArray: 	an Array(a GLMFastTablePresentation(id=57700352 title='Stack' pane=a G...etc...
	Receiver's instance variables: 
		outerContext: 	GTBrowseDebugAction(DebugAction)>>asGlamourAction
		startpc: 	160
		numArgs: 	0


GLMGenericAction(GLMAction)>>actOn:
	Receiver: a GLMGenericAction
	Arguments and temporary variables: 
		aPresentation: 	a GLMFastTablePresentation(id=57700352 title='Stack' pane=a GLMP...etc...
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		action: 	[ self execute ]
		title: 	'Inheritance'
		help: 	'Browser a hierarchy of the implementors of the current mnethod.'
		keymap: 	Meta + i
		position: 	nil
		category: 	nil
		icon: 	nil
		condition: 	nil
		enabledCondition: 	nil
		separatorAfter: 	nil
		separatorBefore: 	nil
		shouldShowTitle: 	true


[ self actOn: aPresentation ] in GLMGenericAction(GLMAction)>>installKeyCombinationForPresentation:onMorph:
	Receiver: a GLMGenericAction
	Arguments and temporary variables: 
		aPresentation: 	a GLMFastTablePresentation(id=57700352 title='Stack' pane=a GLMP...etc...
		aMorph: 	a FTTableMorph(715904256)
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry
		suspendAll: 	nil
		suspendedAnnouncemets: 	nil
		logger: 	a GLMNullLogger
		action: 	[ self execute ]
		title: 	'Inheritance'
		help: 	'Browser a hierarchy of the implementors of the current mnethod.'
		keymap: 	Meta + i
		position: 	nil
		category: 	nil
		icon: 	nil
		condition: 	nil
		enabledCondition: 	nil
		separatorAfter: 	nil
		separatorBefore: 	nil
		shouldShowTitle: 	true


BlockClosure>>cull:
	Receiver: [ self actOn: aPresentation ]
	Arguments and temporary variables: 
		anArg: 	a FTTableMorph(715904256)
	Receiver's instance variables: 
		outerContext: 	GLMGenericAction(GLMAction)>>installKeyCombinationForPresentation...etc...
		startpc: 	57
		numArgs: 	0


BlockClosure>>cull:cull:
	Receiver: [ self actOn: aPresentation ]
	Arguments and temporary variables: 
		firstArg: 	a FTTableMorph(715904256)
		secondArg: 	a FTTableMorph(715904256)
	Receiver's instance variables: 
		outerContext: 	GLMGenericAction(GLMAction)>>installKeyCombinationForPresentation...etc...
		startpc: 	57
		numArgs: 	0


BlockClosure>>cull:cull:cull:
	Receiver: [ self actOn: aPresentation ]
	Arguments and temporary variables: 
		firstArg: 	a FTTableMorph(715904256)
		secondArg: 	a FTTableMorph(715904256)
		thirdArg: 	[keystroke '<Ctrl-i>']
	Receiver's instance variables: 
		outerContext: 	GLMGenericAction(GLMAction)>>installKeyCombinationForPresentation...etc...
		startpc: 	57
		numArgs: 	0


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on Meta + i do [ self actOn: aPresentation ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
	Receiver's instance variables: 
		target: 	a FTTableMorph(715904256)
		category: 	a KMCategory
		morph: 	a FTTableMorph(715904256)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on Meta + i do [ self actOn: aPresentation ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
		listeners: 	an Array(aKMCategoryTarget(nil) a KMDispatcher)
		l: 	aKMCategoryTarget(nil)
	Receiver's instance variables: 
		action: 	[ self actOn: aPresentation ]
		name: 	nil
		shortcut: 	Meta + i
		defaultShortcut: 	Meta + i
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on Meta + i do [ self actOn: aPresentation ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
		listeners: 	an Array(aKMCategoryTarget(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ self actOn: aPresentation ]
		name: 	nil
		shortcut: 	Meta + i
		defaultShortcut: 	Meta + i
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on Meta + i do [ self actOn: aPresentation ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(nil) a KMDispatcher)
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ self actOn: aPresentation ]
		name: 	nil
		shortcut: 	Meta + i
		defaultShortcut: 	Meta + i
		description: 	nil


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(nil) a KMDispatcher)
		aBlock: 	[ ^ self ]
		entry: 	nil on Meta + i do [ self actOn: aPresentation ]

	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Unix->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on Shift + Meta + t do [ self actOn: aPresentation ]
 nil on Meta + v do [ self ...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	4
		each: 	nil on Meta + i do [ self actOn: aPresentation ]

	Receiver's instance variables: 
		tally: 	16
		array: 	an Array(nil nil on Shift + Meta + t do [ self actOn: aPresentation ]
 n...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
		aMatchListener: 	an Array(aKMCategoryTarget(nil) a KMDispatcher)
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Unix->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a FTTableMorph(715904256)
		category: 	a KMCategory
		morph: 	a FTTableMorph(715904256)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
		aTarget: 	aKMCategoryTarget(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation))
		morph: 	a FTTableMorph(715904256)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation))
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	2


KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation))
		morph: 	a FTTableMorph(715904256)
		directKeymaps: 	a KMCategory


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-i>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a FTTableMorph(715904256)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-i>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-i>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a KMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatcher>>dispatchKeystroke:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-i>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation))
		morph: 	a FTTableMorph(715904256)
		directKeymaps: 	a KMCategory


FTTableMorph(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a FTTableMorph(715904256)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-i>']
	Receiver's instance variables: 
		bounds: 	(87.0@261.0) corner: (1347.0@446.0)
		owner: 	a GLMPanelMorph(928650496)
		submorphs: 	an Array(a FTTableContainerMorph(922309120) a ScrollBar(321451264))
		fullBounds: 	(87@261) corner: (1347@446)
		color: 	Color white
		extension: 	a MorphExtension (639773184) [other:  (announcer -> an Announcer) (k...etc...
		container: 	a FTTableContainerMorph(922309120)
		verticalScrollBar: 	a ScrollBar(321451264)
		horizontalScrollBar: 	nil
		selectionColor: 	nil
		showIndex: 	1
		dataSource: 	a GLMFastTableDataSource
		intercellSpacing: 	(3@1)
		rowHeight: 	20.333333333333336
		selectedRowIndexes: 	#(2)
		highlightedRowIndexes: 	#()
		selectionStrategy: 	a FTSimpleSelection
		columns: 	an Array(a GLMFastTableColumn a GLMFastTableColumn a GLMFastTableColum...etc...
		secondarySelectionColor: 	nil
		headerColor: 	nil
		showColumnHeaders: 	false
		allowsDeselection: 	false
		needToggleAtMouseUp: 	false
		function: 	a FTNilFunction
		resizable: 	true
		trialHSB: 	nil


FTTableMorph(Morph)>>handleKeystrokeWithKeymappings:
	Receiver: a FTTableMorph(715904256)
	Arguments and temporary variables: 
		aKeystrokeEvent: 	[keystroke '<Ctrl-i>']
	Receiver's instance variables: 
		bounds: 	(87.0@261.0) corner: (1347.0@446.0)
		owner: 	a GLMPanelMorph(928650496)
		submorphs: 	an Array(a FTTableContainerMorph(922309120) a ScrollBar(321451264))
		fullBounds: 	(87@261) corner: (1347@446)
		color: 	Color white
		extension: 	a MorphExtension (639773184) [other:  (announcer -> an Announcer) (k...etc...
		container: 	a FTTableContainerMorph(922309120)
		verticalScrollBar: 	a ScrollBar(321451264)
		horizontalScrollBar: 	nil
		selectionColor: 	nil
		showIndex: 	1
		dataSource: 	a GLMFastTableDataSource
		intercellSpacing: 	(3@1)
		rowHeight: 	20.333333333333336
		selectedRowIndexes: 	#(2)
		highlightedRowIndexes: 	#()
		selectionStrategy: 	a FTSimpleSelection
		columns: 	an Array(a GLMFastTableColumn a GLMFastTableColumn a GLMFastTableColum...etc...
		secondarySelectionColor: 	nil
		headerColor: 	nil
		showColumnHeaders: 	false
		allowsDeselection: 	false
		needToggleAtMouseUp: 	false
		function: 	a FTNilFunction
		resizable: 	true
		trialHSB: 	nil



--- The full stack ---
MethodDictionary(Dictionary)>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in MethodDictionary(Dictionary)>>at:
MethodDictionary>>at:ifAbsent:
MethodDictionary(Dictionary)>>at:
Metaclass(Behavior)>>compiledMethodAt:
Metaclass(Behavior)>>>>
RGMethodDefinition class>>realClass:selector:
SystemNavigation>>createMethodNamed:realParent:
SystemNavigation>>methodHierarchyBrowserForClass:selector:
GTGenericStackDebugger(GTMoldableDebugger)>>methodHierarchy
GTGenericStackDebugger(Object)>>perform:withEnoughArguments:
GTBrowseDebugAction(MessageSendDebugAction)>>executeAction
GTBrowseDebugAction(DebugAction)>>execute
[ self execute ] in GTBrowseDebugAction(DebugAction)>>asGlamourAction
BlockClosure>>glamourValueWithArgs:
GLMGenericAction(GLMAction)>>actOn:
[ self actOn: aPresentation ] in GLMGenericAction(GLMAction)>>installKeyCombinationForPresentation:onMorph:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
FTTableMorph(Morph)>>dispatchKeystrokeForEvent:
FTTableMorph(Morph)>>handleKeystrokeWithKeymappings:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMShortcutHandler>>handleKeystroke:inMorph:
FTTableMorph(Morph)>>handleKeystroke:
KeyboardEvent>>sentTo:
FTTableMorph(Morph)>>handleEvent:
FTTableMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 1:16:24.982728 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:
	Receiver: 7 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:16:24.971521+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest...etc...
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | ex sunitAnnounce: aTestCase toResult: self ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCase:
		startpc: 	134
		numArgs: 	0


TestResult>>runCase:
	Receiver: 7 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:16:24.971521+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest...etc...
		skipped: 	an OrderedCollection()


CarRentalTest(TestCase)>>run:
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		aResult: 	7 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ :each | 
each run: aResult.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
		each: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>>#testCustom CarRe...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each run: aResult.
self announceTest: each.
self changed: ea...etc...
		index: 	8
	Receiver's instance variables: 
		array: 	an Array(CarRentalTest>>#testBooleanCondition CarRentalTest>>#testCustom...etc...
		firstIndex: 	1
		lastIndex: 	10


[ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self change...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>runUnmanaged:
		startpc: 	89
		numArgs: 	0


TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


[ self runUnmanaged: aResult ] in TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ self runUnmanaged: aResult ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ self runUnmanaged: aResult ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestsBy:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestsBy:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


ClyRunTestsFromClassesCommand(ClyRunTestsFromSelectedItemsCommand)>>runTestCase:results:
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		testCase: 	CarRentalTest
		testResult: 	7 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 0 erro...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


ClyRunTestsFromClassesCommand>>runTestCase:
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		testCase: 	CarRentalTest
		testResult: 	7 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 0 erro...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


[ :each | self runTestCase: each actualObject ] in ClyRunTestsFromClassesCommand>>execute
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(CarRentalTest)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(CarRentalTest))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestCase: each actualObject ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(CarRentalTest))

ClyRunTestsFromClassesCommand>>execute
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))



--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:
BlockClosure>>on:do:
TestResult>>runCase:
CarRentalTest(TestCase)>>run:
[ :each | 
each run: aResult.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
BlockClosure>>ensure:
TestSuite>>runUnmanaged:
[ self runUnmanaged: aResult ] in TestSuite>>run:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestsBy:
CurrentExecutionEnvironment class>>runTestsBy:
TestSuite>>run:
ClyRunTestsFromClassesCommand(ClyRunTestsFromSelectedItemsCommand)>>runTestCase:results:
ClyRunTestsFromClassesCommand>>runTestCase:
[ :each | self runTestCase: each actualObject ] in ClyRunTestsFromClassesCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromClassesCommand>>execute
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyClassContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #equals:
22 June 2019 1:18:07.448232 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #equals:
	Receiver: 3
	Arguments and temporary variables: 
		aMessage: 	equals: 3
		exception: 	MessageNotUnderstood: SmallInteger>>equals:
		resumeValue: 	nil
	Receiver's instance variables: 
3

CarRentalTest class>>DoIt
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set(#testC...etc...


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| carRental redPanda yellowPanda blackTesla |
	carRental := CarRenta...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	CarRentalTest
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | 
printString := [ result asScriptResultStringInCalypso ]
	o...etc...
		result: 	nil
		rcvr: 	CarRentalTest
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(927102720)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result asScriptResultStringInCalypso ]
	o...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(927102720)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor>>printIt
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		printString: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(927102720)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(927102720)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(927102720)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(927102720)
		secondArg: 	a RubEditingArea(927102720)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(927102720)
		secondArg: 	a RubEditingArea(927102720)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Meta + p do [ :target | target editor printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(927102720)
		category: 	a KMCategory
		morph: 	a RubEditingArea(927102720)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	17
		each: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a CmdKMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(927102720)
		category: 	a KMCategory
		morph: 	a RubEditingArea(927102720)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(927102720)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(446753792)


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#RubTextEditor) aKMCategoryT...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#RubTextEditor) aKMCat...etc...
		firstIndex: 	1
		lastIndex: 	4


CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(927102720)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(446753792)


CmdKMDispatcher>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		executed: 	false
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		context: 	a ClySourceCodeContext
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(927102720)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(446753792)


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(927102720)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(927102720)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(446753792)


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(927102720)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@240)
		owner: 	a TransformWithLayoutMorph(751302656)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1049297664) a RubCursor(29120998...etc...
		fullBounds: 	(0@0) corner: (922@240)
		color: 	Color transparent
		extension: 	a MorphExtension (671895040) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(1016588800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(291209984)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	(345@210)
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(927102720)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@240)
		owner: 	a TransformWithLayoutMorph(751302656)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1049297664) a RubCursor(29120998...etc...
		fullBounds: 	(0@0) corner: (922@240)
		color: 	Color transparent
		extension: 	a MorphExtension (671895040) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(1016588800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(291209984)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	(345@210)
		wrapped: 	true
		editorClass: 	ClyTextEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(927102720)
	Receiver's instance variables: 
		timeStamp: 	10947705
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(-49@38.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	112
		charCode: 	112
		scanCode: 	112


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(927102720)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@240)
		owner: 	a TransformWithLayoutMorph(751302656)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1049297664) a RubCursor(29120998...etc...
		fullBounds: 	(0@0) corner: (922@240)
		color: 	Color transparent
		extension: 	a MorphExtension (671895040) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(1016588800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(291209984)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	(345@210)
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(927102720)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@240)
		owner: 	a TransformWithLayoutMorph(751302656)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1049297664) a RubCursor(29120998...etc...
		fullBounds: 	(0@0) corner: (922@240)
		color: 	Color transparent
		extension: 	a MorphExtension (671895040) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(1016588800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(291209984)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	(345@210)
		wrapped: 	true
		editorClass: 	ClyTextEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(927102720)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(26@652.0) corner: (42@668.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(26@652.0) corner: (42@668.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(927102720)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(34@661) mouseOver 10947017 nil]
		targetOffset: 	(345.0@210.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 10947017 35 662 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(927102720)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(26@652.0) corner: (42@668.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(26@652.0) corner: (42@668.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(927102720)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(34@661) mouseOver 10947017 nil]
		targetOffset: 	(345.0@210.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 10947017 35 662 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(927102720)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(26@652.0) corner: (42@668.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(26@652.0) corner: (42@668.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(927102720)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(34@661) mouseOver 10947017 nil]
		targetOffset: 	(345.0@210.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 10947017 35 662 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendKeyboardEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(26@652.0) corner: (42@668.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(26@652.0) corner: (42@668.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(927102720)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(34@661) mouseOver 10947017 nil]
		targetOffset: 	(345.0@210.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 10947017 35 662 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #equals:
CarRentalTest class>>DoIt
OpalCompiler>>evaluate
ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
ClyTextEditor>>printIt
[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
OrderedCollection>>do:
CmdKMDispatcher(KMDispatcher)>>dispatch:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #equals:
22 June 2019 1:18:29.421988 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #equals:
	Receiver: 3
	Arguments and temporary variables: 
		aMessage: 	equals: 3
		exception: 	MessageNotUnderstood: SmallInteger>>equals:
		resumeValue: 	nil
	Receiver's instance variables: 
3

CarRentalTest class>>DoIt
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set(#testC...etc...


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| carRental redPanda yellowPanda blackTesla |
	carRental := CarRenta...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	CarRentalTest
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | 
printString := [ result asScriptResultStringInCalypso ]
	o...etc...
		result: 	nil
		rcvr: 	CarRentalTest
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(927102720)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result asScriptResultStringInCalypso ]
	o...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(927102720)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor>>printIt
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		printString: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(927102720)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(927102720)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(927102720)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(927102720)
		secondArg: 	a RubEditingArea(927102720)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(927102720)
		secondArg: 	a RubEditingArea(927102720)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Meta + p do [ :target | target editor printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(927102720)
		category: 	a KMCategory
		morph: 	a RubEditingArea(927102720)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	17
		each: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a CmdKMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(927102720)
		category: 	a KMCategory
		morph: 	a RubEditingArea(927102720)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(927102720)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(446753792)


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#RubTextEditor) aKMCategoryT...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#RubTextEditor) aKMCat...etc...
		firstIndex: 	1
		lastIndex: 	4


CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(927102720)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(446753792)


CmdKMDispatcher>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		executed: 	false
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		context: 	a ClySourceCodeContext
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(927102720)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(446753792)


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(927102720)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(927102720)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(446753792)


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(927102720)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@240)
		owner: 	a TransformWithLayoutMorph(751302656)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1049297664) a RubCursor(29120998...etc...
		fullBounds: 	(0@0) corner: (922@240)
		color: 	Color transparent
		extension: 	a MorphExtension (671895040) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(1016588800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(291209984)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(927102720)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@240)
		owner: 	a TransformWithLayoutMorph(751302656)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1049297664) a RubCursor(29120998...etc...
		fullBounds: 	(0@0) corner: (922@240)
		color: 	Color transparent
		extension: 	a MorphExtension (671895040) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(1016588800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(291209984)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(927102720)
	Receiver's instance variables: 
		timeStamp: 	10969731
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(3@37.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	112
		charCode: 	112
		scanCode: 	112


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(927102720)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@240)
		owner: 	a TransformWithLayoutMorph(751302656)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1049297664) a RubCursor(29120998...etc...
		fullBounds: 	(0@0) corner: (922@240)
		color: 	Color transparent
		extension: 	a MorphExtension (671895040) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(1016588800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(291209984)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(927102720)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@240)
		owner: 	a TransformWithLayoutMorph(751302656)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1049297664) a RubCursor(29120998...etc...
		fullBounds: 	(0@0) corner: (922@240)
		color: 	Color transparent
		extension: 	a MorphExtension (671895040) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(1016588800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(291209984)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(927102720)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(78@651.0) corner: (94@667.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(78@651.0) corner: (94@667.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(927102720)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(86@660) mouseOver 10969098 nil]
		targetOffset: 	(345@209)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 10969098 86 660 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(927102720)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(78@651.0) corner: (94@667.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(78@651.0) corner: (94@667.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(927102720)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(86@660) mouseOver 10969098 nil]
		targetOffset: 	(345@209)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 10969098 86 660 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(927102720)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(78@651.0) corner: (94@667.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(78@651.0) corner: (94@667.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(927102720)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(86@660) mouseOver 10969098 nil]
		targetOffset: 	(345@209)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 10969098 86 660 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendKeyboardEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(78@651.0) corner: (94@667.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(78@651.0) corner: (94@667.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(927102720)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(86@660) mouseOver 10969098 nil]
		targetOffset: 	(345@209)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 10969098 86 660 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #equals:
CarRentalTest class>>DoIt
OpalCompiler>>evaluate
ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
ClyTextEditor>>printIt
[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
OrderedCollection>>do:
CmdKMDispatcher(KMDispatcher)>>dispatch:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #equals:
22 June 2019 1:19:41.174207 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #equals:
	Receiver: 3
	Arguments and temporary variables: 
		aMessage: 	equals: 3
		exception: 	MessageNotUnderstood: SmallInteger>>equals:
		resumeValue: 	nil
	Receiver's instance variables: 
3

CarRentalTest class>>DoIt
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set(#testC...etc...


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| carRental redPanda yellowPanda blackTesla |
	carRental := CarRenta...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	CarRentalTest
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	CarRentalTest
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(927102720)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(927102720)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>evaluateSelection
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(927102720)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>doIt
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(927102720)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>doIt:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(927102720)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(927102720)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(927102720)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(927102720)
		secondArg: 	a RubEditingArea(927102720)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(927102720)
		secondArg: 	a RubEditingArea(927102720)
		thirdArg: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(927102720)
		category: 	a KMCategory
		morph: 	a RubEditingArea(927102720)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	18
		each: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aListener: 	a CmdKMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(927102720)
		category: 	a KMCategory
		morph: 	a RubEditingArea(927102720)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(927102720)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(446753792)


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#RubTextEditor) aKMCategoryT...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#RubTextEditor) aKMCat...etc...
		firstIndex: 	1
		lastIndex: 	4


CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(927102720)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(446753792)


CmdKMDispatcher>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		executed: 	false
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		context: 	a ClySourceCodeContext
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(927102720)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(446753792)


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(927102720)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(927102720)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(446753792)


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(927102720)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@240)
		owner: 	a TransformWithLayoutMorph(751302656)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1049297664) a RubCursor(29120998...etc...
		fullBounds: 	(0@0) corner: (922@240)
		color: 	Color transparent
		extension: 	a MorphExtension (671895040) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(1016588800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(291209984)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(927102720)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@240)
		owner: 	a TransformWithLayoutMorph(751302656)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1049297664) a RubCursor(29120998...etc...
		fullBounds: 	(0@0) corner: (922@240)
		color: 	Color transparent
		extension: 	a MorphExtension (671895040) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(1016588800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(291209984)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-d>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(927102720)
	Receiver's instance variables: 
		timeStamp: 	11041478
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(370@128.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	100


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(927102720)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@240)
		owner: 	a TransformWithLayoutMorph(751302656)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1049297664) a RubCursor(29120998...etc...
		fullBounds: 	(0@0) corner: (922@240)
		color: 	Color transparent
		extension: 	a MorphExtension (671895040) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(1016588800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(291209984)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(927102720)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@240)
		owner: 	a TransformWithLayoutMorph(751302656)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1049297664) a RubCursor(29120998...etc...
		fullBounds: 	(0@0) corner: (922@240)
		color: 	Color transparent
		extension: 	a MorphExtension (671895040) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(1016588800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(291209984)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a RubEditingArea(927102720)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(445@742.0) corner: (461@758.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(445@742.0) corner: (461@758.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(927102720)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(453@751) mouseOver CTRL 11041349 nil]
		targetOffset: 	(349@208)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11041349 453 751 0 2 0 1)
		lastKeyScanCode: 	100
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a RubEditingArea(927102720)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(445@742.0) corner: (461@758.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(445@742.0) corner: (461@758.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(927102720)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(453@751) mouseOver CTRL 11041349 nil]
		targetOffset: 	(349@208)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11041349 453 751 0 2 0 1)
		lastKeyScanCode: 	100
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #equals:
CarRentalTest class>>DoIt
OpalCompiler>>evaluate
ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
ClyTextEditor(RubSmalltalkEditor)>>evaluateSelection
ClyTextEditor(RubSmalltalkEditor)>>doIt
ClyTextEditor(RubSmalltalkEditor)>>doIt:
[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
OrderedCollection>>do:
CmdKMDispatcher(KMDispatcher)>>dispatch:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #equals:
22 June 2019 1:19:46.631296 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #equals:
	Receiver: 3
	Arguments and temporary variables: 
		aMessage: 	equals: 3
		exception: 	MessageNotUnderstood: SmallInteger>>equals:
		resumeValue: 	nil
	Receiver's instance variables: 
3

Message>>sentTo:
	Receiver: equals: 3
	Arguments and temporary variables: 
		receiver: 	3
	Receiver's instance variables: 
		selector: 	#equals:
		args: 	#(3)
		lookupClass: 	SmallInteger


SmallInteger(Object)>>doesNotUnderstand: #equals:
	Receiver: 3
	Arguments and temporary variables: 
		aMessage: 	equals: 3
		exception: 	MessageNotUnderstood: SmallInteger>>equals:
		resumeValue: 	MessageNotUnderstood: SmallInteger>>equals:
	Receiver's instance variables: 
3

CarRentalTest class>>DoIt
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set(#testC...etc...


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| carRental redPanda yellowPanda blackTesla |
	carRental := CarRenta...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	CarRentalTest
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | result ]
		result: 	nil
		rcvr: 	CarRentalTest
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(927102720)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(927102720)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>evaluateSelection
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(927102720)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>doIt
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(927102720)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>doIt:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aKeyboardEvent: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(927102720)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(927102720)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(927102720)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(927102720)
		secondArg: 	a RubEditingArea(927102720)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor doIt: nil ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(927102720)
		secondArg: 	a RubEditingArea(927102720)
		thirdArg: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	556
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(927102720)
		category: 	a KMCategory
		morph: 	a RubEditingArea(927102720)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #doIt on Meta + d do [ :target | target editor doIt: nil ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor doIt: nil ]
		name: 	#doIt
		shortcut: 	Meta + d
		defaultShortcut: 	Meta + d
		description: 	'Do it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
		entry: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	18
		each: 	#doIt on Meta + d do [ :target | target editor doIt: nil ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aListener: 	a CmdKMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(927102720)
		category: 	a KMCategory
		morph: 	a RubEditingArea(927102720)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(927102720)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(446753792)


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#RubTextEditor) aKMCategoryT...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#RubTextEditor) aKMCat...etc...
		firstIndex: 	1
		lastIndex: 	4


CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(927102720)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(446753792)


CmdKMDispatcher>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		executed: 	false
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
		context: 	a ClySourceCodeContext
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(927102720)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(446753792)


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-d>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(927102720)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-d>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(927102720)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(446753792)


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(927102720)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@240)
		owner: 	a TransformWithLayoutMorph(751302656)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1049297664) a RubCursor(29120998...etc...
		fullBounds: 	(0@0) corner: (922@240)
		color: 	Color transparent
		extension: 	a MorphExtension (671895040) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(1016588800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(291209984)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(927102720)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@240)
		owner: 	a TransformWithLayoutMorph(751302656)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1049297664) a RubCursor(29120998...etc...
		fullBounds: 	(0@0) corner: (922@240)
		color: 	Color transparent
		extension: 	a MorphExtension (671895040) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(1016588800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(291209984)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-d>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(927102720)
	Receiver's instance variables: 
		timeStamp: 	11041478
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(370@128.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	100
		charCode: 	100
		scanCode: 	100


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(927102720)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@240)
		owner: 	a TransformWithLayoutMorph(751302656)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1049297664) a RubCursor(29120998...etc...
		fullBounds: 	(0@0) corner: (922@240)
		color: 	Color transparent
		extension: 	a MorphExtension (671895040) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(1016588800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(291209984)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(927102720)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (922@240)
		owner: 	a TransformWithLayoutMorph(751302656)
		submorphs: 	an Array(a RubPrimarySelectionMorph(1049297664) a RubCursor(29120998...etc...
		fullBounds: 	(0@0) corner: (922@240)
		color: 	Color transparent
		extension: 	a MorphExtension (671895040) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(1016588800)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(291209984)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-d>']
		focusHolder: 	a RubEditingArea(927102720)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1062@248.0) corner: (1078@264.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(1062@248.0) corner: (1078@264.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a FTTableMorph(1007475968)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1062@248) mouseUp 11046941 nil]
		targetOffset: 	(28.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 11046941 1062 248 0 0 0 1)
		lastKeyScanCode: 	100
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #equals:
Message>>sentTo:
SmallInteger(Object)>>doesNotUnderstand: #equals:
CarRentalTest class>>DoIt
OpalCompiler>>evaluate
ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
ClyTextEditor(RubSmalltalkEditor)>>evaluateSelection
ClyTextEditor(RubSmalltalkEditor)>>doIt
ClyTextEditor(RubSmalltalkEditor)>>doIt:
[ :target | target editor doIt: nil ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
OrderedCollection>>do:
CmdKMDispatcher(KMDispatcher)>>dispatch:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #equals:
22 June 2019 1:20:43.523185 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #equals:
	Receiver: 3
	Arguments and temporary variables: 
		aMessage: 	equals: 3
		exception: 	MessageNotUnderstood: SmallInteger>>equals:
		resumeValue: 	nil
	Receiver's instance variables: 
3

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ 3 equals: 3
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	11103836
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	11103837
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	11103836
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	11103837
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	11103786
		lastStepMessage: 	nil
		lastCycleTime: 	11103835
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	11103786
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	11103837
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	11103786
		lastStepMessage: 	nil
		lastCycleTime: 	11103835
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	11103786
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	11103786
		lastStepMessage: 	nil
		lastCycleTime: 	11103835
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	11103786
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	11103786
		lastStepMessage: 	nil
		lastCycleTime: 	11103835
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	11103786
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	11103786
		lastStepMessage: 	nil
		lastCycleTime: 	11103835
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	11103786
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #equals:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #isSame:
22 June 2019 1:22:45.109803 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #isSame:
	Receiver: 3
	Arguments and temporary variables: 
		aMessage: 	isSame: 3
		exception: 	MessageNotUnderstood: SmallInteger>>isSame:
		resumeValue: 	nil
	Receiver's instance variables: 
3

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ 3 isSame: 3
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	11225396
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	11225422
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	11225396
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	11225422
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	11225396
		lastStepMessage: 	nil
		lastCycleTime: 	11225422
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	11225396
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	11225422
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	11225396
		lastStepMessage: 	nil
		lastCycleTime: 	11225422
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	11225396
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	11225396
		lastStepMessage: 	nil
		lastCycleTime: 	11225422
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	11225396
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	11225396
		lastStepMessage: 	nil
		lastCycleTime: 	11225422
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	11225396
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(440081152) named: Pl...etc...
		lastStepTime: 	11225396
		lastStepMessage: 	nil
		lastCycleTime: 	11225422
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	11225396
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #isSame:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#assert:equals: was sent to nil
22 June 2019 1:24:57.218707 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #assert:equals:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	assert: 3 equals: 3
		exception: 	MessageNotUnderstood: receiver of "assert:equals:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ self assert: 3 equals: 3
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(390587648)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(613743872)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	11357528
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	11357531
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	11357528
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	11357531
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	11357480
		lastStepMessage: 	nil
		lastCycleTime: 	11357531
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	11357480
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	11357531
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	11357480
		lastStepMessage: 	nil
		lastCycleTime: 	11357531
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	11357480
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	11357480
		lastStepMessage: 	nil
		lastCycleTime: 	11357531
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	11357480
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	11357480
		lastStepMessage: 	nil
		lastCycleTime: 	11357531
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	11357480
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(251925504) named: Pl...etc...
		lastStepTime: 	11357480
		lastStepMessage: 	nil
		lastCycleTime: 	11357531
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(874432000)))
		lastAlarmTime: 	11357480
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #assert:equals:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 1:27:30.771111 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:27:30.759725+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:27:30.759725+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRentingWithDates) #failures->a Set() ...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))


--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Date did not understand #@
22 June 2019 1:27:39.662967 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Date(Object)>>doesNotUnderstand: #@
	Receiver: 22 June 2019
	Arguments and temporary variables: 
		aMessage: 	@ 26 June 2019
		exception: 	MessageNotUnderstood: Date>>@
		resumeValue: 	nil
	Receiver's instance variables: 
		start: 	2019-06-22T00:00:00+02:00
		duration: 	1:00:00:00


CarRental>>rent:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		numDays: 	5
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		carRentalDates: 	a Dictionary(a Car->a SortedCollection() a Car->a SortedCollect...etc...


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:27:30.759725+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:27:30.759725+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRentingWithDates) #failures->a Set() ...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
Date(Object)>>doesNotUnderstand: #@
CarRental>>rent:days:
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Date did not understand #@
22 June 2019 1:31:20.18698 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Date(Object)>>doesNotUnderstand: #@
	Receiver: 22 June 2019
	Arguments and temporary variables: 
		aMessage: 	@ 23 June 2019
		exception: 	MessageNotUnderstood: Date>>@
		resumeValue: 	nil
	Receiver's instance variables: 
		start: 	2019-06-22T00:00:00+02:00
		duration: 	1:00:00:00


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	numDays := 2.
	^ Date today @ (Date today + numDays days - 1 day)
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(351254016)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(351254016)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(1062045184)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	11740473
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	11740499
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	11740473
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	11740499
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11740472
		lastStepMessage: 	nil
		lastCycleTime: 	11740499
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11740472
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	11740499
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11740472
		lastStepMessage: 	nil
		lastCycleTime: 	11740499
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11740472
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11740472
		lastStepMessage: 	nil
		lastCycleTime: 	11740499
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11740472
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11740472
		lastStepMessage: 	nil
		lastCycleTime: 	11740499
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11740472
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11740472
		lastStepMessage: 	nil
		lastCycleTime: 	11740499
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11740472
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
Date(Object)>>doesNotUnderstand: #@
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Date did not understand #@
22 June 2019 1:31:35.629907 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Date(Object)>>doesNotUnderstand: #@
	Receiver: 22 June 2019
	Arguments and temporary variables: 
		aMessage: 	@ 23 June 2019
		exception: 	MessageNotUnderstood: Date>>@
		resumeValue: 	nil
	Receiver's instance variables: 
		start: 	2019-06-22T00:00:00+02:00
		duration: 	1:00:00:00


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Date today @ (Date today + numDays days - 1 day)
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(351254016)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(351254016)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(1062045184)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(351254016)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (699@50)
		owner: 	a TransformWithLayoutMorph(97194240)
		submorphs: 	an Array(a RubCursor(936978432) a RubPrimarySelectionMorph(134787840...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (378711296) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(385235200)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(936978432)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(935918848))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(1062045184)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11755900
		lastStepMessage: 	nil
		lastCycleTime: 	11755939
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11755900
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11755900
		lastStepMessage: 	nil
		lastCycleTime: 	11755939
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11755900
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11755900
		lastStepMessage: 	nil
		lastCycleTime: 	11755939
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11755900
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
Date(Object)>>doesNotUnderstand: #@
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Date did not understand #@
22 June 2019 1:31:40.99029 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Date(Object)>>doesNotUnderstand: #@
	Receiver: 22 June 2019
	Arguments and temporary variables: 
		aMessage: 	@ 23 June 2019
		exception: 	MessageNotUnderstood: Date>>@
		resumeValue: 	nil
	Receiver's instance variables: 
		start: 	2019-06-22T00:00:00+02:00
		duration: 	1:00:00:00


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Date today @ (Date today + numDays days - 1 days)
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(351254016)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(351254016)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(1062045184)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(351254016)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (699@50)
		owner: 	a TransformWithLayoutMorph(97194240)
		submorphs: 	an Array(a RubCursor(936978432) a RubPrimarySelectionMorph(134787840...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (378711296) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(385235200)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(936978432)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(123037184))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(1062045184)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11761247
		lastStepMessage: 	nil
		lastCycleTime: 	11761301
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11761247
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11761247
		lastStepMessage: 	nil
		lastCycleTime: 	11761301
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11761247
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11761247
		lastStepMessage: 	nil
		lastCycleTime: 	11761301
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11761247
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
Date(Object)>>doesNotUnderstand: #@
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Date did not understand #@
22 June 2019 1:32:21.182643 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Date(Object)>>doesNotUnderstand: #@
	Receiver: 22 June 2019
	Arguments and temporary variables: 
		aMessage: 	@ 3
		exception: 	MessageNotUnderstood: Date>>@
		resumeValue: 	nil
	Receiver's instance variables: 
		start: 	2019-06-22T00:00:00+02:00
		duration: 	1:00:00:00


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Date today @ 3
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(351254016)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(351254016)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(1062045184)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	11801461
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	11801495
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	11801461
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	11801495
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11801452
		lastStepMessage: 	nil
		lastCycleTime: 	11801495
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11801452
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	11801495
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11801452
		lastStepMessage: 	nil
		lastCycleTime: 	11801495
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11801452
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11801452
		lastStepMessage: 	nil
		lastCycleTime: 	11801495
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11801452
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11801452
		lastStepMessage: 	nil
		lastCycleTime: 	11801495
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11801452
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11801452
		lastStepMessage: 	nil
		lastCycleTime: 	11801495
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11801452
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
Date(Object)>>doesNotUnderstand: #@
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Date did not understand #@
22 June 2019 1:32:33.200988 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Date(Object)>>doesNotUnderstand: #@
	Receiver: 22 June 2019
	Arguments and temporary variables: 
		aMessage: 	@ 3
		exception: 	MessageNotUnderstood: Date>>@
		resumeValue: 	nil
	Receiver's instance variables: 
		start: 	2019-06-22T00:00:00+02:00
		duration: 	1:00:00:00


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Date today @ 3
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(351254016)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(351254016)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(1062045184)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(351254016)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (699@69)
		owner: 	a TransformWithLayoutMorph(97194240)
		submorphs: 	an Array(a RubPrimarySelectionMorph(412184832) a RubCursor(936978432...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (378711296) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(385235200)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(936978432)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(58217472))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(1062045184)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11813462
		lastStepMessage: 	nil
		lastCycleTime: 	11813511
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11813462
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11813462
		lastStepMessage: 	nil
		lastCycleTime: 	11813511
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11813462
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11813462
		lastStepMessage: 	nil
		lastCycleTime: 	11813511
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11813462
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
Date(Object)>>doesNotUnderstand: #@
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Date did not understand #@
22 June 2019 1:34:20.198033 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Date(Object)>>doesNotUnderstand: #@
	Receiver: 22 June 2019
	Arguments and temporary variables: 
		aMessage: 	@ 22 June 2019
		exception: 	MessageNotUnderstood: Date>>@
		resumeValue: 	nil
	Receiver's instance variables: 
		start: 	2019-06-22T00:00:00+02:00
		duration: 	1:00:00:00


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Date today @ Date today
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(351254016)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(351254016)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(1062045184)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	11920510
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	11920511
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	11920510
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	11920511
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11920460
		lastStepMessage: 	nil
		lastCycleTime: 	11920511
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11920460
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	11920511
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11920460
		lastStepMessage: 	nil
		lastCycleTime: 	11920511
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11920460
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11920460
		lastStepMessage: 	nil
		lastCycleTime: 	11920511
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11920460
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11920460
		lastStepMessage: 	nil
		lastCycleTime: 	11920511
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11920460
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11920460
		lastStepMessage: 	nil
		lastCycleTime: 	11920511
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11920460
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
Date(Object)>>doesNotUnderstand: #@
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Character did not understand #@
22 June 2019 1:34:35.534122 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Character(Object)>>doesNotUnderstand: #@
	Receiver: $a
	Arguments and temporary variables: 
		aMessage: 	@ $b
		exception: 	MessageNotUnderstood: Character>>@
		resumeValue: 	nil
	Receiver's instance variables: 
$a

[ :a :b | a @ b ] in ByteString(SequenceableCollection)>>@
	Receiver: 'a'
	Arguments and temporary variables: 
		aCollection: 	'b'
		a: 	$a
		b: 	$b
	Receiver's instance variables: 
'a'

ByteString(SequenceableCollection)>>with:collect:
	Receiver: 'a'
	Arguments and temporary variables: 
		otherCollection: 	'b'
		twoArgBlock: 	[ :a :b | a @ b ]
		result: 	' '
		index: 	1
	Receiver's instance variables: 
'a'

ByteString(SequenceableCollection)>>@
	Receiver: 'a'
	Arguments and temporary variables: 
		aCollection: 	'b'
	Receiver's instance variables: 
'a'

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ 'a' @ 'b'
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(351254016)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(351254016)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(1062045184)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	11935810
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	11935844
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	11935810
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	11935844
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11935795
		lastStepMessage: 	nil
		lastCycleTime: 	11935844
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11935795
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	11935844
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11935795
		lastStepMessage: 	nil
		lastCycleTime: 	11935844
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11935795
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11935795
		lastStepMessage: 	nil
		lastCycleTime: 	11935844
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11935795
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11935795
		lastStepMessage: 	nil
		lastCycleTime: 	11935844
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11935795
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	11935795
		lastStepMessage: 	nil
		lastCycleTime: 	11935844
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	11935795
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
Character(Object)>>doesNotUnderstand: #@
[ :a :b | a @ b ] in ByteString(SequenceableCollection)>>@
ByteString(SequenceableCollection)>>with:collect:
ByteString(SequenceableCollection)>>@
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
UnwindError
22 June 2019 1:37:43.157997 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil)
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil)
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection>>remove:ifAbsent:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
		absentBlock: 	[ self errorNotFound: oldObject ]
		index: 	1
	Receiver's instance variables: 
		array: 	#(nil nil)
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>remove:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil)
		firstIndex: 	1
		lastIndex: 	0


Breakpoint>>remove
	Receiver: a Breakpoint
	Arguments and temporary variables: 

	Receiver's instance variables: 
		condition: 	nil
		link: 	a MetaLink
		node: 	testRenting
	"The same car cannot be rented twice. Extend the code to mak...etc...
		level: 	nil
		options: 	#(#+ #optionCompileOnLinkInstallation #+ #optionAnnounce)


[ breakpoint remove ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Context>>resume:through:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		value: 	a MorphicUIManager
		firstUnwindContext: 	BlockClosure>>ensure:
		context: 	BlockClosure>>ensure:
		unwindBlock: 	[ breakpoint remove ]
	Receiver's instance variables: 
		sender: 	nil
		pc: 	nil
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ chain := thisContext sender cut: ctxt.
ctxt jump ]


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	true
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))

ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyDebugTestCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyDebugTestCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(998430464)
		selectedItems: 	an Array(a ClyDataSourceItem(testRenting))
		metaLevelScope: 	ClyInstanceSideScope


[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyDebugTestCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyDebugTestCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)


BlockClosure>>on:do:
	Receiver: [ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCom...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	77
		numArgs: 	0


CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyDebugTestCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyDebugTestCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)


[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(1041837824)'Debug tests'
	Arguments and temporary variables: 
		evt: 	[(878@707) mouseUp 10403016 nil]
		w: 	a WorldMorph(275485952) [world]
		selArgCount: 	0
	Receiver's instance variables: 
		bounds: 	(825.0@696.0) corner: (1001.0@714.0)
		owner: 	a MenuMorph(866368256)
		submorphs: 	#()
		fullBounds: 	(825.0@696.0) corner: (1001.0@714.0)
		color: 	Color black
		extension: 	a MorphExtension (817758208)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


BlockClosure>>ensure:
	Receiver: [ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := select...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	230
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |
"show cursor in case item opens a new MVC window"
(se...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(1041837824)'Debug tests'
	Arguments and temporary variables: 
		evt: 	[(878@707) mouseUp 10403016 nil]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(825.0@696.0) corner: (1001.0@714.0)
		owner: 	a MenuMorph(866368256)
		submorphs: 	#()
		fullBounds: 	(825.0@696.0) corner: (1001.0@714.0)
		color: 	Color black
		extension: 	a MorphExtension (817758208)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(1041837824)'Debug tests'
	Arguments and temporary variables: 
		evt: 	[(878@707) mouseUp 10403016 nil]
	Receiver's instance variables: 
		bounds: 	(825.0@696.0) corner: (1001.0@714.0)
		owner: 	a MenuMorph(866368256)
		submorphs: 	#()
		fullBounds: 	(825.0@696.0) corner: (1001.0@714.0)
		color: 	Color black
		extension: 	a MorphExtension (817758208)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(1041837824)'Debug tests'
	Arguments and temporary variables: 
		anEvent: 	[(878@707) mouseUp 10403016 nil]
	Receiver's instance variables: 
		bounds: 	(825.0@696.0) corner: (1001.0@714.0)
		owner: 	a MenuMorph(866368256)
		submorphs: 	#()
		fullBounds: 	(825.0@696.0) corner: (1001.0@714.0)
		color: 	Color black
		extension: 	a MorphExtension (817758208)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(878@707) mouseUp 10403016 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(1041837824)'Debug tests'
	Receiver's instance variables: 
		timeStamp: 	10403016
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(878@707)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(1041837824)'Debug tests'
	Arguments and temporary variables: 
		anEvent: 	[(878@707) mouseUp 10403016 nil]
	Receiver's instance variables: 
		bounds: 	(825.0@696.0) corner: (1001.0@714.0)
		owner: 	a MenuMorph(866368256)
		submorphs: 	#()
		fullBounds: 	(825.0@696.0) corner: (1001.0@714.0)
		color: 	Color black
		extension: 	a MorphExtension (817758208)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(878@707) mouseUp 10403016 nil]
		aMorph: 	a ToggleMenuItemMorph(1041837824)'Debug tests'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(878@707) mouseUp 10403016 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(878@707) mouseUp 10403016 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	10403016
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(878@707)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(878@707) mouseUp 10403016 nil]
		aMorph: 	a ToggleMenuItemMorph(1041837824)'Debug tests'
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(878@707) mouseUp 10403016 nil]
		aMorph: 	a ToggleMenuItemMorph(1041837824)'Debug tests'
	Receiver's instance variables: 
		morph: 	nil


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(1041837824)'Debug tests'
	Arguments and temporary variables: 
		anEvent: 	[(878@707) mouseUp 10403016 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(825.0@696.0) corner: (1001.0@714.0)
		owner: 	a MenuMorph(866368256)
		submorphs: 	#()
		fullBounds: 	(825.0@696.0) corner: (1001.0@714.0)
		color: 	Color black
		extension: 	a MorphExtension (817758208)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(878@707) mouseUp 10403016 nil]
		aMorph: 	a MenuMorph(866368256)
		localEvt: 	[(878@707) mouseUp 10403016 nil]
		index: 	17
		child: 	a ToggleMenuItemMorph(1041837824)'Debug tests'
		morphs: 	an Array(a ToggleMenuItemMorph(449417216)'Browse' a ToggleMenuItemMorph...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(878@707) mouseUp 10403016 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(878@707) mouseUp 10403016 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	10403016
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(878@707)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(878@707) mouseUp 10403016 nil]
		aMorph: 	a MenuMorph(866368256)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove:
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
Breakpoint>>remove
[ breakpoint remove ] in ClyDebugTestCommand>>runTest:of:
Context>>resume:through:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 1:40:10.910581 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:40:10.899612+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:40:10.899612+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))


--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Dictionary did not understand #at:add:
22 June 2019 1:40:14.180526 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Dictionary(Object)>>doesNotUnderstand: #at:add:
	Receiver: a Dictionary(a Car->a SortedCollection() a Car->a SortedCollection() a Car->a SortedCollec...etc...
	Arguments and temporary variables: 
		aMessage: 	at: a Car add: an Array(22 June 2019 26 June 2019)
		exception: 	MessageNotUnderstood: Dictionary>>at:add:
		resumeValue: 	nil
	Receiver's instance variables: 
		tally: 	3
		array: 	an Array(a Car->a SortedCollection() a Car->a SortedCollection() nil nil...etc...


CarRental>>rent:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		numDays: 	5
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		carRentalDates: 	a Dictionary(a Car->a SortedCollection() a Car->a SortedCollect...etc...


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:40:10.899612+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T13:40:10.899612+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
Dictionary(Object)>>doesNotUnderstand: #at:add:
CarRental>>rent:days:
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Array did not understand #'<='
22 June 2019 1:42:35.820536 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Array(Object)>>doesNotUnderstand: #'<='
	Receiver: an Array(22 June 2019 23 June 2019)
	Arguments and temporary variables: 
		aMessage: 	<= an Array(21 June 2019 23 June 2019)
		exception: 	MessageNotUnderstood: Array>><=
		resumeValue: 	nil
	Receiver's instance variables: 
an Array(22 June 2019 23 June 2019)

SortedCollection>>indexForInserting:
	Receiver: a SortedCollection(an Array(22 June 2019 23 June 2019))
	Arguments and temporary variables: 
		newObject: 	an Array(21 June 2019 23 June 2019)
		index: 	10
		low: 	10
		high: 	10
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil an Array(22 June 2019 23 Ju...etc...
		firstIndex: 	10
		lastIndex: 	10
		sortBlock: 	nil


SortedCollection>>add:
	Receiver: a SortedCollection(an Array(22 June 2019 23 June 2019))
	Arguments and temporary variables: 
		newObject: 	an Array(21 June 2019 23 June 2019)
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil an Array(22 June 2019 23 Ju...etc...
		firstIndex: 	10
		lastIndex: 	10
		sortBlock: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ coll add: array2
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(351254016)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(351254016)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(1062045184)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(351254016)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (699@202)
		owner: 	a TransformWithLayoutMorph(97194240)
		submorphs: 	an Array(a RubPrimarySelectionMorph(949992192) a RubCursor(936978432...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (378711296) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(385235200)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(936978432)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(284736512))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(1062045184)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	12416103
		lastStepMessage: 	nil
		lastCycleTime: 	12416132
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	12416103
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	12416103
		lastStepMessage: 	nil
		lastCycleTime: 	12416132
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	12416103
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	12416103
		lastStepMessage: 	nil
		lastCycleTime: 	12416132
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	12416103
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
Array(Object)>>doesNotUnderstand: #'<='
SortedCollection>>indexForInserting:
SortedCollection>>add:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Array did not understand #'<='
22 June 2019 1:42:40.264592 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Array(Object)>>doesNotUnderstand: #'<='
	Receiver: an Array(22 June 2019 23 June 2019)
	Arguments and temporary variables: 
		aMessage: 	<= an Array(21 June 2019 23 June 2019)
		exception: 	MessageNotUnderstood: Array>><=
		resumeValue: 	nil
	Receiver's instance variables: 
an Array(22 June 2019 23 June 2019)

SortedCollection>>indexForInserting:
	Receiver: a SortedCollection(an Array(22 June 2019 23 June 2019))
	Arguments and temporary variables: 
		newObject: 	an Array(21 June 2019 23 June 2019)
		index: 	10
		low: 	10
		high: 	10
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil an Array(22 June 2019 23 Ju...etc...
		firstIndex: 	10
		lastIndex: 	10
		sortBlock: 	nil


SortedCollection>>add:
	Receiver: a SortedCollection(an Array(22 June 2019 23 June 2019))
	Arguments and temporary variables: 
		newObject: 	an Array(21 June 2019 23 June 2019)
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil an Array(22 June 2019 23 Ju...etc...
		firstIndex: 	10
		lastIndex: 	10
		sortBlock: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ coll add: array2
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(351254016)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(351254016)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(1062045184)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(351254016)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (699@202)
		owner: 	a TransformWithLayoutMorph(97194240)
		submorphs: 	an Array(a RubPrimarySelectionMorph(949992192) a RubCursor(936978432...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (378711296) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(385235200)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(936978432)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(401127936))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(1062045184)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	12420535
		lastStepMessage: 	nil
		lastCycleTime: 	12420574
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	12420535
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	12420535
		lastStepMessage: 	nil
		lastCycleTime: 	12420574
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	12420535
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(501246720) named: Pl...etc...
		lastStepTime: 	12420535
		lastStepMessage: 	nil
		lastCycleTime: 	12420574
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(936978432)))
		lastAlarmTime: 	12420535
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
Array(Object)>>doesNotUnderstand: #'<='
SortedCollection>>indexForInserting:
SortedCollection>>add:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 2:16:12.996292 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:16:12.986446+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:16:12.986446+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))


--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Dictionary did not understand #at:add:
22 June 2019 2:16:17.057966 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Dictionary(Object)>>doesNotUnderstand: #at:add:
	Receiver: a Dictionary(a Car->a SortedCollection() a Car->a SortedCollection() a Car->a SortedCollec...etc...
	Arguments and temporary variables: 
		aMessage: 	at: a Car add: 22 June 2019
		exception: 	MessageNotUnderstood: Dictionary>>at:add:
		resumeValue: 	nil
	Receiver's instance variables: 
		tally: 	3
		array: 	an Array(a Car->a SortedCollection() nil a Car->a SortedCollection() a C...etc...


CarRental>>rent:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		numDays: 	5
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:16:12.986446+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:16:12.986446+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
Dictionary(Object)>>doesNotUnderstand: #at:add:
CarRental>>rent:days:
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Dictionary did not understand #at:add:
22 June 2019 2:20:58.697302 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

Dictionary(Object)>>doesNotUnderstand: #at:add:
	Receiver: a Dictionary('test'->a SortedCollection() )
	Arguments and temporary variables: 
		aMessage: 	at: 'test' add: 3
		exception: 	MessageNotUnderstood: Dictionary>>at:add:
		resumeValue: 	nil
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil nil nil 'test'->a SortedCollection())


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ dict at: 'test' add: 3
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(211897600)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(211897600)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(741406464)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(211897600)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (699@69)
		owner: 	a TransformWithLayoutMorph(838570496)
		submorphs: 	an Array(a RubPrimarySelectionMorph(789433088) a RubCursor(850890496...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (826449920) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(995844096)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(850890496)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(222528000))
		getMenuPolicy: 	nil
		mouseDownPoint: 	(260.0@285.0)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(741406464)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(782857216) named: Pl...etc...
		lastStepTime: 	14718953
		lastStepMessage: 	nil
		lastCycleTime: 	14719008
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(850890496)))
		lastAlarmTime: 	14718953
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(782857216) named: Pl...etc...
		lastStepTime: 	14718953
		lastStepMessage: 	nil
		lastCycleTime: 	14719008
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(850890496)))
		lastAlarmTime: 	14718953
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(782857216) named: Pl...etc...
		lastStepTime: 	14718953
		lastStepMessage: 	nil
		lastCycleTime: 	14719008
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(850890496)))
		lastAlarmTime: 	14718953
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
Dictionary(Object)>>doesNotUnderstand: #at:add:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 2:22:14.817162 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:22:14.805519+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:22:14.805519+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))


--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: This block accepts 0 arguments, but was called with 1 argument.
22 June 2019 2:22:17.988911 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

BlockClosure(Object)>>error:
	Receiver: [ ^ false ]
	Arguments and temporary variables: 
		aString: 	'This block accepts 0 arguments, but was called with 1 argument.'
	Receiver's instance variables: 
		outerContext: 	CarRental>>isAvailable:startingOn:days:
		startpc: 	115
		numArgs: 	0


BlockClosure>>numArgsError:
	Receiver: [ ^ false ]
	Arguments and temporary variables: 
		numArgsForInvocation: 	1
		printNArgs: 	[ :n | 
n printString , ' argument'
	,
		(n = 1
			ifTrue: [ '' ]
	...etc...
	Receiver's instance variables: 
		outerContext: 	CarRental>>isAvailable:startingOn:days:
		startpc: 	115
		numArgs: 	0


BlockClosure>>value:
	Receiver: [ ^ false ]
	Arguments and temporary variables: 
		anArg: 	1
	Receiver's instance variables: 
		outerContext: 	CarRental>>isAvailable:startingOn:days:
		startpc: 	115
		numArgs: 	0


SortedCollection(SequenceableCollection)>>findBinaryIndex:do:ifNone:
	Receiver: a SortedCollection(22 June 2019)
	Arguments and temporary variables: 
		aBlock: 	[ :arg | (arg - date) asDays ]
		actionBlock: 	[ ^ false ]
		exceptionBlock: 	[ :prev :next | next ]
		index: 	1
		low: 	1
		high: 	1
		test: 	0.0
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil 22 June 2019)
		firstIndex: 	10
		lastIndex: 	10
		sortBlock: 	nil


CarRental>>isAvailable:startingOn:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		date: 	22 June 2019
		numDays: 	1
		rentalStartingDates: 	a SortedCollection(22 June 2019)
		rentalEndingDates: 	a SortedCollection(26 June 2019)
		idxPrevRentalDate: 	1
		idxNextRentalDate: 	nil
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
		aCar: 	a Car
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Car a Car a Car)
	Arguments and temporary variables: 
		selectBlock: 	[ :aCar | self isAvailable: aCar startingOn: date days: numDays ]
		newCollection: 	an OrderedCollection()
		element: 	a Car
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Car a Car a Car nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRental>>availableCars
	Receiver: a CarRental
	Arguments and temporary variables: 

	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:22:14.805519+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:22:14.805519+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...



--- The full stack ---
BlockClosure(Object)>>error:
BlockClosure>>numArgsError:
BlockClosure>>value:
SortedCollection(SequenceableCollection)>>findBinaryIndex:do:ifNone:
CarRental>>isAvailable:startingOn:days:
[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
OrderedCollection>>select:
CarRental>>availableCars:days:
CarRental>>availableCars
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #value:
22 June 2019 2:25:38.370432 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #value:
	Receiver: 4
	Arguments and temporary variables: 
		aMessage: 	value: 3
		exception: 	MessageNotUnderstood: SmallInteger>>value:
		resumeValue: 	nil
	Receiver's instance variables: 
4

SortedCollection(SequenceableCollection)>>findBinaryIndex:do:ifNone:
	Receiver: a SortedCollection(1 3 3 5)
	Arguments and temporary variables: 
		aBlock: 	4
		actionBlock: 	[ :found | found ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
		index: 	2
		low: 	1
		high: 	4
		test: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil 1 3 3 5)
		firstIndex: 	7
		lastIndex: 	10
		sortBlock: 	nil


SortedCollection(SequenceableCollection)>>findBinaryIndex:
	Receiver: a SortedCollection(1 3 3 5)
	Arguments and temporary variables: 
		aBlock: 	4
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil 1 3 3 5)
		firstIndex: 	7
		lastIndex: 	10
		sortBlock: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ test := (dict at: 'test') findBinaryIndex: 4
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(211897600)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(211897600)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(741406464)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	14998636
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	14998682
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	14998636
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	14998682
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(850890496)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(782857216) named: Pl...etc...
		lastStepTime: 	14998635
		lastStepMessage: 	nil
		lastCycleTime: 	14998680
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(850890496)))
		lastAlarmTime: 	14998635
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	14998682
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(782857216) named: Pl...etc...
		lastStepTime: 	14998635
		lastStepMessage: 	nil
		lastCycleTime: 	14998680
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(850890496)))
		lastAlarmTime: 	14998635
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(782857216) named: Pl...etc...
		lastStepTime: 	14998635
		lastStepMessage: 	nil
		lastCycleTime: 	14998680
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(850890496)))
		lastAlarmTime: 	14998635
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(782857216) named: Pl...etc...
		lastStepTime: 	14998635
		lastStepMessage: 	nil
		lastCycleTime: 	14998680
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(850890496)))
		lastAlarmTime: 	14998635
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(782857216) named: Pl...etc...
		lastStepTime: 	14998635
		lastStepMessage: 	nil
		lastCycleTime: 	14998680
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(850890496)))
		lastAlarmTime: 	14998635
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #value:
SortedCollection(SequenceableCollection)>>findBinaryIndex:do:ifNone:
SortedCollection(SequenceableCollection)>>findBinaryIndex:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
NotFound: [ :arg | 4 - arg ] not found in SortedCollection
22 June 2019 2:26:05.608167 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SortedCollection(Collection)>>errorNotFound:
	Receiver: a SortedCollection(1 3 3 5)
	Arguments and temporary variables: 
		anObject: 	[ :arg | 4 - arg ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil 1 3 3 5)
		firstIndex: 	7
		lastIndex: 	10
		sortBlock: 	nil


[ self errorNotFound: aBlock ] in SortedCollection(SequenceableCollection)>>findBinaryIndex:
	Receiver: a SortedCollection(1 3 3 5)
	Arguments and temporary variables: 
		aBlock: 	[ :arg | 4 - arg ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil 1 3 3 5)
		firstIndex: 	7
		lastIndex: 	10
		sortBlock: 	nil


BlockClosure>>cull:
	Receiver: [ self errorNotFound: aBlock ]
	Arguments and temporary variables: 
		anArg: 	3
	Receiver's instance variables: 
		outerContext: 	SortedCollection(SequenceableCollection)>>findBinaryIndex:
		startpc: 	54
		numArgs: 	0


BlockClosure>>cull:cull:
	Receiver: [ self errorNotFound: aBlock ]
	Arguments and temporary variables: 
		firstArg: 	3
		secondArg: 	4
	Receiver's instance variables: 
		outerContext: 	SortedCollection(SequenceableCollection)>>findBinaryIndex:
		startpc: 	54
		numArgs: 	0


SortedCollection(SequenceableCollection)>>findBinaryIndex:do:ifNone:
	Receiver: a SortedCollection(1 3 3 5)
	Arguments and temporary variables: 
		aBlock: 	[ :arg | 4 - arg ]
		actionBlock: 	[ :found | found ]
		exceptionBlock: 	[ self errorNotFound: aBlock ]
		index: 	3
		low: 	4
		high: 	3
		test: 	-1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil 1 3 3 5)
		firstIndex: 	7
		lastIndex: 	10
		sortBlock: 	nil


SortedCollection(SequenceableCollection)>>findBinaryIndex:
	Receiver: a SortedCollection(1 3 3 5)
	Arguments and temporary variables: 
		aBlock: 	[ :arg | 4 - arg ]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil 1 3 3 5)
		firstIndex: 	7
		lastIndex: 	10
		sortBlock: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ test := (dict at: 'test') findBinaryIndex: [ :arg | 4 - arg ]
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(211897600)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(211897600)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(741406464)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	15025881
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	15025917
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	15025881
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	15025917
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(850890496)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(782857216) named: Pl...etc...
		lastStepTime: 	15025880
		lastStepMessage: 	nil
		lastCycleTime: 	15025917
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(850890496)))
		lastAlarmTime: 	15025880
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		now: 	15025917
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(782857216) named: Pl...etc...
		lastStepTime: 	15025880
		lastStepMessage: 	nil
		lastCycleTime: 	15025917
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(850890496)))
		lastAlarmTime: 	15025880
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(782857216) named: Pl...etc...
		lastStepTime: 	15025880
		lastStepMessage: 	nil
		lastCycleTime: 	15025917
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(850890496)))
		lastAlarmTime: 	15025880
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(782857216) named: Pl...etc...
		lastStepTime: 	15025880
		lastStepMessage: 	nil
		lastCycleTime: 	15025917
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(850890496)))
		lastAlarmTime: 	15025880
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(782857216) named: Pl...etc...
		lastStepTime: 	15025880
		lastStepMessage: 	nil
		lastCycleTime: 	15025917
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(850890496)))
		lastAlarmTime: 	15025880
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
SortedCollection(Collection)>>errorNotFound:
[ self errorNotFound: aBlock ] in SortedCollection(SequenceableCollection)>>findBinaryIndex:
BlockClosure>>cull:
BlockClosure>>cull:cull:
SortedCollection(SequenceableCollection)>>findBinaryIndex:do:ifNone:
SortedCollection(SequenceableCollection)>>findBinaryIndex:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 2:29:31.27217 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:29:31.260515+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:29:31.260515+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))


--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: This block accepts 0 arguments, but was called with 1 argument.
22 June 2019 2:29:34.392535 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

BlockClosure(Object)>>error:
	Receiver: [ ^ false ]
	Arguments and temporary variables: 
		aString: 	'This block accepts 0 arguments, but was called with 1 argument.'
	Receiver's instance variables: 
		outerContext: 	CarRental>>isAvailable:startingOn:days:
		startpc: 	115
		numArgs: 	0


BlockClosure>>numArgsError:
	Receiver: [ ^ false ]
	Arguments and temporary variables: 
		numArgsForInvocation: 	1
		printNArgs: 	[ :n | 
n printString , ' argument'
	,
		(n = 1
			ifTrue: [ '' ]
	...etc...
	Receiver's instance variables: 
		outerContext: 	CarRental>>isAvailable:startingOn:days:
		startpc: 	115
		numArgs: 	0


BlockClosure>>value:
	Receiver: [ ^ false ]
	Arguments and temporary variables: 
		anArg: 	1
	Receiver's instance variables: 
		outerContext: 	CarRental>>isAvailable:startingOn:days:
		startpc: 	115
		numArgs: 	0


SortedCollection(SequenceableCollection)>>findBinaryIndex:do:ifNone:
	Receiver: a SortedCollection(22 June 2019)
	Arguments and temporary variables: 
		aBlock: 	[ :arg | (arg - date) asDays ]
		actionBlock: 	[ ^ false ]
		exceptionBlock: 	[ :prev :next | next ]
		index: 	1
		low: 	1
		high: 	1
		test: 	0.0
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil 22 June 2019)
		firstIndex: 	10
		lastIndex: 	10
		sortBlock: 	nil


CarRental>>isAvailable:startingOn:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		date: 	22 June 2019
		numDays: 	1
		rentalStartingDates: 	a SortedCollection(22 June 2019)
		rentalEndingDates: 	a SortedCollection(26 June 2019)
		idxPrevRentalDate: 	1
		idxNextRentalDate: 	nil
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
		aCar: 	a Car
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Car a Car a Car)
	Arguments and temporary variables: 
		selectBlock: 	[ :aCar | self isAvailable: aCar startingOn: date days: numDays ]
		newCollection: 	an OrderedCollection()
		element: 	a Car
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Car a Car a Car nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRental>>availableCars
	Receiver: a CarRental
	Arguments and temporary variables: 

	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:29:31.260515+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:29:31.260515+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...



--- The full stack ---
BlockClosure(Object)>>error:
BlockClosure>>numArgsError:
BlockClosure>>value:
SortedCollection(SequenceableCollection)>>findBinaryIndex:do:ifNone:
CarRental>>isAvailable:startingOn:days:
[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
OrderedCollection>>select:
CarRental>>availableCars:days:
CarRental>>availableCars
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 2:33:14.055919 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:33:14.044464+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:33:14.044464+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))


--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: This block accepts 0 arguments, but was called with 1 argument.
22 June 2019 2:33:16.934401 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

BlockClosure(Object)>>error:
	Receiver: [ ^ false ]
	Arguments and temporary variables: 
		aString: 	'This block accepts 0 arguments, but was called with 1 argument.'
	Receiver's instance variables: 
		outerContext: 	CarRental>>isAvailable:startingOn:days:
		startpc: 	115
		numArgs: 	0


BlockClosure>>numArgsError:
	Receiver: [ ^ false ]
	Arguments and temporary variables: 
		numArgsForInvocation: 	1
		printNArgs: 	[ :n | 
n printString , ' argument'
	,
		(n = 1
			ifTrue: [ '' ]
	...etc...
	Receiver's instance variables: 
		outerContext: 	CarRental>>isAvailable:startingOn:days:
		startpc: 	115
		numArgs: 	0


BlockClosure>>value:
	Receiver: [ ^ false ]
	Arguments and temporary variables: 
		anArg: 	1
	Receiver's instance variables: 
		outerContext: 	CarRental>>isAvailable:startingOn:days:
		startpc: 	115
		numArgs: 	0


SortedCollection(SequenceableCollection)>>findBinaryIndex:do:ifNone:
	Receiver: a SortedCollection(22 June 2019)
	Arguments and temporary variables: 
		aBlock: 	[ :arg | (date - arg) asDays ]
		actionBlock: 	[ ^ false ]
		exceptionBlock: 	[ :prev :next | next ]
		index: 	1
		low: 	1
		high: 	1
		test: 	0.0
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil 22 June 2019)
		firstIndex: 	10
		lastIndex: 	10
		sortBlock: 	nil


CarRental>>isAvailable:startingOn:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		date: 	22 June 2019
		numDays: 	1
		rentalStartingDates: 	a SortedCollection(22 June 2019)
		rentalEndingDates: 	a SortedCollection(26 June 2019)
		idxPrevRentalDate: 	0
		idxNextRentalDate: 	nil
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection(22 June 2019) a...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection(26 June 2019) a C...etc...


[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
		aCar: 	a Car
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection(22 June 2019) a...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection(26 June 2019) a C...etc...


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Car a Car a Car)
	Arguments and temporary variables: 
		selectBlock: 	[ :aCar | self isAvailable: aCar startingOn: date days: numDays ]
		newCollection: 	an OrderedCollection()
		element: 	a Car
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Car a Car a Car nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection(22 June 2019) a...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection(26 June 2019) a C...etc...


CarRental>>availableCars
	Receiver: a CarRental
	Arguments and temporary variables: 

	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection(22 June 2019) a...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection(26 June 2019) a C...etc...


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:33:14.044464+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:33:14.044464+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...



--- The full stack ---
BlockClosure(Object)>>error:
BlockClosure>>numArgsError:
BlockClosure>>value:
SortedCollection(SequenceableCollection)>>findBinaryIndex:do:ifNone:
CarRental>>isAvailable:startingOn:days:
[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
OrderedCollection>>select:
CarRental>>availableCars:days:
CarRental>>availableCars
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 2:48:55.49184 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:48:55.480361+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:48:55.480361+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))


--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
22 June 2019 2:48:56.837135 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

SortedCollection(Object)>>errorSubscriptBounds:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	nil


SortedCollection(OrderedCollection)>>at:
	Receiver: a SortedCollection()
	Arguments and temporary variables: 
		anInteger: 	1
		index: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0
		sortBlock: 	nil


CarRental>>isAvailable:startingOn:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		date: 	22 June 2019
		numDays: 	1
		rentalStartingDates: 	a SortedCollection()
		rentalEndingDates: 	a SortedCollection()
		idxPrevRentalDate: 	0
		idxNextRentalDate: 	1
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
		aCar: 	a Car
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Car a Car a Car)
	Arguments and temporary variables: 
		selectBlock: 	[ :aCar | self isAvailable: aCar startingOn: date days: numDays ]
		newCollection: 	an OrderedCollection()
		element: 	a Car
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Car a Car a Car nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRental>>availableCars
	Receiver: a CarRental
	Arguments and temporary variables: 

	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:48:55.480361+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T14:48:55.480361+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
SortedCollection(Object)>>errorSubscriptBounds:
SortedCollection(OrderedCollection)>>at:
CarRental>>isAvailable:startingOn:days:
[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
OrderedCollection>>select:
CarRental>>availableCars:days:
CarRental>>availableCars
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 3:02:35.276469 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testCustom
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:02:35.264341+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:02:35.264341+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testCustom
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testCustom #testRenting #testRentingWithD...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCustom
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCustom))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCustom
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCustom))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCustom
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCustom))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCustom)
		testSelector: 	#testCustom
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCustom))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCustom)
		testSelector: 	#testCustom
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCustom))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testCustom)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCustom))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testCustom))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testCustom))


--- The full stack ---
CarRentalTest>>testCustom
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of False did not understand #<
22 June 2019 3:02:37.362372 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

False(Object)>>doesNotUnderstand: #<
	Receiver: false
	Arguments and temporary variables: 
		aMessage: 	< 0
		exception: 	MessageNotUnderstood: False>><
		resumeValue: 	nil
	Receiver's instance variables: 
false

[ :idx | (idx > 0 & idx) < rentalEndingDates size ] in CarRental>>isAvailable:startingOn:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		date: 	22 June 2019
		numDays: 	1
		rentalStartingDates: 	a SortedCollection()
		rentalEndingDates: 	a SortedCollection()
		idxPrevRentalDate: 	0
		idxNextRentalDate: 	1
		boundsCheck: 	[ :idx | (idx > 0 & idx) < rentalEndingDates size ]
		idx: 	0
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRental>>isAvailable:startingOn:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		date: 	22 June 2019
		numDays: 	1
		rentalStartingDates: 	a SortedCollection()
		rentalEndingDates: 	a SortedCollection()
		idxPrevRentalDate: 	0
		idxNextRentalDate: 	1
		boundsCheck: 	[ :idx | (idx > 0 & idx) < rentalEndingDates size ]
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
		aCar: 	a Car
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Car a Car a Car)
	Arguments and temporary variables: 
		selectBlock: 	[ :aCar | self isAvailable: aCar startingOn: date days: numDays ]
		newCollection: 	an OrderedCollection()
		element: 	a Car
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Car a Car a Car nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRental>>availableCars
	Receiver: a CarRental
	Arguments and temporary variables: 

	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRentalTest>>testCustom
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:02:35.264341+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testCustom)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:02:35.264341+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testCustom)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testCustom
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testCustom #testRenting #testRentingWithD...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCustom
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCustom))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCustom
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCustom))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
False(Object)>>doesNotUnderstand: #<
[ :idx | (idx > 0 & idx) < rentalEndingDates size ] in CarRental>>isAvailable:startingOn:days:
CarRental>>isAvailable:startingOn:days:
[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
OrderedCollection>>select:
CarRental>>availableCars:days:
CarRental>>availableCars
CarRentalTest>>testCustom
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 3:06:06.621571 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testCustom
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCustom
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:06:06.611048+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCustom
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:06:06.611048+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCustom
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCustom
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testCustom
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates #testCu...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCustom
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCustom))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCustom
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCustom))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCustom
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCustom))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCustom)
		testSelector: 	#testCustom
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCustom))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCustom)
		testSelector: 	#testCustom
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCustom))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testCustom)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCustom))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testCustom))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testCustom))


--- The full stack ---
CarRentalTest>>testCustom
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 3:06:21.330197 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:06:21.318494+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:06:21.318494+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRentingWithDates) #failures->a Set(#t...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))


--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 3 instead of 2.
22 June 2019 3:06:22.747807 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest(TestAsserter)>>assert:description:
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[ self comparingStringBetween: actual and: expected ]
		aString: 	'Got 3 instead of 2.'
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestAsserter)>>assert:equals:
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		actual: 	3
		expected: 	2
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:06:21.318494+02:00
		failures: 	a Set(CarRentalTest>>#testRenting)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:06:21.318494+02:00
		failures: 	a Set(CarRentalTest>>#testRenting)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRentingWithDates) #failures->a Set(#t...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRentalTest(TestAsserter)>>assert:description:
CarRentalTest(TestAsserter)>>assert:equals:
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#isReturnSpecial was sent to nil
22 June 2019 3:09:28.714563 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #isReturnSpecial
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	isReturnSpecial
		exception: 	MessageNotUnderstood: receiver of "isReturnSpecial" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

ClyTextEditor(RubSmalltalkEditor)>>debug:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		method: 	nil
		receiver: 	CarRental
		context: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(463086080)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>debugSelection
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(463086080)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>debugIt
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(463086080)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubEditingArea(Object)>>perform:orSendTo:
	Receiver: a RubEditingArea(463086080)
	Arguments and temporary variables: 
		selector: 	#debugIt
		otherTarget: 	a ClyTextEditor
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1447@449)
		owner: 	a TransformWithLayoutMorph(610501888)
		submorphs: 	an Array(a RubCursor(258889728) a RubPrimarySelectionMorph(915035648...etc...
		fullBounds: 	(0@0) corner: (1447@449)
		color: 	Color transparent
		extension: 	a MorphExtension (435235584) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(31319296)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(258889728)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubEditingArea(463086080)
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(505751296)'Debug it'
	Arguments and temporary variables: 
		evt: 	[(221@854) mouseUp 17623211 nil]
		w: 	a WorldMorph(275485952) [world]
		selArgCount: 	2
	Receiver's instance variables: 
		bounds: 	(140.0@846.0) corner: (339.0@864.0)
		owner: 	a MenuMorph(997294592)
		submorphs: 	#()
		fullBounds: 	(140.0@846.0) corner: (339.0@864.0)
		color: 	Color black
		extension: 	a MorphExtension (678650880)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a RubEditingArea(463086080)
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#debugIt a ClyTextEditor)
		icon: 	Form(16x16x32)
		keyText: 	'D'
		getStateSelector: 	nil
		enablementSelector: 	nil


BlockClosure>>ensure:
	Receiver: [ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := select...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	230
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |
"show cursor in case item opens a new MVC window"
(se...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(505751296)'Debug it'
	Arguments and temporary variables: 
		evt: 	[(221@854) mouseUp 17623211 nil]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(140.0@846.0) corner: (339.0@864.0)
		owner: 	a MenuMorph(997294592)
		submorphs: 	#()
		fullBounds: 	(140.0@846.0) corner: (339.0@864.0)
		color: 	Color black
		extension: 	a MorphExtension (678650880)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a RubEditingArea(463086080)
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#debugIt a ClyTextEditor)
		icon: 	Form(16x16x32)
		keyText: 	'D'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(505751296)'Debug it'
	Arguments and temporary variables: 
		evt: 	[(221@854) mouseUp 17623211 nil]
	Receiver's instance variables: 
		bounds: 	(140.0@846.0) corner: (339.0@864.0)
		owner: 	a MenuMorph(997294592)
		submorphs: 	#()
		fullBounds: 	(140.0@846.0) corner: (339.0@864.0)
		color: 	Color black
		extension: 	a MorphExtension (678650880)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a RubEditingArea(463086080)
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#debugIt a ClyTextEditor)
		icon: 	Form(16x16x32)
		keyText: 	'D'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(505751296)'Debug it'
	Arguments and temporary variables: 
		anEvent: 	[(221@854) mouseUp 17623211 nil]
	Receiver's instance variables: 
		bounds: 	(140.0@846.0) corner: (339.0@864.0)
		owner: 	a MenuMorph(997294592)
		submorphs: 	#()
		fullBounds: 	(140.0@846.0) corner: (339.0@864.0)
		color: 	Color black
		extension: 	a MorphExtension (678650880)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a RubEditingArea(463086080)
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#debugIt a ClyTextEditor)
		icon: 	Form(16x16x32)
		keyText: 	'D'
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(221@854) mouseUp 17623211 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(505751296)'Debug it'
	Receiver's instance variables: 
		timeStamp: 	17623211
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(221@854)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(505751296)'Debug it'
	Arguments and temporary variables: 
		anEvent: 	[(221@854) mouseUp 17623211 nil]
	Receiver's instance variables: 
		bounds: 	(140.0@846.0) corner: (339.0@864.0)
		owner: 	a MenuMorph(997294592)
		submorphs: 	#()
		fullBounds: 	(140.0@846.0) corner: (339.0@864.0)
		color: 	Color black
		extension: 	a MorphExtension (678650880)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a RubEditingArea(463086080)
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#debugIt a ClyTextEditor)
		icon: 	Form(16x16x32)
		keyText: 	'D'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(221@854) mouseUp 17623211 nil]
		aMorph: 	a ToggleMenuItemMorph(505751296)'Debug it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(221@854) mouseUp 17623211 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(221@854) mouseUp 17623211 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	17623211
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(221@854)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(221@854) mouseUp 17623211 nil]
		aMorph: 	a ToggleMenuItemMorph(505751296)'Debug it'
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(221@854) mouseUp 17623211 nil]
		aMorph: 	a ToggleMenuItemMorph(505751296)'Debug it'
	Receiver's instance variables: 
		morph: 	nil


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(505751296)'Debug it'
	Arguments and temporary variables: 
		anEvent: 	[(221@854) mouseUp 17623211 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(140.0@846.0) corner: (339.0@864.0)
		owner: 	a MenuMorph(997294592)
		submorphs: 	#()
		fullBounds: 	(140.0@846.0) corner: (339.0@864.0)
		color: 	Color black
		extension: 	a MorphExtension (678650880)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a RubEditingArea(463086080)
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#debugIt a ClyTextEditor)
		icon: 	Form(16x16x32)
		keyText: 	'D'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(221@854) mouseUp 17623211 nil]
		aMorph: 	a MenuMorph(997294592)
		localEvt: 	[(221@854) mouseUp 17623211 nil]
		index: 	8
		child: 	a ToggleMenuItemMorph(505751296)'Debug it'
		morphs: 	an Array(a ToggleMenuItemMorph(802643456)'Source code' a MenuLineMorph(...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(221@854) mouseUp 17623211 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(221@854) mouseUp 17623211 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	17623211
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(221@854)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(221@854) mouseUp 17623211 nil]
		aMorph: 	a MenuMorph(997294592)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(221@854) mouseUp 17623211 nil]
		aMorph: 	a MenuMorph(997294592)
	Receiver's instance variables: 
		morph: 	nil


MenuMorph(Morph)>>processEvent:using:
	Receiver: a MenuMorph(997294592)
	Arguments and temporary variables: 
		anEvent: 	[(221@854) mouseUp 17623211 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(135.0@726.0) corner: (344.0@1107.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(802643456)'Source code' a MenuLineMor...etc...
		fullBounds: 	(135.0@726.0) corner: (344.0@1107.0)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (387670272) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(505751296)'Debug it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	nil


MenuMorph(Morph)>>processEvent:
	Receiver: a MenuMorph(997294592)
	Arguments and temporary variables: 
		anEvent: 	[(221@854) mouseUp 17623211 nil]
	Receiver's instance variables: 
		bounds: 	(135.0@726.0) corner: (344.0@1107.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(802643456)'Source code' a MenuLineMor...etc...
		fullBounds: 	(135.0@726.0) corner: (344.0@1107.0)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (387670272) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(505751296)'Debug it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	nil


MenuMorph>>handleFocusEvent:
	Receiver: a MenuMorph(997294592)
	Arguments and temporary variables: 
		evt: 	[(221@854) mouseUp 17623211 nil]
	Receiver's instance variables: 
		bounds: 	(135.0@726.0) corner: (344.0@1107.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(802643456)'Source code' a MenuLineMor...etc...
		fullBounds: 	(135.0@726.0) corner: (344.0@1107.0)
		color: 	(Color r: 0.8230000000000001 g: 0.8230000000000001 b: 0.8230000000000001...etc...
		extension: 	a MorphExtension (387670272) [other:  (basicColor -> (Color r: 0.823...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.674 g: 0.674 b: 0.674 alpha: 1.0)
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(505751296)'Debug it'
		stayUp: 	false
		popUpOwner: 	nil
		activeSubMenu: 	nil
		titleMorph: 	nil


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(221@854) mouseUp 17623211 nil]
		focusHolder: 	a MenuMorph(997294592)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(447@924.0) corner: (463@940.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(439@916) mouseOver 17628989 nil]
		targetOffset: 	(17.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 17628989 439 916 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	[(221@854) mouseOver red 17623131 nil]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(221@854) mouseUp 17623211 nil]
		focusHolder: 	a MenuMorph(997294592)
		aBlock: 	[ self mouseFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(447@924.0) corner: (463@940.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(439@916) mouseOver 17628989 nil]
		targetOffset: 	(17.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 17628989 439 916 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(221@854) mouseUp 17623211 nil]
		focusHolder: 	a MenuMorph(997294592)
		aBlock: 	[ self mouseFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(447@924.0) corner: (463@940.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(439@916) mouseOver 17628989 nil]
		targetOffset: 	(17.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 17628989 439 916 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(221@854) mouseUp 17623211 nil]
	Receiver's instance variables: 
		bounds: 	(447@924.0) corner: (463@940.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(439@916) mouseOver 17628989 nil]
		targetOffset: 	(17.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 17628989 439 916 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>handleEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[(221@854) mouseUp 17623211 nil]
		evt: 	[(221@854) mouseUp 17623211 nil]
	Receiver's instance variables: 
		bounds: 	(447@924.0) corner: (463@940.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(439@916) mouseOver 17628989 nil]
		targetOffset: 	(17.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 17628989 439 916 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEventsFromQueue:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEventQueue: 	an InputEventSensor
		evt: 	[(221@854) mouseUp 17623211 nil]
		evtBuf: 	#(1 17623211 221 854 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	(447@924.0) corner: (463@940.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(439@916) mouseOver 17628989 nil]
		targetOffset: 	(17.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 17628989 439 916 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


HandMorph>>processEvents
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(447@924.0) corner: (463@940.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(439@916) mouseOver 17628989 nil]
		targetOffset: 	(17.0@13.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 17628989 439 916 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	0


[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		h: 	a HandMorph(810749440)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(782857216) named: Pl...etc...
		lastStepTime: 	17628993
		lastStepMessage: 	nil
		lastCycleTime: 	17628989
		alarms: 	a Heap()
		lastAlarmTime: 	17628993
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #isReturnSpecial
ClyTextEditor(RubSmalltalkEditor)>>debug:
ClyTextEditor(RubSmalltalkEditor)>>debugSelection
ClyTextEditor(RubSmalltalkEditor)>>debugIt
RubEditingArea(Object)>>perform:orSendTo:
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldState>>doOneSubCycleFor:
WorldMorph>>doOneSubCycle
MenuMorph>>invokeModalAt:in:allowKeyboard:
MenuMorph>>invokeModal:
MenuMorph>>invokeModal
RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
RubEditingArea(RubAbstractTextArea)>>mouseDown:
RubEditingArea(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubEditingArea(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubTextScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubScrolledTextMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ClyMethodCodeEditorToolMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TabManagerMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ClyFullBrowser(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SystemWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 3:09:59.133841 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:09:59.122466+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:09:59.122466+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRentingWithDates) #failures->a Set(#t...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))


--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#availableCars was sent to nil
22 June 2019 3:10:18.699232 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #availableCars
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	availableCars
		exception: 	MessageNotUnderstood: receiver of "availableCars" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

CarRentalTest>>DoItIn:
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		ThisContext: 	CarRentalTest>>testRenting
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoItIn: ThisContext
	^ self
		assert: (ThisContext namedTempAt: 2) availab...etc...
		source: 	a ReadStream
		context: 	CarRentalTest>>testRenting
		receiver: 	CarRentalTest>>#testRenting
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	CarRentalTest>>#testRenting
		ctxt: 	CarRentalTest>>testRenting
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(507431424)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(507431424)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoMethodRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(874172928)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(507431424)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1260@316)
		owner: 	a TransformWithLayoutMorph(745872640)
		submorphs: 	an Array(a RubCursor(409421568) a RubPrimarySelectionMorph(33953792)...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (613643008) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(1022364928)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(409421568)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(211311616))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoMethodRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(874172928)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(733889280) named: Pl...etc...
		lastStepTime: 	17678956
		lastStepMessage: 	nil
		lastCycleTime: 	17679009
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(409421568)))
		lastAlarmTime: 	17678956
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(733889280) named: Pl...etc...
		lastStepTime: 	17678956
		lastStepMessage: 	nil
		lastCycleTime: 	17679009
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(409421568)))
		lastAlarmTime: 	17678956
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(733889280) named: Pl...etc...
		lastStepTime: 	17678956
		lastStepMessage: 	nil
		lastCycleTime: 	17679009
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(409421568)))
		lastAlarmTime: 	17678956
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #availableCars
CarRentalTest>>DoItIn:
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 3:10:38.507886 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>on:do:
	Receiver: [ chain := thisContext sender cut: ctxt.
ctxt jump ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
error
	ifNil:
		[ "this is ugly but it fixes the side-e...etc...
	Receiver's instance variables: 
		outerContext: 	Context class>>contextOn:do:
		startpc: 	68
		numArgs: 	0


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:09:59.122466+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:09:59.122466+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRentingWithDates) #failures->a Set(#t...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRentalTest>>testRenting
BlockClosure>>on:do:
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 3 instead of 2.
22 June 2019 3:10:57.755983 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest(TestAsserter)>>assert:description:
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[ self comparingStringBetween: actual and: expected ]
		aString: 	'Got 3 instead of 2.'
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestAsserter)>>assert:equals:
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		actual: 	3
		expected: 	2
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>on:do:
	Receiver: [ chain := thisContext sender cut: ctxt.
ctxt jump ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
error
	ifNil:
		[ "this is ugly but it fixes the side-e...etc...
	Receiver's instance variables: 
		outerContext: 	Context class>>contextOn:do:
		startpc: 	68
		numArgs: 	0


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:09:59.122466+02:00
		failures: 	a Set(CarRentalTest>>#testRenting)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:09:59.122466+02:00
		failures: 	a Set(CarRentalTest>>#testRenting)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRentingWithDates) #failures->a Set(#t...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}



--- The full stack ---
CarRentalTest(TestAsserter)>>assert:description:
CarRentalTest(TestAsserter)>>assert:equals:
CarRentalTest>>testRenting
BlockClosure>>on:do:
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 3 instead of 1.
22 June 2019 3:12:00.064943 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest(TestAsserter)>>assert:description:
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[ self comparingStringBetween: actual and: expected ]
		aString: 	'Got 3 instead of 1.'
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


CarRentalTest(TestAsserter)>>assert:equals:
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		actual: 	3
		expected: 	1
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


CarRentalTest>>DoItIn:
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		ThisContext: 	CarRentalTest>>testRenting
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoItIn: ThisContext
	^ self assert: (ThisContext namedTempAt: 2) rentedCar...etc...
		source: 	a ReadStream
		context: 	CarRentalTest>>testRenting
		receiver: 	CarRentalTest>>#testRenting
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	CarRentalTest>>#testRenting
		ctxt: 	CarRentalTest>>testRenting
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(482241280)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(482241280)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoMethodRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(1001023744)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(482241280)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1247@316)
		owner: 	a TransformWithLayoutMorph(429401088)
		submorphs: 	an Array(a RubCursor(648315392) a RubPrimarySelectionMorph(439007488...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (549064960) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(328244736)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(648315392)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(401042944))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoMethodRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(1001023744)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(733889280) named: Pl...etc...
		lastStepTime: 	17780300
		lastStepMessage: 	nil
		lastCycleTime: 	17780370
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(648315392)))
		lastAlarmTime: 	17780300
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(733889280) named: Pl...etc...
		lastStepTime: 	17780300
		lastStepMessage: 	nil
		lastCycleTime: 	17780370
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(648315392)))
		lastAlarmTime: 	17780300
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(810749440))
		viewBox: 	(0@0) corner: (1920@1146)
		canvas: 	a FormCanvas on: DisplayScreen(1920x1146x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(733889280) named: Pl...etc...
		lastStepTime: 	17780300
		lastStepMessage: 	nil
		lastCycleTime: 	17780370
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(648315392)))
		lastAlarmTime: 	17780300
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(810749440)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a GLMS...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65550
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(27...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	125
		numArgs: 	0



--- The full stack ---
CarRentalTest(TestAsserter)>>assert:description:
CarRentalTest(TestAsserter)>>assert:equals:
CarRentalTest>>DoItIn:
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of CarRentalTest class did not understand #assert:equals:
22 June 2019 3:13:44.326912 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest class(Object)>>doesNotUnderstand: #assert:equals:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aMessage: 	assert: 3 equals: 2
		exception: 	MessageNotUnderstood: CarRentalTest class>>assert:equals:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRentingWithDates) #failures->a Set(#t...etc...


CarRentalTest class>>DoIt
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRentingWithDates) #failures->a Set(#t...etc...


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| carRental redPanda yellowPanda blackTesla |
	carRental := CarRenta...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	CarRentalTest
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | 
printString := [ result asScriptResultStringInCalypso ]
	o...etc...
		result: 	nil
		rcvr: 	CarRentalTest
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(100398336)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result asScriptResultStringInCalypso ]
	o...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(100398336)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor>>printIt
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		printString: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(100398336)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(100398336)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(100398336)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(100398336)
		secondArg: 	a RubEditingArea(100398336)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(100398336)
		secondArg: 	a RubEditingArea(100398336)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Meta + p do [ :target | target editor printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(100398336)
		category: 	a KMCategory
		morph: 	a RubEditingArea(100398336)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	17
		each: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a CmdKMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(100398336)
		category: 	a KMCategory
		morph: 	a RubEditingArea(100398336)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(100398336)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(383340800)


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#RubTextEditor) aKMCategoryT...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#RubTextEditor) aKMCat...etc...
		firstIndex: 	1
		lastIndex: 	4


CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(100398336)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(383340800)


CmdKMDispatcher>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		executed: 	false
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		context: 	a ClySourceCodeContext
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(100398336)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(383340800)


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(100398336)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(100398336)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(383340800)


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(100398336)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1447@297)
		owner: 	a TransformWithLayoutMorph(549385472)
		submorphs: 	an Array(a RubPrimarySelectionMorph(900750080) a RubCursor(879765504...etc...
		fullBounds: 	(0@0) corner: (1447@297)
		color: 	Color transparent
		extension: 	a MorphExtension (279164416) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(419179008)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(879765504)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(100398336)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1447@297)
		owner: 	a TransformWithLayoutMorph(549385472)
		submorphs: 	an Array(a RubPrimarySelectionMorph(900750080) a RubCursor(879765504...etc...
		fullBounds: 	(0@0) corner: (1447@297)
		color: 	Color transparent
		extension: 	a MorphExtension (279164416) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(419179008)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(879765504)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(100398336)
	Receiver's instance variables: 
		timeStamp: 	17884636
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(-34@30.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	112
		charCode: 	112
		scanCode: 	112


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(100398336)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1447@297)
		owner: 	a TransformWithLayoutMorph(549385472)
		submorphs: 	an Array(a RubPrimarySelectionMorph(900750080) a RubCursor(879765504...etc...
		fullBounds: 	(0@0) corner: (1447@297)
		color: 	Color transparent
		extension: 	a MorphExtension (279164416) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(419179008)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(879765504)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(100398336)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1447@297)
		owner: 	a TransformWithLayoutMorph(549385472)
		submorphs: 	an Array(a RubPrimarySelectionMorph(900750080) a RubCursor(879765504...etc...
		fullBounds: 	(0@0) corner: (1447@297)
		color: 	Color transparent
		extension: 	a MorphExtension (279164416) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(419179008)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(879765504)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(100398336)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(36@543.0) corner: (52@559.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(100398336)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(36@543) mouseOver 17883959 nil]
		targetOffset: 	(458@250)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 17883959 36 543 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(100398336)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(36@543.0) corner: (52@559.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(100398336)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(36@543) mouseOver 17883959 nil]
		targetOffset: 	(458@250)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 17883959 36 543 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(100398336)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(36@543.0) corner: (52@559.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(100398336)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(36@543) mouseOver 17883959 nil]
		targetOffset: 	(458@250)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 17883959 36 543 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendKeyboardEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(36@543.0) corner: (52@559.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(100398336)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(36@543) mouseOver 17883959 nil]
		targetOffset: 	(458@250)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 17883959 36 543 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
CarRentalTest class(Object)>>doesNotUnderstand: #assert:equals:
CarRentalTest class>>DoIt
OpalCompiler>>evaluate
ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
ClyTextEditor>>printIt
[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
OrderedCollection>>do:
CmdKMDispatcher(KMDispatcher)>>dispatch:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 3:15:38.793613 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:15:38.78346+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:15:38.78346+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRentingWithDates) #failures->a Set(#t...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(998430464)
		selectedItems: 	an Array(a ClyDataSourceItem(testRenting))
		metaLevelScope: 	ClyInstanceSideScope


[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)



--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 3:15:49.895855 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:15:38.78346+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:15:38.78346+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRentingWithDates) #failures->a Set(#t...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(998430464)
		selectedItems: 	an Array(a ClyDataSourceItem(testRenting))
		metaLevelScope: 	ClyInstanceSideScope


[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)



--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 3:15:57.317781 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRental>>isAvailable:startingOn:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		date: 	22 June 2019
		numDays: 	1
		RFReifyValueVar: 	nil
		rentalStartingDates: 	nil
		rentalEndingDates: 	nil
		idxPrevRentalDate: 	nil
		idxNextRentalDate: 	nil
		boundsCheck: 	nil
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
		aCar: 	a Car
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Car a Car a Car)
	Arguments and temporary variables: 
		selectBlock: 	[ :aCar | self isAvailable: aCar startingOn: date days: numDays ]
		newCollection: 	an OrderedCollection()
		element: 	a Car
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Car a Car a Car nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRental>>availableCars
	Receiver: a CarRental
	Arguments and temporary variables: 

	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:15:38.78346+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:15:38.78346+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRentingWithDates) #failures->a Set(#t...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRental>>isAvailable:startingOn:days:
[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
OrderedCollection>>select:
CarRental>>availableCars:days:
CarRental>>availableCars
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 3:16:49.530165 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRental>>isAvailable:startingOn:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		date: 	22 June 2019
		numDays: 	1
		RFReifyValueVar: 	nil
		rentalStartingDates: 	nil
		rentalEndingDates: 	nil
		idxPrevRentalDate: 	nil
		idxNextRentalDate: 	nil
		boundsCheck: 	nil
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
		aCar: 	a Car
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Car a Car a Car)
	Arguments and temporary variables: 
		selectBlock: 	[ :aCar | self isAvailable: aCar startingOn: date days: numDays ]
		newCollection: 	an OrderedCollection(a Car)
		element: 	a Car
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Car a Car a Car nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRental>>availableCars
	Receiver: a CarRental
	Arguments and temporary variables: 

	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:15:38.78346+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:15:38.78346+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRentingWithDates) #failures->a Set(#t...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRental>>isAvailable:startingOn:days:
[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
OrderedCollection>>select:
CarRental>>availableCars:days:
CarRental>>availableCars
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 3:17:13.757492 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRental>>isAvailable:startingOn:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		date: 	22 June 2019
		numDays: 	1
		RFReifyValueVar: 	nil
		rentalStartingDates: 	nil
		rentalEndingDates: 	nil
		idxPrevRentalDate: 	nil
		idxNextRentalDate: 	nil
		boundsCheck: 	nil
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
		aCar: 	a Car
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Car a Car a Car)
	Arguments and temporary variables: 
		selectBlock: 	[ :aCar | self isAvailable: aCar startingOn: date days: numDays ]
		newCollection: 	an OrderedCollection(a Car a Car)
		element: 	a Car
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(a Car a Car a Car nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRental>>availableCars
	Receiver: a CarRental
	Arguments and temporary variables: 

	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:15:38.78346+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:15:38.78346+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRentingWithDates) #failures->a Set(#t...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRental>>isAvailable:startingOn:days:
[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
OrderedCollection>>select:
CarRental>>availableCars:days:
CarRental>>availableCars
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 3:17:19.96914 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRental>>isAvailable:startingOn:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		date: 	22 June 2019
		numDays: 	5
		RFReifyValueVar: 	nil
		rentalStartingDates: 	nil
		rentalEndingDates: 	nil
		idxPrevRentalDate: 	nil
		idxNextRentalDate: 	nil
		boundsCheck: 	nil
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRental>>rent:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		numDays: 	5
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:15:38.78346+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:15:38.78346+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRentingWithDates) #failures->a Set(#t...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRental>>isAvailable:startingOn:days:
CarRental>>rent:days:
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 3:17:24.924944 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRental>>isAvailable:startingOn:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		date: 	22 June 2019
		numDays: 	1
		RFReifyValueVar: 	nil
		rentalStartingDates: 	nil
		rentalEndingDates: 	nil
		idxPrevRentalDate: 	nil
		idxNextRentalDate: 	nil
		boundsCheck: 	nil
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
		aCar: 	a Car
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Car a Car a Car)
	Arguments and temporary variables: 
		selectBlock: 	[ :aCar | self isAvailable: aCar startingOn: date days: numDays ]
		newCollection: 	an OrderedCollection()
		element: 	a Car
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Car a Car a Car nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRental>>availableCars
	Receiver: a CarRental
	Arguments and temporary variables: 

	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in Process...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:15:38.78346+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:15:38.78346+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRentingWithDates) #failures->a Set(#t...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRental>>isAvailable:startingOn:days:
[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
OrderedCollection>>select:
CarRental>>availableCars:days:
CarRental>>availableCars
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 3:23:11.228975 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:
	Receiver: 7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:23:11.216924+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testCustom)
		passed: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest...etc...
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | ex sunitAnnounce: aTestCase toResult: self ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCase:
		startpc: 	134
		numArgs: 	0


TestResult>>runCase:
	Receiver: 7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:23:11.216924+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testCustom)
		passed: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest...etc...
		skipped: 	an OrderedCollection()


CarRentalTest(TestCase)>>run:
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		aResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ :each | 
each run: aResult.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
		each: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>>#testCustom CarRe...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each run: aResult.
self announceTest: each.
self changed: ea...etc...
		index: 	8
	Receiver's instance variables: 
		array: 	an Array(CarRentalTest>>#testBooleanCondition CarRentalTest>>#testCustom...etc...
		firstIndex: 	1
		lastIndex: 	10


[ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self change...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>runUnmanaged:
		startpc: 	89
		numArgs: 	0


TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


[ self runUnmanaged: aResult ] in TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ self runUnmanaged: aResult ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ self runUnmanaged: aResult ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestsBy:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestsBy:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


ClyRunTestsFromClassesCommand(ClyRunTestsFromSelectedItemsCommand)>>runTestCase:results:
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		testCase: 	CarRentalTest
		testResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 erro...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


ClyRunTestsFromClassesCommand>>runTestCase:
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		testCase: 	CarRentalTest
		testResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 erro...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


[ :each | self runTestCase: each actualObject ] in ClyRunTestsFromClassesCommand>>execute
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(CarRentalTest)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(CarRentalTest))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestCase: each actualObject ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(CarRentalTest))

ClyRunTestsFromClassesCommand>>execute
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))



--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:
BlockClosure>>on:do:
TestResult>>runCase:
CarRentalTest(TestCase)>>run:
[ :each | 
each run: aResult.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
BlockClosure>>ensure:
TestSuite>>runUnmanaged:
[ self runUnmanaged: aResult ] in TestSuite>>run:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestsBy:
CurrentExecutionEnvironment class>>runTestsBy:
TestSuite>>run:
ClyRunTestsFromClassesCommand(ClyRunTestsFromSelectedItemsCommand)>>runTestCase:results:
ClyRunTestsFromClassesCommand>>runTestCase:
[ :each | self runTestCase: each actualObject ] in ClyRunTestsFromClassesCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromClassesCommand>>execute
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyClassContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 3:23:30.422335 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:
	Receiver: 7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:23:30.4101+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testCustom)
		passed: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest...etc...
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | ex sunitAnnounce: aTestCase toResult: self ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCase:
		startpc: 	134
		numArgs: 	0


TestResult>>runCase:
	Receiver: 7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:23:30.4101+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testCustom)
		passed: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest...etc...
		skipped: 	an OrderedCollection()


CarRentalTest(TestCase)>>run:
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		aResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ :each | 
each run: aResult.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
		each: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>>#testCustom CarRe...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each run: aResult.
self announceTest: each.
self changed: ea...etc...
		index: 	8
	Receiver's instance variables: 
		array: 	an Array(CarRentalTest>>#testBooleanCondition CarRentalTest>>#testCustom...etc...
		firstIndex: 	1
		lastIndex: 	10


[ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self change...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>runUnmanaged:
		startpc: 	89
		numArgs: 	0


TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


[ self runUnmanaged: aResult ] in TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ self runUnmanaged: aResult ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ self runUnmanaged: aResult ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestsBy:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestsBy:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


ClyRunTestsFromClassesCommand(ClyRunTestsFromSelectedItemsCommand)>>runTestCase:results:
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		testCase: 	CarRentalTest
		testResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 erro...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


ClyRunTestsFromClassesCommand>>runTestCase:
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		testCase: 	CarRentalTest
		testResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 erro...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


[ :each | self runTestCase: each actualObject ] in ClyRunTestsFromClassesCommand>>execute
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(CarRentalTest)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(CarRentalTest))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestCase: each actualObject ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(CarRentalTest))

ClyRunTestsFromClassesCommand>>execute
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))



--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:
BlockClosure>>on:do:
TestResult>>runCase:
CarRentalTest(TestCase)>>run:
[ :each | 
each run: aResult.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
BlockClosure>>ensure:
TestSuite>>runUnmanaged:
[ self runUnmanaged: aResult ] in TestSuite>>run:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestsBy:
CurrentExecutionEnvironment class>>runTestsBy:
TestSuite>>run:
ClyRunTestsFromClassesCommand(ClyRunTestsFromSelectedItemsCommand)>>runTestCase:results:
ClyRunTestsFromClassesCommand>>runTestCase:
[ :each | self runTestCase: each actualObject ] in ClyRunTestsFromClassesCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromClassesCommand>>execute
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyClassContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 3:23:33.170841 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:
	Receiver: 7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:23:30.4101+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testCustom)
		passed: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest...etc...
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | ex sunitAnnounce: aTestCase toResult: self ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCase:
		startpc: 	134
		numArgs: 	0


TestResult>>runCase:
	Receiver: 7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:23:30.4101+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testCustom)
		passed: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest...etc...
		skipped: 	an OrderedCollection()


CarRentalTest(TestCase)>>run:
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		aResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ :each | 
each run: aResult.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
		each: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>>#testCustom CarRe...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each run: aResult.
self announceTest: each.
self changed: ea...etc...
		index: 	8
	Receiver's instance variables: 
		array: 	an Array(CarRentalTest>>#testBooleanCondition CarRentalTest>>#testCustom...etc...
		firstIndex: 	1
		lastIndex: 	10


[ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self change...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>runUnmanaged:
		startpc: 	89
		numArgs: 	0


TestSuite>>runUnmanaged:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


[ self runUnmanaged: aResult ] in TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ self runUnmanaged: aResult ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ self runUnmanaged: aResult ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestsBy:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestsBy:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ self runUnmanaged: aResult ]
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestSuite>>run:
	Receiver: a TestSuite
	Arguments and temporary variables: 
		aResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors,...etc...
	Receiver's instance variables: 
		tests: 	an OrderedCollection(CarRentalTest>>#testBooleanCondition CarRentalTest>...etc...
		resources: 	an OrderedCollection()
		name: 	'CarRentalTest'
		announcer: 	an Announcer


ClyRunTestsFromClassesCommand(ClyRunTestsFromSelectedItemsCommand)>>runTestCase:results:
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		testCase: 	CarRentalTest
		testResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 erro...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


ClyRunTestsFromClassesCommand>>runTestCase:
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		testCase: 	CarRentalTest
		testResult: 	7 run, 6 passes, 0 skipped, 0 expected failures, 0 failures, 1 erro...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


[ :each | self runTestCase: each actualObject ] in ClyRunTestsFromClassesCommand>>execute
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(CarRentalTest)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(CarRentalTest))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestCase: each actualObject ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(CarRentalTest))

ClyRunTestsFromClassesCommand>>execute
	Receiver: a ClyRunTestsFromClassesCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(CarRentalTest))



--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCase:
BlockClosure>>on:do:
TestResult>>runCase:
CarRentalTest(TestCase)>>run:
[ :each | 
each run: aResult.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each run: aResult.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>runUnmanaged:
BlockClosure>>ensure:
TestSuite>>runUnmanaged:
[ self runUnmanaged: aResult ] in TestSuite>>run:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestsBy:
CurrentExecutionEnvironment class>>runTestsBy:
TestSuite>>run:
ClyRunTestsFromClassesCommand(ClyRunTestsFromSelectedItemsCommand)>>runTestCase:results:
ClyRunTestsFromClassesCommand>>runTestCase:
[ :each | self runTestCase: each actualObject ] in ClyRunTestsFromClassesCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromClassesCommand>>execute
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyClassContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of False did not understand #+
22 June 2019 3:24:25.474918 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

False(Object)>>doesNotUnderstand: #+
	Receiver: false
	Arguments and temporary variables: 
		aMessage: 	+ 1:00:00:00
		exception: 	MessageNotUnderstood: False>>+
		resumeValue: 	nil
	Receiver's instance variables: 
false

CarRental>>isAvailable:startingOn:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		date: 	22 June 2019
		numDays: 	1
		rentalStartingDates: 	a SortedCollection(22 June 2019)
		rentalEndingDates: 	a SortedCollection(26 June 2019)
		idxPrevRentalDate: 	0
		idxNextRentalDate: 	1
		boundsCheck: 	[ :idx | idx > 0 & (idx <= rentalEndingDates size) ]
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
		aCar: 	a Car
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Car a Car a Car)
	Arguments and temporary variables: 
		selectBlock: 	[ :aCar | self isAvailable: aCar startingOn: date days: numDays ]
		newCollection: 	an OrderedCollection()
		element: 	a Car
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Car a Car a Car nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRental>>availableCars
	Receiver: a CarRental
	Arguments and temporary variables: 

	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:24:25.462777+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:24:25.462777+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}



--- The full stack ---
False(Object)>>doesNotUnderstand: #+
CarRental>>isAvailable:startingOn:days:
[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
OrderedCollection>>select:
CarRental>>availableCars:days:
CarRental>>availableCars
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 3:24:35.510468 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:24:35.500158+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:24:35.500158+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))


--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of False did not understand #+
22 June 2019 3:24:38.655001 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

False(Object)>>doesNotUnderstand: #+
	Receiver: false
	Arguments and temporary variables: 
		aMessage: 	+ 1:00:00:00
		exception: 	MessageNotUnderstood: False>>+
		resumeValue: 	nil
	Receiver's instance variables: 
false

CarRental>>isAvailable:startingOn:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		aCar: 	a Car
		date: 	22 June 2019
		numDays: 	1
		rentalStartingDates: 	a SortedCollection(22 June 2019)
		rentalEndingDates: 	a SortedCollection(26 June 2019)
		idxPrevRentalDate: 	0
		idxNextRentalDate: 	1
		boundsCheck: 	[ :idx | idx > 0 & (idx <= rentalEndingDates size) ]
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
		aCar: 	a Car
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Car a Car a Car)
	Arguments and temporary variables: 
		selectBlock: 	[ :aCar | self isAvailable: aCar startingOn: date days: numDays ]
		newCollection: 	an OrderedCollection()
		element: 	a Car
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a Car a Car a Car nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


CarRental>>availableCars:days:
	Receiver: a CarRental
	Arguments and temporary variables: 
		date: 	22 June 2019
		numDays: 	1
	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRental>>availableCars
	Receiver: a CarRental
	Arguments and temporary variables: 

	Receiver's instance variables: 
		cars: 	an OrderedCollection(a Car a Car a Car)
		numTotalCars: 	0
		dictRentalStartingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sort...etc...
		dictRentalEndingDates: 	a Dictionary(a Car->a SortedCollection() a Car->a Sorted...etc...


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:24:35.500158+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:24:35.500158+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRenting)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0



--- The full stack ---
False(Object)>>doesNotUnderstand: #+
CarRental>>isAvailable:startingOn:days:
[ :aCar | self isAvailable: aCar startingOn: date days: numDays ] in CarRental>>availableCars:days:
OrderedCollection>>select:
CarRental>>availableCars:days:
CarRental>>availableCars
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 3:25:48.764629 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
		blackTesla: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:25:48.755209+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:25:48.755209+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))


--- The full stack ---
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 2 instead of 1.
22 June 2019 3:25:51.366287 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest(TestAsserter)>>assert:description:
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[ self comparingStringBetween: actual and: expected ]
		aString: 	'Got 2 instead of 1.'
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestAsserter)>>assert:equals:
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		actual: 	2
		expected: 	1
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest>>testRenting
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
		blackTesla: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRenting
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:25:48.755209+02:00
		failures: 	a Set(CarRentalTest>>#testRenting)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRenting
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T15:25:48.755209+02:00
		failures: 	a Set(CarRentalTest>>#testRenting)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRenting
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRenting
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRenting
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRenting #testRentingWithDates) #failu...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRentalTest(TestAsserter)>>assert:description:
CarRentalTest(TestAsserter)>>assert:equals:
CarRentalTest>>testRenting
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
UnwindError
22 June 2019 3:32:06.582753 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection>>remove:ifAbsent:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
		absentBlock: 	[ self errorNotFound: oldObject ]
		index: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>remove:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


Breakpoint>>remove
	Receiver: a Breakpoint
	Arguments and temporary variables: 

	Receiver's instance variables: 
		condition: 	nil
		link: 	a MetaLink
		node: 	testRenting
	"The same car cannot be rented twice. Extend the code to mak...etc...
		level: 	nil
		options: 	#(#+ #optionCompileOnLinkInstallation #+ #optionAnnounce)


[ breakpoint remove ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Context>>resume:through:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		value: 	a MorphicUIManager
		firstUnwindContext: 	BlockClosure>>ensure:
		context: 	BlockClosure>>ensure:
		unwindBlock: 	[ breakpoint remove ]
	Receiver's instance variables: 
		sender: 	nil
		pc: 	nil
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ chain := thisContext sender cut: ctxt.
ctxt jump ]


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	true
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))

ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyDebugTestCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyDebugTestCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(998430464)
		selectedItems: 	an Array(a ClyDataSourceItem(testRenting))
		metaLevelScope: 	ClyInstanceSideScope


[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyDebugTestCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyDebugTestCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)


BlockClosure>>on:do:
	Receiver: [ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCom...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	77
		numArgs: 	0


CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyDebugTestCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyDebugTestCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)


[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(963412992)'Debug tests'
	Arguments and temporary variables: 
		evt: 	[(1304@407) mouseUp 17659412 nil]
		w: 	a WorldMorph(275485952) [world]
		selArgCount: 	0
	Receiver's instance variables: 
		bounds: 	(1245.0@393.0) corner: (1408.0@411.0)
		owner: 	a MenuMorph(708188160)
		submorphs: 	#()
		fullBounds: 	(1245.0@393.0) corner: (1408.0@411.0)
		color: 	Color black
		extension: 	a MorphExtension (158110720)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


BlockClosure>>ensure:
	Receiver: [ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := select...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	230
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |
"show cursor in case item opens a new MVC window"
(se...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(963412992)'Debug tests'
	Arguments and temporary variables: 
		evt: 	[(1304@407) mouseUp 17659412 nil]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(1245.0@393.0) corner: (1408.0@411.0)
		owner: 	a MenuMorph(708188160)
		submorphs: 	#()
		fullBounds: 	(1245.0@393.0) corner: (1408.0@411.0)
		color: 	Color black
		extension: 	a MorphExtension (158110720)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(963412992)'Debug tests'
	Arguments and temporary variables: 
		evt: 	[(1304@407) mouseUp 17659412 nil]
	Receiver's instance variables: 
		bounds: 	(1245.0@393.0) corner: (1408.0@411.0)
		owner: 	a MenuMorph(708188160)
		submorphs: 	#()
		fullBounds: 	(1245.0@393.0) corner: (1408.0@411.0)
		color: 	Color black
		extension: 	a MorphExtension (158110720)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(963412992)'Debug tests'
	Arguments and temporary variables: 
		anEvent: 	[(1304@407) mouseUp 17659412 nil]
	Receiver's instance variables: 
		bounds: 	(1245.0@393.0) corner: (1408.0@411.0)
		owner: 	a MenuMorph(708188160)
		submorphs: 	#()
		fullBounds: 	(1245.0@393.0) corner: (1408.0@411.0)
		color: 	Color black
		extension: 	a MorphExtension (158110720)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1304@407) mouseUp 17659412 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(963412992)'Debug tests'
	Receiver's instance variables: 
		timeStamp: 	17659412
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1304@407)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(963412992)'Debug tests'
	Arguments and temporary variables: 
		anEvent: 	[(1304@407) mouseUp 17659412 nil]
	Receiver's instance variables: 
		bounds: 	(1245.0@393.0) corner: (1408.0@411.0)
		owner: 	a MenuMorph(708188160)
		submorphs: 	#()
		fullBounds: 	(1245.0@393.0) corner: (1408.0@411.0)
		color: 	Color black
		extension: 	a MorphExtension (158110720)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1304@407) mouseUp 17659412 nil]
		aMorph: 	a ToggleMenuItemMorph(963412992)'Debug tests'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1304@407) mouseUp 17659412 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1304@407) mouseUp 17659412 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	17659412
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1304@407)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1304@407) mouseUp 17659412 nil]
		aMorph: 	a ToggleMenuItemMorph(963412992)'Debug tests'
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1304@407) mouseUp 17659412 nil]
		aMorph: 	a ToggleMenuItemMorph(963412992)'Debug tests'
	Receiver's instance variables: 
		morph: 	nil


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(963412992)'Debug tests'
	Arguments and temporary variables: 
		anEvent: 	[(1304@407) mouseUp 17659412 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(1245.0@393.0) corner: (1408.0@411.0)
		owner: 	a MenuMorph(708188160)
		submorphs: 	#()
		fullBounds: 	(1245.0@393.0) corner: (1408.0@411.0)
		color: 	Color black
		extension: 	a MorphExtension (158110720)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1304@407) mouseUp 17659412 nil]
		aMorph: 	a MenuMorph(708188160)
		localEvt: 	[(1304@407) mouseUp 17659412 nil]
		index: 	15
		child: 	a ToggleMenuItemMorph(963412992)'Debug tests'
		morphs: 	an Array(a ToggleMenuItemMorph(933094144)'Browse' a ToggleMenuItemMorph...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1304@407) mouseUp 17659412 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1304@407) mouseUp 17659412 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	17659412
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1304@407)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1304@407) mouseUp 17659412 nil]
		aMorph: 	a MenuMorph(708188160)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove:
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
Breakpoint>>remove
[ breakpoint remove ] in ClyDebugTestCommand>>runTest:of:
Context>>resume:through:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: This block accepts 0 arguments, but was called with 1 argument.
22 June 2019 3:45:23.13379 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

BlockClosure(Object)>>error:
	Receiver: [ carRental addCar: Car panda ]
	Arguments and temporary variables: 
		aString: 	'This block accepts 0 arguments, but was called with 1 argument.'
	Receiver's instance variables: 
		outerContext: 	CarRentalTest class>>DoIt
		startpc: 	107
		numArgs: 	0


BlockClosure>>numArgsError:
	Receiver: [ carRental addCar: Car panda ]
	Arguments and temporary variables: 
		numArgsForInvocation: 	1
		printNArgs: 	[ :n | 
n printString , ' argument'
	,
		(n = 1
			ifTrue: [ '' ]
	...etc...
	Receiver's instance variables: 
		outerContext: 	CarRentalTest class>>DoIt
		startpc: 	107
		numArgs: 	0


BlockClosure>>value:
	Receiver: [ carRental addCar: Car panda ]
	Arguments and temporary variables: 
		anArg: 	1
	Receiver's instance variables: 
		outerContext: 	CarRentalTest class>>DoIt
		startpc: 	107
		numArgs: 	0


SmallInteger(Number)>>to:do:
	Receiver: 1
	Arguments and temporary variables: 
		stop: 	3
		aBlock: 	[ carRental addCar: Car panda ]
		nextValue: 	1
	Receiver's instance variables: 
1

CarRentalTest class>>DoIt
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		carRental: 	a CarRental
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set(#testRentingWithDates) #failures->a Set() ...etc...


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| carRental |
	carRental := CarRental new.
	1 to: 3 do: [ carRental ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	CarRentalTest
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | 
printString := [ result asScriptResultStringInCalypso ]
	o...etc...
		result: 	nil
		rcvr: 	CarRentalTest
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(3677952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result asScriptResultStringInCalypso ]
	o...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(3677952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor>>printIt
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		printString: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(3677952)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(3677952)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(3677952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(3677952)
		secondArg: 	a RubEditingArea(3677952)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(3677952)
		secondArg: 	a RubEditingArea(3677952)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Meta + p do [ :target | target editor printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(3677952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(3677952)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	17
		each: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a CmdKMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(3677952)
		category: 	a KMCategory
		morph: 	a RubEditingArea(3677952)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a RubEditingArea(3677952)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(343649024)


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigation) a...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	4
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#MorphFocusCtrlNavigat...etc...
		firstIndex: 	1
		lastIndex: 	4


CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a RubEditingArea(3677952)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(343649024)


CmdKMDispatcher>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		executed: 	false
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		context: 	a ClySourceCodeContext
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a RubEditingArea(3677952)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(343649024)


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(3677952)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#MorphFocusCtrlNavigation) aKMCategoryTarget(#...etc...
		morph: 	a RubEditingArea(3677952)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(343649024)


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(3677952)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1447@335)
		owner: 	a TransformWithLayoutMorph(615013120)
		submorphs: 	an Array(a RubCursor(229889280) a RubPrimarySelectionMorph(312673792...etc...
		fullBounds: 	(0@0) corner: (1447@335)
		color: 	Color transparent
		extension: 	a MorphExtension (853248256) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(690205696)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(229889280)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(3677952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1447@335)
		owner: 	a TransformWithLayoutMorph(615013120)
		submorphs: 	an Array(a RubCursor(229889280) a RubPrimarySelectionMorph(312673792...etc...
		fullBounds: 	(0@0) corner: (1447@335)
		color: 	Color transparent
		extension: 	a MorphExtension (853248256) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(690205696)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(229889280)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(3677952)
	Receiver's instance variables: 
		timeStamp: 	19783442
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(219@268.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	112
		charCode: 	112
		scanCode: 	112


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(3677952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1447@335)
		owner: 	a TransformWithLayoutMorph(615013120)
		submorphs: 	an Array(a RubCursor(229889280) a RubPrimarySelectionMorph(312673792...etc...
		fullBounds: 	(0@0) corner: (1447@335)
		color: 	Color transparent
		extension: 	a MorphExtension (853248256) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(690205696)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(229889280)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(3677952)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1447@335)
		owner: 	a TransformWithLayoutMorph(615013120)
		submorphs: 	an Array(a RubCursor(229889280) a RubPrimarySelectionMorph(312673792...etc...
		fullBounds: 	(0@0) corner: (1447@335)
		color: 	Color transparent
		extension: 	a MorphExtension (853248256) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(690205696)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(229889280)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(3677952)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(281@772.0) corner: (297@788.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(281@772.0) corner: (297@788.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(3677952)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(289@781) mouseOver CTRL 19782584 nil]
		targetOffset: 	(218@282)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 19782584 281 778 0 2 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil



--- The full stack ---
BlockClosure(Object)>>error:
BlockClosure>>numArgsError:
BlockClosure>>value:
SmallInteger(Number)>>to:do:
CarRentalTest class>>DoIt
OpalCompiler>>evaluate
ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
ClyTextEditor>>printIt
[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
OrderedCollection>>do:
CmdKMDispatcher(KMDispatcher)>>dispatch:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
UnwindError
22 June 2019 3:56:28.596773 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection>>remove:ifAbsent:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
		absentBlock: 	[ self errorNotFound: oldObject ]
		index: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>remove:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


Breakpoint>>remove
	Receiver: a Breakpoint
	Arguments and temporary variables: 

	Receiver's instance variables: 
		condition: 	nil
		link: 	a MetaLink
		node: 	testRenting
	"The same car cannot be rented twice. Extend the code to mak...etc...
		level: 	nil
		options: 	#(#+ #optionCompileOnLinkInstallation #+ #optionAnnounce)


[ breakpoint remove ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Context>>resume:through:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		value: 	a MorphicUIManager
		firstUnwindContext: 	BlockClosure>>ensure:
		context: 	BlockClosure>>ensure:
		unwindBlock: 	[ breakpoint remove ]
	Receiver's instance variables: 
		sender: 	nil
		pc: 	nil
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ chain := thisContext sender cut: ctxt.
ctxt jump ]


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	true
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRenting
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRenting)
		testSelector: 	#testRenting
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRenting)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRenting))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRenting))

ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRenting))
		runTestCases: 	{CarRentalTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyDebugTestCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyDebugTestCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(998430464)
		selectedItems: 	an Array(a ClyDataSourceItem(testRenting))
		metaLevelScope: 	ClyInstanceSideScope


[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyDebugTestCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyDebugTestCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)


BlockClosure>>on:do:
	Receiver: [ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCom...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	77
		numArgs: 	0


CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyDebugTestCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyDebugTestCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)


[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(348775424)'Debug tests'
	Arguments and temporary variables: 
		evt: 	[(863@585) mouseUp 17441543 nil]
		w: 	a WorldMorph(275485952) [world]
		selArgCount: 	0
	Receiver's instance variables: 
		bounds: 	(811.0@572.0) corner: (987.0@590.0)
		owner: 	a MenuMorph(449099264)
		submorphs: 	#()
		fullBounds: 	(811.0@572.0) corner: (987.0@590.0)
		color: 	Color black
		extension: 	a MorphExtension (1007352064)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


BlockClosure>>ensure:
	Receiver: [ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := select...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	230
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |
"show cursor in case item opens a new MVC window"
(se...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(348775424)'Debug tests'
	Arguments and temporary variables: 
		evt: 	[(863@585) mouseUp 17441543 nil]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(811.0@572.0) corner: (987.0@590.0)
		owner: 	a MenuMorph(449099264)
		submorphs: 	#()
		fullBounds: 	(811.0@572.0) corner: (987.0@590.0)
		color: 	Color black
		extension: 	a MorphExtension (1007352064)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(348775424)'Debug tests'
	Arguments and temporary variables: 
		evt: 	[(863@585) mouseUp 17441543 nil]
	Receiver's instance variables: 
		bounds: 	(811.0@572.0) corner: (987.0@590.0)
		owner: 	a MenuMorph(449099264)
		submorphs: 	#()
		fullBounds: 	(811.0@572.0) corner: (987.0@590.0)
		color: 	Color black
		extension: 	a MorphExtension (1007352064)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(348775424)'Debug tests'
	Arguments and temporary variables: 
		anEvent: 	[(863@585) mouseUp 17441543 nil]
	Receiver's instance variables: 
		bounds: 	(811.0@572.0) corner: (987.0@590.0)
		owner: 	a MenuMorph(449099264)
		submorphs: 	#()
		fullBounds: 	(811.0@572.0) corner: (987.0@590.0)
		color: 	Color black
		extension: 	a MorphExtension (1007352064)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(863@585) mouseUp 17441543 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(348775424)'Debug tests'
	Receiver's instance variables: 
		timeStamp: 	17441543
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(863@585)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(348775424)'Debug tests'
	Arguments and temporary variables: 
		anEvent: 	[(863@585) mouseUp 17441543 nil]
	Receiver's instance variables: 
		bounds: 	(811.0@572.0) corner: (987.0@590.0)
		owner: 	a MenuMorph(449099264)
		submorphs: 	#()
		fullBounds: 	(811.0@572.0) corner: (987.0@590.0)
		color: 	Color black
		extension: 	a MorphExtension (1007352064)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(863@585) mouseUp 17441543 nil]
		aMorph: 	a ToggleMenuItemMorph(348775424)'Debug tests'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(863@585) mouseUp 17441543 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(863@585) mouseUp 17441543 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	17441543
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(863@585)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(863@585) mouseUp 17441543 nil]
		aMorph: 	a ToggleMenuItemMorph(348775424)'Debug tests'
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(863@585) mouseUp 17441543 nil]
		aMorph: 	a ToggleMenuItemMorph(348775424)'Debug tests'
	Receiver's instance variables: 
		morph: 	nil


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(348775424)'Debug tests'
	Arguments and temporary variables: 
		anEvent: 	[(863@585) mouseUp 17441543 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(811.0@572.0) corner: (987.0@590.0)
		owner: 	a MenuMorph(449099264)
		submorphs: 	#()
		fullBounds: 	(811.0@572.0) corner: (987.0@590.0)
		color: 	Color black
		extension: 	a MorphExtension (1007352064)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(863@585) mouseUp 17441543 nil]
		aMorph: 	a MenuMorph(449099264)
		localEvt: 	[(863@585) mouseUp 17441543 nil]
		index: 	17
		child: 	a ToggleMenuItemMorph(348775424)'Debug tests'
		morphs: 	an Array(a ToggleMenuItemMorph(723543040)'Browse' a ToggleMenuItemMorph...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(863@585) mouseUp 17441543 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(863@585) mouseUp 17441543 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	17441543
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(863@585)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(863@585) mouseUp 17441543 nil]
		aMorph: 	a MenuMorph(449099264)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove:
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
Breakpoint>>remove
[ breakpoint remove ] in ClyDebugTestCommand>>runTest:of:
Context>>resume:through:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of CarRentalTest class did not understand #assert:equals:
22 June 2019 4:00:07.722262 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest class(Object)>>doesNotUnderstand: #assert:equals:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aMessage: 	assert: 6 equals: 6
		exception: 	MessageNotUnderstood: CarRentalTest class>>assert:equals:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRenting) #passed->...etc...


CarRentalTest class>>DoIt
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		carRental: 	a CarRental
		date: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRenting) #passed->...etc...


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| carRental date |
	carRental := CarRental new.
	1 to: 3 do: [ :i | ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	CarRentalTest
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | 
printString := [ result asScriptResultStringInCalypso ]
	o...etc...
		result: 	nil
		rcvr: 	CarRentalTest
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(114240512)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result asScriptResultStringInCalypso ]
	o...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(114240512)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor>>printIt
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		printString: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(114240512)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(114240512)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(114240512)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(114240512)
		secondArg: 	a RubEditingArea(114240512)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(114240512)
		secondArg: 	a RubEditingArea(114240512)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Meta + p do [ :target | target editor printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(114240512)
		category: 	a KMCategory
		morph: 	a RubEditingArea(114240512)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	17
		each: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a CmdKMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(114240512)
		category: 	a KMCategory
		morph: 	a RubEditingArea(114240512)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(114240512)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(837763328)


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#RubTextEditor) aKMCategoryT...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#RubTextEditor) aKMCat...etc...
		firstIndex: 	1
		lastIndex: 	4


CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(114240512)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(837763328)


CmdKMDispatcher>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		executed: 	false
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		context: 	a ClySourceCodeContext
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(114240512)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(837763328)


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(114240512)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(114240512)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(837763328)


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(114240512)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (838@430)
		owner: 	a TransformWithLayoutMorph(192861696)
		submorphs: 	an Array(a RubCursor(158674944) a RubPrimarySelectionMorph(751792640...etc...
		fullBounds: 	(0@0) corner: (838@430)
		color: 	Color transparent
		extension: 	a MorphExtension (605310208) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(877195520)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(158674944)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(114240512)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (838@430)
		owner: 	a TransformWithLayoutMorph(192861696)
		submorphs: 	an Array(a RubCursor(158674944) a RubPrimarySelectionMorph(751792640...etc...
		fullBounds: 	(0@0) corner: (838@430)
		color: 	Color transparent
		extension: 	a MorphExtension (605310208) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(877195520)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(158674944)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(114240512)
	Receiver's instance variables: 
		timeStamp: 	20667976
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(-9@210.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	112
		charCode: 	112
		scanCode: 	112


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(114240512)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (838@430)
		owner: 	a TransformWithLayoutMorph(192861696)
		submorphs: 	an Array(a RubCursor(158674944) a RubPrimarySelectionMorph(751792640...etc...
		fullBounds: 	(0@0) corner: (838@430)
		color: 	Color transparent
		extension: 	a MorphExtension (605310208) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(877195520)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(158674944)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(114240512)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (838@430)
		owner: 	a TransformWithLayoutMorph(192861696)
		submorphs: 	an Array(a RubCursor(158674944) a RubPrimarySelectionMorph(751792640...etc...
		fullBounds: 	(0@0) corner: (838@430)
		color: 	Color transparent
		extension: 	a MorphExtension (605310208) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(877195520)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(158674944)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(114240512)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(61@647.0) corner: (77@663.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(61@647.0) corner: (77@663.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(114240512)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(61@647) mouseOver 20667387 nil]
		targetOffset: 	(363@357)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 20667387 61 650 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(114240512)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(61@647.0) corner: (77@663.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(61@647.0) corner: (77@663.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(114240512)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(61@647) mouseOver 20667387 nil]
		targetOffset: 	(363@357)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 20667387 61 650 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(114240512)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(61@647.0) corner: (77@663.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(61@647.0) corner: (77@663.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(114240512)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(61@647) mouseOver 20667387 nil]
		targetOffset: 	(363@357)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 20667387 61 650 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendKeyboardEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(61@647.0) corner: (77@663.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(61@647.0) corner: (77@663.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(114240512)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(61@647) mouseOver 20667387 nil]
		targetOffset: 	(363@357)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 20667387 61 650 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
CarRentalTest class(Object)>>doesNotUnderstand: #assert:equals:
CarRentalTest class>>DoIt
OpalCompiler>>evaluate
ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
ClyTextEditor>>printIt
[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
OrderedCollection>>do:
CmdKMDispatcher(KMDispatcher)>>dispatch:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of CarRentalTest class did not understand #assert:equals:
22 June 2019 4:00:12.477487 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest class(Object)>>doesNotUnderstand: #assert:equals:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aMessage: 	assert: 6 equals: 6
		exception: 	MessageNotUnderstood: CarRentalTest class>>assert:equals:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRenting) #passed->...etc...


CarRentalTest class>>DoIt
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		carRental: 	a CarRental
		date: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRenting) #passed->...etc...


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| carRental date |
	carRental := CarRental new.
	1 to: 3 do: [ :i | ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	CarRentalTest
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | 
printString := [ result asScriptResultStringInCalypso ]
	o...etc...
		result: 	nil
		rcvr: 	CarRentalTest
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(114240512)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result asScriptResultStringInCalypso ]
	o...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(114240512)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor>>printIt
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		printString: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(114240512)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(114240512)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(114240512)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(114240512)
		secondArg: 	a RubEditingArea(114240512)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(114240512)
		secondArg: 	a RubEditingArea(114240512)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Meta + p do [ :target | target editor printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(114240512)
		category: 	a KMCategory
		morph: 	a RubEditingArea(114240512)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	17
		each: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a CmdKMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(114240512)
		category: 	a KMCategory
		morph: 	a RubEditingArea(114240512)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(114240512)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(837763328)


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#RubTextEditor) aKMCategoryT...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#RubTextEditor) aKMCat...etc...
		firstIndex: 	1
		lastIndex: 	4


CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(114240512)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(837763328)


CmdKMDispatcher>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		executed: 	false
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		context: 	a ClySourceCodeContext
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(114240512)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(837763328)


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(114240512)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(114240512)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(837763328)


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(114240512)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (838@430)
		owner: 	a TransformWithLayoutMorph(192861696)
		submorphs: 	an Array(a RubCursor(158674944) a RubPrimarySelectionMorph(751792640...etc...
		fullBounds: 	(0@0) corner: (838@430)
		color: 	Color transparent
		extension: 	a MorphExtension (605310208) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(877195520)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(158674944)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(114240512)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (838@430)
		owner: 	a TransformWithLayoutMorph(192861696)
		submorphs: 	an Array(a RubCursor(158674944) a RubPrimarySelectionMorph(751792640...etc...
		fullBounds: 	(0@0) corner: (838@430)
		color: 	Color transparent
		extension: 	a MorphExtension (605310208) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(877195520)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(158674944)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(114240512)
	Receiver's instance variables: 
		timeStamp: 	20672782
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(-70@226.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	112
		charCode: 	112
		scanCode: 	112


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(114240512)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (838@430)
		owner: 	a TransformWithLayoutMorph(192861696)
		submorphs: 	an Array(a RubCursor(158674944) a RubPrimarySelectionMorph(751792640...etc...
		fullBounds: 	(0@0) corner: (838@430)
		color: 	Color transparent
		extension: 	a MorphExtension (605310208) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(877195520)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(158674944)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(114240512)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (838@430)
		owner: 	a TransformWithLayoutMorph(192861696)
		submorphs: 	an Array(a RubCursor(158674944) a RubPrimarySelectionMorph(751792640...etc...
		fullBounds: 	(0@0) corner: (838@430)
		color: 	Color transparent
		extension: 	a MorphExtension (605310208) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(877195520)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(158674944)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(114240512)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0@663.0) corner: (16@679.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(114240512)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(0@663) mouseOver 20672123 nil]
		targetOffset: 	(498@323)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 20672123 0 663 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(114240512)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(0@663.0) corner: (16@679.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(114240512)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(0@663) mouseOver 20672123 nil]
		targetOffset: 	(498@323)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 20672123 0 663 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(114240512)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0@663.0) corner: (16@679.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(114240512)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(0@663) mouseOver 20672123 nil]
		targetOffset: 	(498@323)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 20672123 0 663 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendKeyboardEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@663.0) corner: (16@679.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(114240512)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(0@663) mouseOver 20672123 nil]
		targetOffset: 	(498@323)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 20672123 0 663 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
CarRentalTest class(Object)>>doesNotUnderstand: #assert:equals:
CarRentalTest class>>DoIt
OpalCompiler>>evaluate
ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
ClyTextEditor>>printIt
[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
OrderedCollection>>do:
CmdKMDispatcher(KMDispatcher)>>dispatch:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of CarRentalTest class did not understand #assert:equals:
22 June 2019 4:00:45.634581 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest class(Object)>>doesNotUnderstand: #assert:equals:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aMessage: 	assert: 6 equals: 6
		exception: 	MessageNotUnderstood: CarRentalTest class>>assert:equals:
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRenting) #passed->...etc...


CarRentalTest class>>DoIt
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		carRental: 	a CarRental
		date: 	nil
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRenting) #passed->...etc...


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	| carRental date |
	carRental := CarRental new.
	1 to: 3 do: [ :i | ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	CarRentalTest
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aStream: 	a ReadWriteStream
		aBlock: 	[ :result | 
printString := [ result asScriptResultStringInCalypso ]
	o...etc...
		result: 	nil
		rcvr: 	CarRentalTest
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(114240512)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
printString := [ result asScriptResultStringInCalypso ]
	o...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(114240512)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


ClyTextEditor>>printIt
	Receiver: a ClyTextEditor
	Arguments and temporary variables: 
		printString: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(114240512)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
	Receiver: RubSmalltalkEditor
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistration
		target: 	a RubEditingArea(114240512)
	Receiver's instance variables: 
		superclass: 	RubTextEditor
		methodDict: 	a MethodDictionary(#atCompletionPosition->RubSmalltalkEditor>>#atCo...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{ClyTextEditor}
		name: 	#RubSmalltalkEditor
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Rubric-Editing-Code'


BlockClosure>>cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(114240512)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(114240512)
		secondArg: 	a RubEditingArea(114240512)
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


BlockClosure>>cull:cull:cull:
	Receiver: [ :target | target editor printIt ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(114240512)
		secondArg: 	a RubEditingArea(114240512)
		thirdArg: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	RubSmalltalkEditor class>>buildShortcutsOn:
		startpc: 	665
		numArgs: 	1


KMCategoryBinding>>completeMatch:buffer:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		aKeymap: 	#printIt on Meta + p do [ :target | target editor printIt ]

		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(114240512)
		category: 	a KMCategory
		morph: 	a RubEditingArea(114240512)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		l: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


Array(SequenceableCollection)>>do:
	Receiver: an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		aListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
		aBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		listeners: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatcher)
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: #printIt on Meta + p do [ :target | target editor printIt ]

	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		action: 	[ :target | target editor printIt ]
		name: 	#printIt
		shortcut: 	Meta + p
		defaultShortcut: 	Meta + p
		description: 	'Print it'


[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
		entry: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


Set>>do:
	Receiver: a Set(#methodStringsContainingIt on Meta + Shift + e do [ :target | target editor methodSt...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andD...etc...
		index: 	17
		each: 	#printIt on Meta + p do [ :target | target editor printIt ]

	Receiver's instance variables: 
		tally: 	15
		array: 	an Array(#methodStringsContainingIt on Meta + Shift + e do [ :target | t...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aMatchListener: 	an Array(aKMCategoryTarget(#RubSmalltalkEditor) a CmdKMDispatch...etc...
		aBlock: 	[ ^ self ]
	Receiver's instance variables: 
		name: 	#RubSmalltalkEditor
		platforms: 	a Dictionary(#Unix->a KMStorage #Windows->a KMStorage #all->a KMStor...etc...


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: aKMCategoryTarget(#RubSmalltalkEditor)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aListener: 	a CmdKMDispatcher
		anAction: 	[ ^ self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(114240512)
		category: 	a KMCategory
		morph: 	a RubEditingArea(114240512)


[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		aTarget: 	aKMCategoryTarget(#RubSmalltalkEditor)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(114240512)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(837763328)


OrderedCollection>>do:
	Receiver: an OrderedCollection(aKMCategoryTarget(nil) aKMCategoryTarget(#RubTextEditor) aKMCategoryT...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verify...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(aKMCategoryTarget(nil) aKMCategoryTarget(#RubTextEditor) aKMCat...etc...
		firstIndex: 	1
		lastIndex: 	4


CmdKMDispatcher(KMDispatcher)>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(114240512)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(837763328)


CmdKMDispatcher>>dispatch:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		executed: 	false
		anEventBuffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
		context: 	a ClySourceCodeContext
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(114240512)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(837763328)


KMTarget>>dispatch:
	Receiver: a KMTarget
	Arguments and temporary variables: 
		buffer: 	an OrderedCollection([keystroke '<Ctrl-p>'])
	Receiver's instance variables: 
		realTarget: 	nil
		morph: 	a RubEditingArea(114240512)
		targetSelector: 	#yourself
		directKeymaps: 	nil
		perInstanceCategories: 	nil


[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
		targetToDispatch: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>do:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aBlock: 	[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstan...etc...
		currentTarget: 	a KMTarget
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


KMDispatchChain>>dispatch:
	Receiver: a KMDispatchChain
	Arguments and temporary variables: 
		aKeyboardEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		target: 	a KMTarget
		dispatcher: 	a CmdKMDispatcher
		initialTarget: 	a KmGlobalDispatcher


CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
	Receiver: a CmdKMDispatcher
	Arguments and temporary variables: 
		aKeyEvent: 	[keystroke '<Ctrl-p>']
		chain: 	a KMDispatchChain
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(aKMCategoryTarget(#RubTextEditor) aKMCategoryTarget(#RubSmalltal...etc...
		morph: 	a RubEditingArea(114240512)
		directKeymaps: 	a KMCategory
		commandProvider: 	a ClyMethodCodeEditorToolMorph(837763328)


RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
	Receiver: a RubEditingArea(114240512)
	Arguments and temporary variables: 
		evt: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (838@430)
		owner: 	a TransformWithLayoutMorph(192861696)
		submorphs: 	an Array(a RubCursor(158674944) a RubPrimarySelectionMorph(751792640...etc...
		fullBounds: 	(0@0) corner: (838@430)
		color: 	Color transparent
		extension: 	a MorphExtension (605310208) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(877195520)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(158674944)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
	Receiver: a RubEditingArea(114240512)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (838@430)
		owner: 	a TransformWithLayoutMorph(192861696)
		submorphs: 	an Array(a RubCursor(158674944) a RubPrimarySelectionMorph(751792640...etc...
		fullBounds: 	(0@0) corner: (838@430)
		color: 	Color transparent
		extension: 	a MorphExtension (605310208) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(877195520)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(158674944)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


KeyboardEvent>>sentTo:
	Receiver: [keystroke '<Ctrl-p>']
	Arguments and temporary variables: 
		anObject: 	a RubEditingArea(114240512)
	Receiver's instance variables: 
		timeStamp: 	20705891
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#keystroke
		buttons: 	16
		position: 	(74@248.0)
		handler: 	nil
		wasHandled: 	true
		keyValue: 	112
		charCode: 	112
		scanCode: 	112


RubEditingArea(Morph)>>handleEvent:
	Receiver: a RubEditingArea(114240512)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (838@430)
		owner: 	a TransformWithLayoutMorph(192861696)
		submorphs: 	an Array(a RubCursor(158674944) a RubPrimarySelectionMorph(751792640...etc...
		fullBounds: 	(0@0) corner: (838@430)
		color: 	Color transparent
		extension: 	a MorphExtension (605310208) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(877195520)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(158674944)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


RubEditingArea(Morph)>>handleFocusEvent:
	Receiver: a RubEditingArea(114240512)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (838@430)
		owner: 	a TransformWithLayoutMorph(192861696)
		submorphs: 	an Array(a RubCursor(158674944) a RubPrimarySelectionMorph(751792640...etc...
		fullBounds: 	(0@0) corner: (838@430)
		color: 	Color transparent
		extension: 	a MorphExtension (605310208) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a ClyTextEditor
		scrollPane: 	a RubTextScrollPane(877195520)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a ClyTextEditingMode
		cursor: 	a RubCursor(158674944)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	ClyTextEditor


[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(114240512)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(136@676.0) corner: (152@692.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(136@676.0) corner: (152@692.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(114240512)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(144@685) mouseOver 20705164 nil]
		targetOffset: 	(460@317)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 20705164 142 684 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


BlockClosure>>on:do:
	Receiver: [ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (an...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
ActiveWorld := priorWorld.
ActiveEvent := priorEvent.
A...etc...
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	111
		numArgs: 	0


WorldMorph(PasteUpMorph)>>becomeActiveDuring:
	Receiver: a WorldMorph(275485952) [world]
	Arguments and temporary variables: 
		aBlock: 	[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	ha...etc...
		priorWorld: 	a WorldMorph(275485952) [world]
		priorHand: 	a HandMorph(810749440)
		priorEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1146)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(276096512) a TaskbarMorph(1042343680) a Syst...etc...
		fullBounds: 	(0@0) corner: (1920@1146)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (757545216) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		osWindowMutex: 	nil
		session: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(114240512)
		aBlock: 	[ self keyboardFocus: nil ]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(136@676.0) corner: (152@692.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(136@676.0) corner: (152@692.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(114240512)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(144@685) mouseOver 20705164 nil]
		targetOffset: 	(460@317)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 20705164 142 684 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
		focusHolder: 	a RubEditingArea(114240512)
		aBlock: 	[ self keyboardFocus: nil ]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(136@676.0) corner: (152@692.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(136@676.0) corner: (152@692.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(114240512)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(144@685) mouseOver 20705164 nil]
		targetOffset: 	(460@317)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 20705164 142 684 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2


HandMorph>>sendKeyboardEvent:
	Receiver: a HandMorph(810749440)
	Arguments and temporary variables: 
		anEvent: 	[keystroke '<Ctrl-p>']
	Receiver's instance variables: 
		bounds: 	(136@676.0) corner: (152@692.0)
		owner: 	a WorldMorph(275485952) [world]
		submorphs: 	#()
		fullBounds: 	(136@676.0) corner: (152@692.0)
		color: 	Color blue
		extension: 	a MorphExtension (280451072)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(114240512)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(144@685) mouseOver 20705164 nil]
		targetOffset: 	(460@317)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	Form(16x16x8)
		temporaryCursorOffset: 	(-8@ -9)
		hardwareCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r...etc...
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 20705164 142 684 0 0 0 1)
		lastKeyScanCode: 	112
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	2



--- The full stack ---
CarRentalTest class(Object)>>doesNotUnderstand: #assert:equals:
CarRentalTest class>>DoIt
OpalCompiler>>evaluate
ClyTextEditor(RubSmalltalkEditor)>>evaluate:andDo:
ClyTextEditor(RubSmalltalkEditor)>>evaluateSelectionAndDo:
ClyTextEditor>>printIt
[ :target | target editor printIt ] in RubSmalltalkEditor class>>buildShortcutsOn:
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in CmdKMDispatcher(KMDispatcher)>>dispatch:
OrderedCollection>>do:
CmdKMDispatcher(KMDispatcher)>>dispatch:
CmdKMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
CmdKMDispatcher(KMDispatcher)>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of False did not understand #year:month:day:
22 June 2019 4:01:36.781514 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

False(Object)>>doesNotUnderstand: #year:month:day:
	Receiver: false
	Arguments and temporary variables: 
		aMessage: 	year: 2019 month: 4 day: 1
		exception: 	MessageNotUnderstood: False>>year:month:day:
		resumeValue: 	nil
	Receiver's instance variables: 
false

CarRentalTest>>testRentingWithDates
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		carRental: 	a CarRental
		date: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:01:36.770264+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRentingWithDates)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:01:36.770264+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(CarRentalTest>>#testRentingWithDates)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set(#testR...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRentingWithDates)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRentingWithDates))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRentingWithDates))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(998430464)
		selectedItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
False(Object)>>doesNotUnderstand: #year:month:day:
CarRentalTest>>testRentingWithDates
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got an OrderedCollection(a Car) instead of 1.
22 June 2019 4:02:59.941928 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest(TestAsserter)>>assert:description:
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[ self comparingStringBetween: actual and: expected ]
		aString: 	'Got an OrderedCollection(a Car) instead of 1.'
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestAsserter)>>assert:equals:
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		actual: 	an OrderedCollection(a Car)
		expected: 	1
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest>>testRentingWithDates
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		carRental: 	a CarRental
		date: 	1 April 2019
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:02:59.930363+02:00
		failures: 	a Set(CarRentalTest>>#testRentingWithDates)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:02:59.930363+02:00
		failures: 	a Set(CarRentalTest>>#testRentingWithDates)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRentingWithDates) ...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRentingWithDates)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRentingWithDates))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRentingWithDates))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRentalTest(TestAsserter)>>assert:description:
CarRentalTest(TestAsserter)>>assert:equals:
CarRentalTest>>testRentingWithDates
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got an OrderedCollection() instead of 1.
22 June 2019 4:03:20.785624 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest(TestAsserter)>>assert:description:
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[ self comparingStringBetween: actual and: expected ]
		aString: 	'Got an OrderedCollection() instead of 1.'
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestAsserter)>>assert:equals:
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		actual: 	an OrderedCollection()
		expected: 	1
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest>>testRentingWithDates
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		carRental: 	a CarRental
		date: 	1 April 2019
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:03:20.77367+02:00
		failures: 	a Set(CarRentalTest>>#testRentingWithDates)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:03:20.77367+02:00
		failures: 	a Set(CarRentalTest>>#testRentingWithDates)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRentingWithDates) ...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRentingWithDates)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRentingWithDates))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRentingWithDates))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRentalTest(TestAsserter)>>assert:description:
CarRentalTest(TestAsserter)>>assert:equals:
CarRentalTest>>testRentingWithDates
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 1 instead of 0.
22 June 2019 4:24:03.325652 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest(TestAsserter)>>assert:description:
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[ self comparingStringBetween: actual and: expected ]
		aString: 	'Got 1 instead of 0.'
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestAsserter)>>assert:equals:
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		actual: 	1
		expected: 	0
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest>>testRentingWithDates
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		carRental: 	a CarRental
		date: 	1 April 2019
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:24:03.313298+02:00
		failures: 	a Set(CarRentalTest>>#testRentingWithDates)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:24:03.313298+02:00
		failures: 	a Set(CarRentalTest>>#testRentingWithDates)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRentingWithDates) ...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRentingWithDates)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRentingWithDates))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRentingWithDates))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRentalTest(TestAsserter)>>assert:description:
CarRentalTest(TestAsserter)>>assert:equals:
CarRentalTest>>testRentingWithDates
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 4:25:39.503935 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRentingWithDates
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		date: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:25:39.492333+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:25:39.492333+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set(#testC...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRentingWithDates)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRentingWithDates))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRentingWithDates))


--- The full stack ---
CarRentalTest>>testRentingWithDates
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 1 instead of 0.
22 June 2019 4:25:41.742529 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest(TestAsserter)>>assert:description:
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[ self comparingStringBetween: actual and: expected ]
		aString: 	'Got 1 instead of 0.'
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestAsserter)>>assert:equals:
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		actual: 	1
		expected: 	0
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest>>testRentingWithDates
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		date: 	1 April 2019
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:25:39.492333+02:00
		failures: 	a Set(CarRentalTest>>#testRentingWithDates)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:25:39.492333+02:00
		failures: 	a Set(CarRentalTest>>#testRentingWithDates)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set(#testC...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRentalTest(TestAsserter)>>assert:description:
CarRentalTest(TestAsserter)>>assert:equals:
CarRentalTest>>testRentingWithDates
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
UnwindError
22 June 2019 4:32:06.310204 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection>>remove:ifAbsent:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
		absentBlock: 	[ self errorNotFound: oldObject ]
		index: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>remove:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


Breakpoint>>remove
	Receiver: a Breakpoint
	Arguments and temporary variables: 

	Receiver's instance variables: 
		condition: 	nil
		link: 	a MetaLink
		node: 	testRentingWithDates
	"Extend the code and write a test for the following...etc...
		level: 	nil
		options: 	#(#+ #optionCompileOnLinkInstallation #+ #optionAnnounce)


[ breakpoint remove ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


Context>>resume:through:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		value: 	a MorphicUIManager
		firstUnwindContext: 	BlockClosure>>ensure:
		context: 	BlockClosure>>ensure:
		unwindBlock: 	[ breakpoint remove ]
	Receiver's instance variables: 
		sender: 	nil
		pc: 	nil
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ chain := thisContext sender cut: ctxt.
ctxt jump ]


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	true
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRentingWithDates)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRentingWithDates))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRentingWithDates))

ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyDebugTestCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyDebugTestCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(998430464)
		selectedItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		metaLevelScope: 	ClyInstanceSideScope


THERE_BE_DRAGONS_HERE
Break
22 June 2019 4:35:44.720182 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRentingWithDates
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		date: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:35:44.710361+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:35:44.710361+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRentingWithDates) ...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRentingWithDates)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRentingWithDates))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRentingWithDates))


--- The full stack ---
CarRentalTest>>testRentingWithDates
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 1 instead of 0.
22 June 2019 4:35:48.26666 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest(TestAsserter)>>assert:description:
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[ self comparingStringBetween: actual and: expected ]
		aString: 	'Got 1 instead of 0.'
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestAsserter)>>assert:equals:
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		actual: 	1
		expected: 	0
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest>>testRentingWithDates
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		date: 	1 April 2019
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:35:44.710361+02:00
		failures: 	a Set(CarRentalTest>>#testRentingWithDates)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:35:44.710361+02:00
		failures: 	a Set(CarRentalTest>>#testRentingWithDates)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRentingWithDates) ...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRentalTest(TestAsserter)>>assert:description:
CarRentalTest(TestAsserter)>>assert:equals:
CarRentalTest>>testRentingWithDates
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
UnwindError
22 June 2019 4:41:36.486952 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection>>remove:ifAbsent:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
		absentBlock: 	[ self errorNotFound: oldObject ]
		index: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>remove:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


Breakpoint>>remove
	Receiver: a Breakpoint
	Arguments and temporary variables: 

	Receiver's instance variables: 
		condition: 	nil
		link: 	a MetaLink
		node: 	testRentingWithDates
	"Extend the code and write a test for the following...etc...
		level: 	nil
		options: 	#(#+ #optionCompileOnLinkInstallation #+ #optionAnnounce)


[ breakpoint remove ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


Context>>resume:through:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		value: 	a MorphicUIManager
		firstUnwindContext: 	BlockClosure>>ensure:
		context: 	BlockClosure>>ensure:
		unwindBlock: 	[ breakpoint remove ]
	Receiver's instance variables: 
		sender: 	nil
		pc: 	nil
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ chain := thisContext sender cut: ctxt.
ctxt jump ]


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	true
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRentingWithDates)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRentingWithDates))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRentingWithDates))

ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyDebugTestCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyDebugTestCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(998430464)
		selectedItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		metaLevelScope: 	ClyInstanceSideScope


[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyDebugTestCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyDebugTestCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)


BlockClosure>>on:do:
	Receiver: [ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCom...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	77
		numArgs: 	0


CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyDebugTestCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyDebugTestCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)


[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(853017856)'Debug tests'
	Arguments and temporary variables: 
		evt: 	[(1644@784) mouseUp 22804903 nil]
		w: 	a WorldMorph(275485952) [world]
		selArgCount: 	0
	Receiver's instance variables: 
		bounds: 	(1579.0@774.0) corner: (1755.0@792.0)
		owner: 	a MenuMorph(558236416)
		submorphs: 	#()
		fullBounds: 	(1579.0@774.0) corner: (1755.0@792.0)
		color: 	Color black
		extension: 	a MorphExtension (819292416)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


BlockClosure>>ensure:
	Receiver: [ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := select...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	230
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |
"show cursor in case item opens a new MVC window"
(se...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(853017856)'Debug tests'
	Arguments and temporary variables: 
		evt: 	[(1644@784) mouseUp 22804903 nil]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(1579.0@774.0) corner: (1755.0@792.0)
		owner: 	a MenuMorph(558236416)
		submorphs: 	#()
		fullBounds: 	(1579.0@774.0) corner: (1755.0@792.0)
		color: 	Color black
		extension: 	a MorphExtension (819292416)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(853017856)'Debug tests'
	Arguments and temporary variables: 
		evt: 	[(1644@784) mouseUp 22804903 nil]
	Receiver's instance variables: 
		bounds: 	(1579.0@774.0) corner: (1755.0@792.0)
		owner: 	a MenuMorph(558236416)
		submorphs: 	#()
		fullBounds: 	(1579.0@774.0) corner: (1755.0@792.0)
		color: 	Color black
		extension: 	a MorphExtension (819292416)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(853017856)'Debug tests'
	Arguments and temporary variables: 
		anEvent: 	[(1644@784) mouseUp 22804903 nil]
	Receiver's instance variables: 
		bounds: 	(1579.0@774.0) corner: (1755.0@792.0)
		owner: 	a MenuMorph(558236416)
		submorphs: 	#()
		fullBounds: 	(1579.0@774.0) corner: (1755.0@792.0)
		color: 	Color black
		extension: 	a MorphExtension (819292416)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1644@784) mouseUp 22804903 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(853017856)'Debug tests'
	Receiver's instance variables: 
		timeStamp: 	22804903
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1644@784)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(853017856)'Debug tests'
	Arguments and temporary variables: 
		anEvent: 	[(1644@784) mouseUp 22804903 nil]
	Receiver's instance variables: 
		bounds: 	(1579.0@774.0) corner: (1755.0@792.0)
		owner: 	a MenuMorph(558236416)
		submorphs: 	#()
		fullBounds: 	(1579.0@774.0) corner: (1755.0@792.0)
		color: 	Color black
		extension: 	a MorphExtension (819292416)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1644@784) mouseUp 22804903 nil]
		aMorph: 	a ToggleMenuItemMorph(853017856)'Debug tests'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1644@784) mouseUp 22804903 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1644@784) mouseUp 22804903 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	22804903
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1644@784)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1644@784) mouseUp 22804903 nil]
		aMorph: 	a ToggleMenuItemMorph(853017856)'Debug tests'
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1644@784) mouseUp 22804903 nil]
		aMorph: 	a ToggleMenuItemMorph(853017856)'Debug tests'
	Receiver's instance variables: 
		morph: 	nil


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(853017856)'Debug tests'
	Arguments and temporary variables: 
		anEvent: 	[(1644@784) mouseUp 22804903 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(1579.0@774.0) corner: (1755.0@792.0)
		owner: 	a MenuMorph(558236416)
		submorphs: 	#()
		fullBounds: 	(1579.0@774.0) corner: (1755.0@792.0)
		color: 	Color black
		extension: 	a MorphExtension (819292416)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1644@784) mouseUp 22804903 nil]
		aMorph: 	a MenuMorph(558236416)
		localEvt: 	[(1644@784) mouseUp 22804903 nil]
		index: 	17
		child: 	a ToggleMenuItemMorph(853017856)'Debug tests'
		morphs: 	an Array(a ToggleMenuItemMorph(81842688)'Browse' a ToggleMenuItemMorph(...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1644@784) mouseUp 22804903 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1644@784) mouseUp 22804903 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	22804903
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1644@784)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1644@784) mouseUp 22804903 nil]
		aMorph: 	a MenuMorph(558236416)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove:
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
Breakpoint>>remove
[ breakpoint remove ] in ClyDebugTestCommand>>runTest:of:
Context>>resume:through:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 4:42:18.342722 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRentingWithDates
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		date: 	nil
		golf: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:42:18.331939+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:42:18.331939+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRentingWithDates) ...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRentingWithDates)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRentingWithDates))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRentingWithDates))


--- The full stack ---
CarRentalTest>>testRentingWithDates
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 6 instead of 5.
22 June 2019 4:42:20.195703 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest(TestAsserter)>>assert:description:
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[ self comparingStringBetween: actual and: expected ]
		aString: 	'Got 6 instead of 5.'
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestAsserter)>>assert:equals:
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		actual: 	6
		expected: 	5
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest>>testRentingWithDates
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		date: 	1 April 2019
		golf: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:42:18.331939+02:00
		failures: 	a Set(CarRentalTest>>#testRentingWithDates)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:42:18.331939+02:00
		failures: 	a Set(CarRentalTest>>#testRentingWithDates)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRentingWithDates) ...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRentalTest(TestAsserter)>>assert:description:
CarRentalTest(TestAsserter)>>assert:equals:
CarRentalTest>>testRentingWithDates
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
UnwindError
22 June 2019 4:42:59.062825 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection>>remove:ifAbsent:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
		absentBlock: 	[ self errorNotFound: oldObject ]
		index: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>remove:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


Breakpoint>>remove
	Receiver: a Breakpoint
	Arguments and temporary variables: 

	Receiver's instance variables: 
		condition: 	nil
		link: 	a MetaLink
		node: 	testRentingWithDates
	"Extend the code and write a test for the following...etc...
		level: 	nil
		options: 	#(#+ #optionCompileOnLinkInstallation #+ #optionAnnounce)


[ breakpoint remove ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


Context>>resume:through:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		value: 	a MorphicUIManager
		firstUnwindContext: 	BlockClosure>>ensure:
		context: 	BlockClosure>>ensure:
		unwindBlock: 	[ breakpoint remove ]
	Receiver's instance variables: 
		sender: 	nil
		pc: 	nil
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ chain := thisContext sender cut: ctxt.
ctxt jump ]


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	true
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRentingWithDates)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRentingWithDates))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRentingWithDates))

ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyDebugTestCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyDebugTestCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(767883776)
		selectedItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		metaLevelScope: 	ClyInstanceSideScope


[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyDebugTestCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyDebugTestCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)


BlockClosure>>on:do:
	Receiver: [ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCom...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	77
		numArgs: 	0


CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyDebugTestCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyDebugTestCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)


[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(254365184)'Debug tests'
	Arguments and temporary variables: 
		evt: 	[(1055@586) mouseUp 23198545 nil]
		w: 	a WorldMorph(275485952) [world]
		selArgCount: 	0
	Receiver's instance variables: 
		bounds: 	(1006.0@571.0) corner: (1182.0@589.0)
		owner: 	a MenuMorph(457293824)
		submorphs: 	#()
		fullBounds: 	(1006.0@571.0) corner: (1182.0@589.0)
		color: 	Color black
		extension: 	a MorphExtension (425946368)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


BlockClosure>>ensure:
	Receiver: [ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := select...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	230
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |
"show cursor in case item opens a new MVC window"
(se...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(254365184)'Debug tests'
	Arguments and temporary variables: 
		evt: 	[(1055@586) mouseUp 23198545 nil]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(1006.0@571.0) corner: (1182.0@589.0)
		owner: 	a MenuMorph(457293824)
		submorphs: 	#()
		fullBounds: 	(1006.0@571.0) corner: (1182.0@589.0)
		color: 	Color black
		extension: 	a MorphExtension (425946368)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(254365184)'Debug tests'
	Arguments and temporary variables: 
		evt: 	[(1055@586) mouseUp 23198545 nil]
	Receiver's instance variables: 
		bounds: 	(1006.0@571.0) corner: (1182.0@589.0)
		owner: 	a MenuMorph(457293824)
		submorphs: 	#()
		fullBounds: 	(1006.0@571.0) corner: (1182.0@589.0)
		color: 	Color black
		extension: 	a MorphExtension (425946368)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(254365184)'Debug tests'
	Arguments and temporary variables: 
		anEvent: 	[(1055@586) mouseUp 23198545 nil]
	Receiver's instance variables: 
		bounds: 	(1006.0@571.0) corner: (1182.0@589.0)
		owner: 	a MenuMorph(457293824)
		submorphs: 	#()
		fullBounds: 	(1006.0@571.0) corner: (1182.0@589.0)
		color: 	Color black
		extension: 	a MorphExtension (425946368)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1055@586) mouseUp 23198545 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(254365184)'Debug tests'
	Receiver's instance variables: 
		timeStamp: 	23198545
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1055@586)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(254365184)'Debug tests'
	Arguments and temporary variables: 
		anEvent: 	[(1055@586) mouseUp 23198545 nil]
	Receiver's instance variables: 
		bounds: 	(1006.0@571.0) corner: (1182.0@589.0)
		owner: 	a MenuMorph(457293824)
		submorphs: 	#()
		fullBounds: 	(1006.0@571.0) corner: (1182.0@589.0)
		color: 	Color black
		extension: 	a MorphExtension (425946368)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1055@586) mouseUp 23198545 nil]
		aMorph: 	a ToggleMenuItemMorph(254365184)'Debug tests'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1055@586) mouseUp 23198545 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1055@586) mouseUp 23198545 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	23198545
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1055@586)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1055@586) mouseUp 23198545 nil]
		aMorph: 	a ToggleMenuItemMorph(254365184)'Debug tests'
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1055@586) mouseUp 23198545 nil]
		aMorph: 	a ToggleMenuItemMorph(254365184)'Debug tests'
	Receiver's instance variables: 
		morph: 	nil


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(254365184)'Debug tests'
	Arguments and temporary variables: 
		anEvent: 	[(1055@586) mouseUp 23198545 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(1006.0@571.0) corner: (1182.0@589.0)
		owner: 	a MenuMorph(457293824)
		submorphs: 	#()
		fullBounds: 	(1006.0@571.0) corner: (1182.0@589.0)
		color: 	Color black
		extension: 	a MorphExtension (425946368)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1055@586) mouseUp 23198545 nil]
		aMorph: 	a MenuMorph(457293824)
		localEvt: 	[(1055@586) mouseUp 23198545 nil]
		index: 	17
		child: 	a ToggleMenuItemMorph(254365184)'Debug tests'
		morphs: 	an Array(a ToggleMenuItemMorph(247362048)'Browse' a ToggleMenuItemMorph...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1055@586) mouseUp 23198545 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1055@586) mouseUp 23198545 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	23198545
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1055@586)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1055@586) mouseUp 23198545 nil]
		aMorph: 	a MenuMorph(457293824)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove:
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
Breakpoint>>remove
[ breakpoint remove ] in ClyDebugTestCommand>>runTest:of:
Context>>resume:through:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 4:43:05.69315 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRentingWithDates
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		date: 	nil
		golf: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:43:05.682202+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:43:05.682202+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRentingWithDates) ...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRentingWithDates)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRentingWithDates))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRentingWithDates))


--- The full stack ---
CarRentalTest>>testRentingWithDates
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 6 instead of 5.
22 June 2019 4:43:07.812014 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest(TestAsserter)>>assert:description:
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[ self comparingStringBetween: actual and: expected ]
		aString: 	'Got 6 instead of 5.'
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestAsserter)>>assert:equals:
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		actual: 	6
		expected: 	5
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest>>testRentingWithDates
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		date: 	1 April 2019
		golf: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:43:05.682202+02:00
		failures: 	a Set(CarRentalTest>>#testRentingWithDates)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:43:05.682202+02:00
		failures: 	a Set(CarRentalTest>>#testRentingWithDates)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRentingWithDates) ...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRentalTest(TestAsserter)>>assert:description:
CarRentalTest(TestAsserter)>>assert:equals:
CarRentalTest>>testRentingWithDates
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 4:44:51.804011 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testRentingWithDates
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		date: 	nil
		golf: 	nil
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:44:51.793975+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:44:51.793975+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set(#testC...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testRentingWithDates)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testRentingWithDates))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testRentingWithDates))


--- The full stack ---
CarRentalTest>>testRentingWithDates
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 6 instead of 5.
22 June 2019 4:44:53.28162 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest(TestAsserter)>>assert:description:
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[ self comparingStringBetween: actual and: expected ]
		aString: 	'Got 6 instead of 5.'
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestAsserter)>>assert:equals:
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		actual: 	6
		expected: 	5
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest>>testRentingWithDates
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		date: 	1 April 2019
		golf: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testRentingWithDates
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:44:51.793975+02:00
		failures: 	a Set(CarRentalTest>>#testRentingWithDates)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testRentingWithDates
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:44:51.793975+02:00
		failures: 	a Set(CarRentalTest>>#testRentingWithDates)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testRentingWithDates
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testRentingWithDates
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testRentingWithDates
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set(#testC...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testRentingWithDates
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testRentingWithDates)
		testSelector: 	#testRentingWithDates
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testRentingWithDates))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRentalTest(TestAsserter)>>assert:description:
CarRentalTest(TestAsserter)>>assert:equals:
CarRentalTest>>testRentingWithDates
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 2 instead of 1.
22 June 2019 4:54:37.883167 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest(TestAsserter)>>assert:description:
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[ self comparingStringBetween: actual and: expected ]
		aString: 	'Got 2 instead of 1.'
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest(TestAsserter)>>assert:equals:
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		actual: 	2
		expected: 	1
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest>>testCarIsAvailable
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:54:37.870977+02:00
		failures: 	a Set(CarRentalTest>>#testCarIsAvailable)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:54:37.870977+02:00
		failures: 	a Set(CarRentalTest>>#testCarIsAvailable)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRentingWithDates) ...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testCarIsAvailable)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testCarIsAvailable))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testCarIsAvailable))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRentalTest(TestAsserter)>>assert:description:
CarRentalTest(TestAsserter)>>assert:equals:
CarRentalTest>>testCarIsAvailable
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 4:56:34.896426 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testCarIsAvailable
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:56:34.885884+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:56:34.885884+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRentingWithDates) ...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testCarIsAvailable)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testCarIsAvailable))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testCarIsAvailable))


--- The full stack ---
CarRentalTest>>testCarIsAvailable
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 2 instead of 1.
22 June 2019 4:56:36.27282 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest(TestAsserter)>>assert:description:
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[ self comparingStringBetween: actual and: expected ]
		aString: 	'Got 2 instead of 1.'
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest(TestAsserter)>>assert:equals:
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		actual: 	2
		expected: 	1
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest>>testCarIsAvailable
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:56:34.885884+02:00
		failures: 	a Set(CarRentalTest>>#testCarIsAvailable)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:56:34.885884+02:00
		failures: 	a Set(CarRentalTest>>#testCarIsAvailable)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRentingWithDates) ...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRentalTest(TestAsserter)>>assert:description:
CarRentalTest(TestAsserter)>>assert:equals:
CarRentalTest>>testCarIsAvailable
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 4:57:04.756274 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testCarIsAvailable
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	nil
		redPanda: 	nil
		yellowPanda: 	nil
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:57:04.744483+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:57:04.744483+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRentingWithDates) ...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testCarIsAvailable)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testCarIsAvailable))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testCarIsAvailable))


--- The full stack ---
CarRentalTest>>testCarIsAvailable
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 2 instead of 1.
22 June 2019 4:57:08.378983 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest(TestAsserter)>>assert:description:
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[ self comparingStringBetween: actual and: expected ]
		aString: 	'Got 2 instead of 1.'
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest(TestAsserter)>>assert:equals:
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		actual: 	2
		expected: 	1
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest>>testCarIsAvailable
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait ...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:57:04.744483+02:00
		failures: 	a Set(CarRentalTest>>#testCarIsAvailable)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:57:04.744483+02:00
		failures: 	a Set(CarRentalTest>>#testCarIsAvailable)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testRentingWithDates) ...etc...


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRentalTest(TestAsserter)>>assert:description:
CarRentalTest(TestAsserter)>>assert:equals:
CarRentalTest>>testCarIsAvailable
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTest:of:
[ super runTest: testSelector of: testClass ] in ClyDebugTestCommand>>runTest:of:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
UnwindError
22 June 2019 4:57:33.055589 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

OrderedCollection(Collection)>>errorNotFound:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection>>remove:ifAbsent:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
		absentBlock: 	[ self errorNotFound: oldObject ]
		index: 	1
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


OrderedCollection(Collection)>>remove:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		oldObject: 	a Breakpoint
	Receiver's instance variables: 
		array: 	#(nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


Breakpoint>>remove
	Receiver: a Breakpoint
	Arguments and temporary variables: 

	Receiver's instance variables: 
		condition: 	nil
		link: 	a MetaLink
		node: 	testCarIsAvailable
	| carRental redPanda yellowPanda |
	carRental := CarR...etc...
		level: 	nil
		options: 	#(#+ #optionCompileOnLinkInstallation #+ #optionAnnounce)


[ breakpoint remove ] in ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


Context>>resume:through:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		value: 	a MorphicUIManager
		firstUnwindContext: 	BlockClosure>>ensure:
		context: 	BlockClosure>>ensure:
		unwindBlock: 	[ breakpoint remove ]
	Receiver's instance variables: 
		sender: 	nil
		pc: 	nil
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ chain := thisContext sender cut: ctxt.
ctxt jump ]


BlockClosure>>ensure:
	Receiver: [ super runTest: testSelector of: testClass ]
	Arguments and temporary variables: 
		aBlock: 	[ breakpoint remove ]
		complete: 	true
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyDebugTestCommand>>runTest:of:
		startpc: 	106
		numArgs: 	0


ClyDebugTestCommand>>runTest:of:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		breakpoint: 	a Breakpoint
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testCarIsAvailable)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testCarIsAvailable))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testCarIsAvailable))

ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
	Receiver: a ClyDebugTestCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyDebugTestCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyDebugTestCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(767883776)
		selectedItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		metaLevelScope: 	ClyInstanceSideScope


[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyDebugTestCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyDebugTestCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)


BlockClosure>>on:do:
	Receiver: [ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCom...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	77
		numArgs: 	0


CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyDebugTestCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyDebugTestCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)


[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(678884608)'Debug tests'
	Arguments and temporary variables: 
		evt: 	[(1293@497) mouseUp 24085032 nil]
		w: 	a WorldMorph(275485952) [world]
		selArgCount: 	0
	Receiver's instance variables: 
		bounds: 	(1244.0@485.0) corner: (1420.0@503.0)
		owner: 	a MenuMorph(733640192)
		submorphs: 	#()
		fullBounds: 	(1244.0@485.0) corner: (1420.0@503.0)
		color: 	Color black
		extension: 	a MorphExtension (1038399232)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


BlockClosure>>ensure:
	Receiver: [ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := select...etc...
	Arguments and temporary variables: 
		aBlock: 	[ oldcursor show ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	230
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |
"show cursor in case item opens a new MVC window"
(se...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(678884608)'Debug tests'
	Arguments and temporary variables: 
		evt: 	[(1293@497) mouseUp 24085032 nil]
		w: 	a WorldMorph(275485952) [world]
	Receiver's instance variables: 
		bounds: 	(1244.0@485.0) corner: (1420.0@503.0)
		owner: 	a MenuMorph(733640192)
		submorphs: 	#()
		fullBounds: 	(1244.0@485.0) corner: (1420.0@503.0)
		color: 	Color black
		extension: 	a MorphExtension (1038399232)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(678884608)'Debug tests'
	Arguments and temporary variables: 
		evt: 	[(1293@497) mouseUp 24085032 nil]
	Receiver's instance variables: 
		bounds: 	(1244.0@485.0) corner: (1420.0@503.0)
		owner: 	a MenuMorph(733640192)
		submorphs: 	#()
		fullBounds: 	(1244.0@485.0) corner: (1420.0@503.0)
		color: 	Color black
		extension: 	a MorphExtension (1038399232)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(678884608)'Debug tests'
	Arguments and temporary variables: 
		anEvent: 	[(1293@497) mouseUp 24085032 nil]
	Receiver's instance variables: 
		bounds: 	(1244.0@485.0) corner: (1420.0@503.0)
		owner: 	a MenuMorph(733640192)
		submorphs: 	#()
		fullBounds: 	(1244.0@485.0) corner: (1420.0@503.0)
		color: 	Color black
		extension: 	a MorphExtension (1038399232)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1293@497) mouseUp 24085032 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(678884608)'Debug tests'
	Receiver's instance variables: 
		timeStamp: 	24085032
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1293@497)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(678884608)'Debug tests'
	Arguments and temporary variables: 
		anEvent: 	[(1293@497) mouseUp 24085032 nil]
	Receiver's instance variables: 
		bounds: 	(1244.0@485.0) corner: (1420.0@503.0)
		owner: 	a MenuMorph(733640192)
		submorphs: 	#()
		fullBounds: 	(1244.0@485.0) corner: (1420.0@503.0)
		color: 	Color black
		extension: 	a MorphExtension (1038399232)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1293@497) mouseUp 24085032 nil]
		aMorph: 	a ToggleMenuItemMorph(678884608)'Debug tests'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1293@497) mouseUp 24085032 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1293@497) mouseUp 24085032 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	24085032
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1293@497)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1293@497) mouseUp 24085032 nil]
		aMorph: 	a ToggleMenuItemMorph(678884608)'Debug tests'
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1293@497) mouseUp 24085032 nil]
		aMorph: 	a ToggleMenuItemMorph(678884608)'Debug tests'
	Receiver's instance variables: 
		morph: 	nil


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(678884608)'Debug tests'
	Arguments and temporary variables: 
		anEvent: 	[(1293@497) mouseUp 24085032 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(1244.0@485.0) corner: (1420.0@503.0)
		owner: 	a MenuMorph(733640192)
		submorphs: 	#()
		fullBounds: 	(1244.0@485.0) corner: (1420.0@503.0)
		color: 	Color black
		extension: 	a MorphExtension (1038399232)
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Debug tests'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a CmdCommandActivator(a ClyDebugTestCommand)
		selector: 	#executeCommand
		arguments: 	#()
		icon: 	Form(16x16x32)
		keyText: 	'd'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1293@497) mouseUp 24085032 nil]
		aMorph: 	a MenuMorph(733640192)
		localEvt: 	[(1293@497) mouseUp 24085032 nil]
		index: 	17
		child: 	a ToggleMenuItemMorph(678884608)'Debug tests'
		morphs: 	an Array(a ToggleMenuItemMorph(852984576)'Browse' a ToggleMenuItemMorph...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1293@497) mouseUp 24085032 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(1293@497) mouseUp 24085032 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	24085032
		source: 	a HandMorph(810749440)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(1293@497)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(1293@497) mouseUp 24085032 nil]
		aMorph: 	a MenuMorph(733640192)
	Receiver's instance variables: 
		morph: 	nil


BlockClosure>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	48
		numArgs: 	0



--- The full stack ---
OrderedCollection(Collection)>>errorNotFound:
[ self errorNotFound: oldObject ] in OrderedCollection(Collection)>>remove:
OrderedCollection>>remove:ifAbsent:
OrderedCollection(Collection)>>remove:
Breakpoint>>remove
[ breakpoint remove ] in ClyDebugTestCommand>>runTest:of:
Context>>resume:through:
BlockClosure>>ensure:
ClyDebugTestCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
IdentitySet(Set)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>runTestItem:
[ :each | self runTestItem: each ] in ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
Array(SequenceableCollection)>>do:
ClyDebugTestCommand(ClyRunTestsFromMethodsCommand)>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 2 instead of 1.
22 June 2019 4:57:44.100737 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest(TestAsserter)>>assert:description:
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[ self comparingStringBetween: actual and: expected ]
		aString: 	'Got 2 instead of 1.'
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest(TestAsserter)>>assert:equals:
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		actual: 	2
		expected: 	1
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest>>testCarIsAvailable
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:57:44.088067+02:00
		failures: 	a Set(CarRentalTest>>#testCarIsAvailable)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:57:44.088067+02:00
		failures: 	a Set(CarRentalTest>>#testCarIsAvailable)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testCarIsAvailable #te...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testCarIsAvailable)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testCarIsAvailable))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testCarIsAvailable))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRentalTest(TestAsserter)>>assert:description:
CarRentalTest(TestAsserter)>>assert:equals:
CarRentalTest>>testCarIsAvailable
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 2 instead of 1.
22 June 2019 4:57:45.886093 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest(TestAsserter)>>assert:description:
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[ self comparingStringBetween: actual and: expected ]
		aString: 	'Got 2 instead of 1.'
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	#()


CarRentalTest(TestAsserter)>>assert:equals:
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		actual: 	2
		expected: 	1
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	#()


CarRentalTest>>testCarIsAvailable
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	#()


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	#()


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in Process>>terminate a Process in [ delay...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:57:44.088067+02:00
		failures: 	a Set(CarRentalTest>>#testCarIsAvailable)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T16:57:44.088067+02:00
		failures: 	a Set(CarRentalTest>>#testCarIsAvailable)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	#()


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testCarIsAvailable #te...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testCarIsAvailable)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testCarIsAvailable))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testCarIsAvailable))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}



--- The full stack ---
CarRentalTest(TestAsserter)>>assert:description:
CarRentalTest(TestAsserter)>>assert:equals:
CarRentalTest>>testCarIsAvailable
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 5:01:16.082678 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testCarIsAvailable
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ [ root insertSender: thisContext.
cur...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ [ root insertSender: thisContext.
cur...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ [ root insertSender: thisContext.
cur...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ [ root insertSender: thisContext.
cur...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ [ root insertSender: thisContext.
cur...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ [ root insertSender: thisContext.
cur...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ [ root insertSender: thisContext.
cur...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T17:01:16.033084+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T17:01:16.033084+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testCarIsAvailable #te...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testCarIsAvailable)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testCarIsAvailable))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testCarIsAvailable))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(767883776)
		selectedItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		metaLevelScope: 	ClyInstanceSideScope


[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)



--- The full stack ---
CarRentalTest>>testCarIsAvailable
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 5:01:52.204046 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testCarIsAvailable
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T17:01:52.192458+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T17:01:52.192458+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testCarIsAvailable #te...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testCarIsAvailable)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testCarIsAvailable))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testCarIsAvailable))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(767883776)
		selectedItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		metaLevelScope: 	ClyInstanceSideScope


[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)



--- The full stack ---
CarRentalTest>>testCarIsAvailable
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 5:02:00.659758 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testCarIsAvailable
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T17:02:00.649278+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T17:02:00.649278+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testCarIsAvailable #te...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testCarIsAvailable)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testCarIsAvailable))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testCarIsAvailable))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(767883776)
		selectedItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		metaLevelScope: 	ClyInstanceSideScope


[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)



--- The full stack ---
CarRentalTest>>testCarIsAvailable
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 5:04:46.08035 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testCarIsAvailable
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T17:04:46.068499+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T17:04:46.068499+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testCarIsAvailable #te...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testCarIsAvailable)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testCarIsAvailable))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testCarIsAvailable))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(767883776)
		selectedItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		metaLevelScope: 	ClyInstanceSideScope


[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)



--- The full stack ---
CarRentalTest>>testCarIsAvailable
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Break
22 June 2019 5:22:34.258494 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
StackToRegisterMappingCogit VMMaker.oscog-eem.2504 uuid: a00b0fad-c04c-47a6-8a11-5dbff110ac11 Jan  5 2019
VM: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Sat Jan 5 20:00:11 2019 CommitHash: 7a3c6b64 Plugins: 201901051900 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0.2 [Build information: Pharo-7.0.2+build.154.sha.9f17218676db0c1a0dd5d1b03226e660dbd674b6 (64 Bit)]

CarRentalTest>>testCarIsAvailable
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		RFReifyValueVar: 	nil
		carRental: 	a CarRental
		redPanda: 	a Car
		yellowPanda: 	a Car
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest(TestCase)>>performTest
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>runCase
		startpc: 	97
		numArgs: 	0


CarRentalTest(TestCase)>>runCase
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	115
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	110
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	101
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	96
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	91
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	CarRentalTest>>#testCarIsAvailable
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


CarRentalTest(TestCase)>>runCaseManaged
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T17:22:34.246723+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	150
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	CarRentalTest>>#testCarIsAvailable
	Receiver's instance variables: 
		timeStamp: 	2019-06-22T17:22:34.246723+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CarRentalTest(TestCase)>>debug
		startpc: 	90
		numArgs: 	0


CarRentalTest(TestCase)>>debug
	Receiver: CarRentalTest>>#testCarIsAvailable
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCarIsAvailable
		expectedFails: 	nil


CarRentalTest class(TestCase class)>>debug:
	Receiver: CarRentalTest
	Arguments and temporary variables: 
		aSymbol: 	#testCarIsAvailable
	Receiver's instance variables: 
		superclass: 	TestCase
		methodDict: 	a MethodDictionary(#testBooleanCondition->CarRentalTest>>#testBoole...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CarRentalTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LifewareHR-Tests'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testCarIsAvailable #te...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testCarIsAvailable
		testClass: 	CarRentalTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
		each: 	CarRentalTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(CarRentalTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	4
		each: 	CarRentalTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. CarRentalTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testCarIsAvailable)
		testSelector: 	#testCarIsAvailable
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testCarIsAvailable)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testCarIsAvailable))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testCarIsAvailable))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		runTestCases: 	{CarRentalTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(767883776)
		selectedItems: 	an Array(a ClyDataSourceItem(testCarIsAvailable))
		metaLevelScope: 	ClyInstanceSideScope


[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyMethodContextOfFullBrowser
		activationStrategy: 	a CmdContextMenuActivation(CmdRootMenuGroup; 1000)



--- The full stack ---
CarRentalTest>>testCarIsAvailable
CarRentalTest(TestCase)>>performTest
[ self setUp.
self performTest ] in CarRentalTest(TestCase)>>runCase
BlockClosure>>ensure:
CarRentalTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CarRentalTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CarRentalTest(TestCase)>>debug
BlockClosure>>ensure:
CarRentalTest(TestCase)>>debug
CarRentalTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

